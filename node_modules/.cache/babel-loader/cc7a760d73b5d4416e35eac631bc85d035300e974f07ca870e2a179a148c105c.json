{"ast":null,"code":"/*!\n * Copyright (c) 2018 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n\nmodule.exports = class ProofPurpose {\n  /**\n   * @param term {string} the `proofPurpose` term, as defined in the\n   *    SECURITY_CONTEXT_URL `@context` or a URI if not defined in such.\n   * @param [date] {string or Date or integer} the expected date for\n   *   the creation of the proof.\n   * @param [maxTimestampDelta] {integer} a maximum number of seconds that\n   *   the date on the signature can deviate from, defaults to `Infinity`.\n   */\n  constructor({\n    term,\n    date,\n    maxTimestampDelta = Infinity\n  } = {}) {\n    if (term === undefined) {\n      throw new Error('\"term\" is required.');\n    }\n    if (maxTimestampDelta !== undefined && typeof maxTimestampDelta !== 'number') {\n      throw new TypeError('\"maxTimestampDelta\" must be a number.');\n    }\n    this.term = term;\n    if (date !== undefined) {\n      this.date = new Date(date);\n      if (isNaN(this.date)) {\n        throw TypeError(`\"date\" \"${date}\" is not a valid date.`);\n      }\n    }\n    this.maxTimestampDelta = maxTimestampDelta;\n  }\n\n  /**\n   * Called to validate the purpose of a proof. This method is called during\n   * proof verification, after the proof value has been checked against the\n   * given verification method (e.g. in the case of a digital signature, the\n   * signature has been cryptographically verified against the public key).\n   *\n   * @param proof {object} the proof, in the `constants.SECURITY_CONTEXT_URL`,\n   *   with the matching purpose to validate.\n   *\n   * @return {Promise<object>} resolves to an object with `valid` and `error`.\n   */\n  async validate(proof, {\n    /*document, suite, verificationMethod,\n    documentLoader,*/\n    expansionMap\n  }) {\n    if (expansionMap) {\n      throw new Error('\"expansionMap\" not supported.');\n    }\n    try {\n      // check expiration\n      if (this.maxTimestampDelta !== Infinity) {\n        const expected = (this.date || new Date()).getTime();\n        const delta = this.maxTimestampDelta * 1000;\n        const created = new Date(proof.created).getTime();\n        // comparing this way handles NaN case where `created` is invalid\n        if (!(created >= expected - delta && created <= expected + delta)) {\n          throw new Error('The proof\\'s created timestamp is out of range.');\n        }\n      }\n      return {\n        valid: true\n      };\n    } catch (error) {\n      return {\n        valid: false,\n        error\n      };\n    }\n  }\n\n  /**\n   * Called to update a proof when it is being created, adding any properties\n   * specific to this purpose. This method is called prior to the proof\n   * value being generated such that any properties added may be, for example,\n   * included in a digital signature value.\n   *\n   * @param proof {object} the proof, in the `constants.SECURITY_CONTEXT_URL`\n   *   to update.\n   *\n   * @return {Promise<object>} resolves to the proof instance (in the\n   *   `constants.SECURITY_CONTEXT_URL`.\n   */\n  async update(proof, {\n    /*document, suite, documentLoader,*/expansionMap\n  }) {\n    if (expansionMap) {\n      throw new Error('\"expansionMap\" not supported.');\n    }\n    proof.proofPurpose = this.term;\n    return proof;\n  }\n\n  /**\n   * Determines if the given proof has a purpose that matches this instance,\n   * i.e. this ProofPurpose instance should be used to validate the given\n   * proof.\n   *\n   * @param proof {object} the proof to check.\n   *\n   * @return {Promise<boolean>} `true` if there's a match, `false` if not.\n   */\n  async match(proof, {\n    /* document, documentLoader,*/expansionMap\n  }) {\n    if (expansionMap) {\n      throw new Error('\"expansionMap\" not supported.');\n    }\n    return proof.proofPurpose === this.term;\n  }\n};","map":{"version":3,"names":["module","exports","ProofPurpose","constructor","term","date","maxTimestampDelta","Infinity","undefined","Error","TypeError","Date","isNaN","validate","proof","expansionMap","expected","getTime","delta","created","valid","error","update","proofPurpose","match"],"sources":["/home/pratap/did-linked-domain/node_modules/jsonld-signatures/lib/purposes/ProofPurpose.js"],"sourcesContent":["/*!\n * Copyright (c) 2018 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n\nmodule.exports = class ProofPurpose {\n  /**\n   * @param term {string} the `proofPurpose` term, as defined in the\n   *    SECURITY_CONTEXT_URL `@context` or a URI if not defined in such.\n   * @param [date] {string or Date or integer} the expected date for\n   *   the creation of the proof.\n   * @param [maxTimestampDelta] {integer} a maximum number of seconds that\n   *   the date on the signature can deviate from, defaults to `Infinity`.\n   */\n  constructor({term, date, maxTimestampDelta = Infinity} = {}) {\n    if(term === undefined) {\n      throw new Error('\"term\" is required.');\n    }\n    if(maxTimestampDelta !== undefined &&\n      typeof maxTimestampDelta !== 'number') {\n      throw new TypeError('\"maxTimestampDelta\" must be a number.');\n    }\n    this.term = term;\n    if(date !== undefined) {\n      this.date = new Date(date);\n      if(isNaN(this.date)) {\n        throw TypeError(`\"date\" \"${date}\" is not a valid date.`);\n      }\n    }\n    this.maxTimestampDelta = maxTimestampDelta;\n  }\n\n  /**\n   * Called to validate the purpose of a proof. This method is called during\n   * proof verification, after the proof value has been checked against the\n   * given verification method (e.g. in the case of a digital signature, the\n   * signature has been cryptographically verified against the public key).\n   *\n   * @param proof {object} the proof, in the `constants.SECURITY_CONTEXT_URL`,\n   *   with the matching purpose to validate.\n   *\n   * @return {Promise<object>} resolves to an object with `valid` and `error`.\n   */\n  async validate(\n    proof, {/*document, suite, verificationMethod,\n      documentLoader,*/ expansionMap}) {\n    if(expansionMap) {\n      throw new Error('\"expansionMap\" not supported.');\n    }\n\n    try {\n      // check expiration\n      if(this.maxTimestampDelta !== Infinity) {\n        const expected = (this.date || new Date()).getTime();\n        const delta = this.maxTimestampDelta * 1000;\n        const created = new Date(proof.created).getTime();\n        // comparing this way handles NaN case where `created` is invalid\n        if(!(created >= (expected - delta) && created <= (expected + delta))) {\n          throw new Error('The proof\\'s created timestamp is out of range.');\n        }\n      }\n      return {valid: true};\n    } catch(error) {\n      return {valid: false, error};\n    }\n  }\n\n  /**\n   * Called to update a proof when it is being created, adding any properties\n   * specific to this purpose. This method is called prior to the proof\n   * value being generated such that any properties added may be, for example,\n   * included in a digital signature value.\n   *\n   * @param proof {object} the proof, in the `constants.SECURITY_CONTEXT_URL`\n   *   to update.\n   *\n   * @return {Promise<object>} resolves to the proof instance (in the\n   *   `constants.SECURITY_CONTEXT_URL`.\n   */\n  async update(proof, {/*document, suite, documentLoader,*/ expansionMap}) {\n    if(expansionMap) {\n      throw new Error('\"expansionMap\" not supported.');\n    }\n    proof.proofPurpose = this.term;\n    return proof;\n  }\n\n  /**\n   * Determines if the given proof has a purpose that matches this instance,\n   * i.e. this ProofPurpose instance should be used to validate the given\n   * proof.\n   *\n   * @param proof {object} the proof to check.\n   *\n   * @return {Promise<boolean>} `true` if there's a match, `false` if not.\n   */\n  async match(proof, {/* document, documentLoader,*/ expansionMap}) {\n    if(expansionMap) {\n      throw new Error('\"expansionMap\" not supported.');\n    }\n    return proof.proofPurpose === this.term;\n  }\n};\n"],"mappings":"AAAA;AACA;AACA;AACA,YAAY;;AAEZA,MAAM,CAACC,OAAO,GAAG,MAAMC,YAAY,CAAC;EAClC;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACEC,WAAWA,CAAC;IAACC,IAAI;IAAEC,IAAI;IAAEC,iBAAiB,GAAGC;EAAQ,CAAC,GAAG,CAAC,CAAC,EAAE;IAC3D,IAAGH,IAAI,KAAKI,SAAS,EAAE;MACrB,MAAM,IAAIC,KAAK,CAAC,qBAAqB,CAAC;IACxC;IACA,IAAGH,iBAAiB,KAAKE,SAAS,IAChC,OAAOF,iBAAiB,KAAK,QAAQ,EAAE;MACvC,MAAM,IAAII,SAAS,CAAC,uCAAuC,CAAC;IAC9D;IACA,IAAI,CAACN,IAAI,GAAGA,IAAI;IAChB,IAAGC,IAAI,KAAKG,SAAS,EAAE;MACrB,IAAI,CAACH,IAAI,GAAG,IAAIM,IAAI,CAACN,IAAI,CAAC;MAC1B,IAAGO,KAAK,CAAC,IAAI,CAACP,IAAI,CAAC,EAAE;QACnB,MAAMK,SAAS,CAAE,WAAUL,IAAK,wBAAuB,CAAC;MAC1D;IACF;IACA,IAAI,CAACC,iBAAiB,GAAGA,iBAAiB;EAC5C;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,MAAMO,QAAQA,CACZC,KAAK,EAAE;IAAC;AACZ;IAAwBC;EAAY,CAAC,EAAE;IACnC,IAAGA,YAAY,EAAE;MACf,MAAM,IAAIN,KAAK,CAAC,+BAA+B,CAAC;IAClD;IAEA,IAAI;MACF;MACA,IAAG,IAAI,CAACH,iBAAiB,KAAKC,QAAQ,EAAE;QACtC,MAAMS,QAAQ,GAAG,CAAC,IAAI,CAACX,IAAI,IAAI,IAAIM,IAAI,CAAC,CAAC,EAAEM,OAAO,CAAC,CAAC;QACpD,MAAMC,KAAK,GAAG,IAAI,CAACZ,iBAAiB,GAAG,IAAI;QAC3C,MAAMa,OAAO,GAAG,IAAIR,IAAI,CAACG,KAAK,CAACK,OAAO,CAAC,CAACF,OAAO,CAAC,CAAC;QACjD;QACA,IAAG,EAAEE,OAAO,IAAKH,QAAQ,GAAGE,KAAM,IAAIC,OAAO,IAAKH,QAAQ,GAAGE,KAAM,CAAC,EAAE;UACpE,MAAM,IAAIT,KAAK,CAAC,iDAAiD,CAAC;QACpE;MACF;MACA,OAAO;QAACW,KAAK,EAAE;MAAI,CAAC;IACtB,CAAC,CAAC,OAAMC,KAAK,EAAE;MACb,OAAO;QAACD,KAAK,EAAE,KAAK;QAAEC;MAAK,CAAC;IAC9B;EACF;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,MAAMC,MAAMA,CAACR,KAAK,EAAE;IAAC,oCAAqCC;EAAY,CAAC,EAAE;IACvE,IAAGA,YAAY,EAAE;MACf,MAAM,IAAIN,KAAK,CAAC,+BAA+B,CAAC;IAClD;IACAK,KAAK,CAACS,YAAY,GAAG,IAAI,CAACnB,IAAI;IAC9B,OAAOU,KAAK;EACd;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,MAAMU,KAAKA,CAACV,KAAK,EAAE;IAAC,8BAA+BC;EAAY,CAAC,EAAE;IAChE,IAAGA,YAAY,EAAE;MACf,MAAM,IAAIN,KAAK,CAAC,+BAA+B,CAAC;IAClD;IACA,OAAOK,KAAK,CAACS,YAAY,KAAK,IAAI,CAACnB,IAAI;EACzC;AACF,CAAC"},"metadata":{},"sourceType":"script","externalDependencies":[]}