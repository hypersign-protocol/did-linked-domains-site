{"ast":null,"code":"/*\n * Copyright (c) 2017 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n\nrequire(\"core-js/modules/es.array.push.js\");\nconst JsonLdError = require('./JsonLdError');\nconst {\n  isArray: _isArray,\n  isObject: _isObject,\n  isEmptyObject: _isEmptyObject,\n  isString: _isString,\n  isUndefined: _isUndefined\n} = require('./types');\nconst {\n  isList: _isList,\n  isValue: _isValue,\n  isGraph: _isGraph,\n  isSubject: _isSubject\n} = require('./graphTypes');\nconst {\n  expandIri: _expandIri,\n  getContextValue: _getContextValue,\n  isKeyword: _isKeyword,\n  process: _processContext,\n  processingMode: _processingMode\n} = require('./context');\nconst {\n  isAbsolute: _isAbsoluteIri\n} = require('./url');\nconst {\n  REGEX_BCP47,\n  REGEX_KEYWORD,\n  addValue: _addValue,\n  asArray: _asArray,\n  getValues: _getValues,\n  validateTypeValue: _validateTypeValue\n} = require('./util');\nconst {\n  handleEvent: _handleEvent\n} = require('./events');\nconst api = {};\nmodule.exports = api;\n\n/**\n * Recursively expands an element using the given context. Any context in\n * the element will be removed. All context URLs must have been retrieved\n * before calling this method.\n *\n * @param activeCtx the context to use.\n * @param activeProperty the property for the element, null for none.\n * @param element the element to expand.\n * @param options the expansion options.\n * @param insideList true if the element is a list, false if not.\n * @param insideIndex true if the element is inside an index container,\n *          false if not.\n * @param typeScopedContext an optional type-scoped active context for\n *          expanding values of nodes that were expressed according to\n *          a type-scoped context.\n *\n * @return a Promise that resolves to the expanded value.\n */\napi.expand = async ({\n  activeCtx,\n  activeProperty = null,\n  element,\n  options = {},\n  insideList = false,\n  insideIndex = false,\n  typeScopedContext = null\n}) => {\n  // nothing to expand\n  if (element === null || element === undefined) {\n    return null;\n  }\n\n  // disable framing if activeProperty is @default\n  if (activeProperty === '@default') {\n    options = Object.assign({}, options, {\n      isFrame: false\n    });\n  }\n  if (!_isArray(element) && !_isObject(element)) {\n    // drop free-floating scalars that are not in lists\n    if (!insideList && (activeProperty === null || _expandIri(activeCtx, activeProperty, {\n      vocab: true\n    }, options) === '@graph')) {\n      // FIXME\n      if (options.eventHandler) {\n        _handleEvent({\n          event: {\n            type: ['JsonLdEvent'],\n            code: 'free-floating scalar',\n            level: 'warning',\n            message: 'Dropping free-floating scalar not in a list.',\n            details: {\n              value: element\n              //activeProperty\n              //insideList\n            }\n          },\n\n          options\n        });\n      }\n      return null;\n    }\n\n    // expand element according to value expansion rules\n    return _expandValue({\n      activeCtx,\n      activeProperty,\n      value: element,\n      options\n    });\n  }\n\n  // recursively expand array\n  if (_isArray(element)) {\n    let rval = [];\n    const container = _getContextValue(activeCtx, activeProperty, '@container') || [];\n    insideList = insideList || container.includes('@list');\n    for (let i = 0; i < element.length; ++i) {\n      // expand element\n      let e = await api.expand({\n        activeCtx,\n        activeProperty,\n        element: element[i],\n        options,\n        insideIndex,\n        typeScopedContext\n      });\n      if (insideList && _isArray(e)) {\n        e = {\n          '@list': e\n        };\n      }\n      if (e === null) {\n        // FIXME: add debug event?\n        //unmappedValue: element[i],\n        //activeProperty,\n        //parent: element,\n        //index: i,\n        //expandedParent: rval,\n        //insideList\n\n        // NOTE: no-value events emitted at calling sites as needed\n        continue;\n      }\n      if (_isArray(e)) {\n        rval = rval.concat(e);\n      } else {\n        rval.push(e);\n      }\n    }\n    return rval;\n  }\n\n  // recursively expand object:\n\n  // first, expand the active property\n  const expandedActiveProperty = _expandIri(activeCtx, activeProperty, {\n    vocab: true\n  }, options);\n\n  // Get any property-scoped context for activeProperty\n  const propertyScopedCtx = _getContextValue(activeCtx, activeProperty, '@context');\n\n  // second, determine if any type-scoped context should be reverted; it\n  // should only be reverted when the following are all true:\n  // 1. `element` is not a value or subject reference\n  // 2. `insideIndex` is false\n  typeScopedContext = typeScopedContext || (activeCtx.previousContext ? activeCtx : null);\n  let keys = Object.keys(element).sort();\n  let mustRevert = !insideIndex;\n  if (mustRevert && typeScopedContext && keys.length <= 2 && !keys.includes('@context')) {\n    for (const key of keys) {\n      const expandedProperty = _expandIri(typeScopedContext, key, {\n        vocab: true\n      }, options);\n      if (expandedProperty === '@value') {\n        // value found, ensure type-scoped context is used to expand it\n        mustRevert = false;\n        activeCtx = typeScopedContext;\n        break;\n      }\n      if (expandedProperty === '@id' && keys.length === 1) {\n        // subject reference found, do not revert\n        mustRevert = false;\n        break;\n      }\n    }\n  }\n  if (mustRevert) {\n    // revert type scoped context\n    activeCtx = activeCtx.revertToPreviousContext();\n  }\n\n  // apply property-scoped context after reverting term-scoped context\n  if (!_isUndefined(propertyScopedCtx)) {\n    activeCtx = await _processContext({\n      activeCtx,\n      localCtx: propertyScopedCtx,\n      propagate: true,\n      overrideProtected: true,\n      options\n    });\n  }\n\n  // if element has a context, process it\n  if ('@context' in element) {\n    activeCtx = await _processContext({\n      activeCtx,\n      localCtx: element['@context'],\n      options\n    });\n  }\n\n  // set the type-scoped context to the context on input, for use later\n  typeScopedContext = activeCtx;\n\n  // Remember the first key found expanding to @type\n  let typeKey = null;\n\n  // look for scoped contexts on `@type`\n  for (const key of keys) {\n    const expandedProperty = _expandIri(activeCtx, key, {\n      vocab: true\n    }, options);\n    if (expandedProperty === '@type') {\n      // set scoped contexts from @type\n      // avoid sorting if possible\n      typeKey = typeKey || key;\n      const value = element[key];\n      const types = Array.isArray(value) ? value.length > 1 ? value.slice().sort() : value : [value];\n      for (const type of types) {\n        const ctx = _getContextValue(typeScopedContext, type, '@context');\n        if (!_isUndefined(ctx)) {\n          activeCtx = await _processContext({\n            activeCtx,\n            localCtx: ctx,\n            options,\n            propagate: false\n          });\n        }\n      }\n    }\n  }\n\n  // process each key and value in element, ignoring @nest content\n  let rval = {};\n  await _expandObject({\n    activeCtx,\n    activeProperty,\n    expandedActiveProperty,\n    element,\n    expandedParent: rval,\n    options,\n    insideList,\n    typeKey,\n    typeScopedContext\n  });\n\n  // get property count on expanded output\n  keys = Object.keys(rval);\n  let count = keys.length;\n  if ('@value' in rval) {\n    // @value must only have @language or @type\n    if ('@type' in rval && ('@language' in rval || '@direction' in rval)) {\n      throw new JsonLdError('Invalid JSON-LD syntax; an element containing \"@value\" may not ' + 'contain both \"@type\" and either \"@language\" or \"@direction\".', 'jsonld.SyntaxError', {\n        code: 'invalid value object',\n        element: rval\n      });\n    }\n    let validCount = count - 1;\n    if ('@type' in rval) {\n      validCount -= 1;\n    }\n    if ('@index' in rval) {\n      validCount -= 1;\n    }\n    if ('@language' in rval) {\n      validCount -= 1;\n    }\n    if ('@direction' in rval) {\n      validCount -= 1;\n    }\n    if (validCount !== 0) {\n      throw new JsonLdError('Invalid JSON-LD syntax; an element containing \"@value\" may only ' + 'have an \"@index\" property and either \"@type\" ' + 'or either or both \"@language\" or \"@direction\".', 'jsonld.SyntaxError', {\n        code: 'invalid value object',\n        element: rval\n      });\n    }\n    const values = rval['@value'] === null ? [] : _asArray(rval['@value']);\n    const types = _getValues(rval, '@type');\n\n    // drop null @values\n    if (_processingMode(activeCtx, 1.1) && types.includes('@json') && types.length === 1) {\n      // Any value of @value is okay if @type: @json\n    } else if (values.length === 0) {\n      // FIXME\n      if (options.eventHandler) {\n        _handleEvent({\n          event: {\n            type: ['JsonLdEvent'],\n            code: 'null @value value',\n            level: 'warning',\n            message: 'Dropping null @value value.',\n            details: {\n              value: rval\n            }\n          },\n          options\n        });\n      }\n      rval = null;\n    } else if (!values.every(v => _isString(v) || _isEmptyObject(v)) && '@language' in rval) {\n      // if @language is present, @value must be a string\n      throw new JsonLdError('Invalid JSON-LD syntax; only strings may be language-tagged.', 'jsonld.SyntaxError', {\n        code: 'invalid language-tagged value',\n        element: rval\n      });\n    } else if (!types.every(t => _isAbsoluteIri(t) && !(_isString(t) && t.indexOf('_:') === 0) || _isEmptyObject(t))) {\n      throw new JsonLdError('Invalid JSON-LD syntax; an element containing \"@value\" and \"@type\" ' + 'must have an absolute IRI for the value of \"@type\".', 'jsonld.SyntaxError', {\n        code: 'invalid typed value',\n        element: rval\n      });\n    }\n  } else if ('@type' in rval && !_isArray(rval['@type'])) {\n    // convert @type to an array\n    rval['@type'] = [rval['@type']];\n  } else if ('@set' in rval || '@list' in rval) {\n    // handle @set and @list\n    if (count > 1 && !(count === 2 && '@index' in rval)) {\n      throw new JsonLdError('Invalid JSON-LD syntax; if an element has the property \"@set\" ' + 'or \"@list\", then it can have at most one other property that is ' + '\"@index\".', 'jsonld.SyntaxError', {\n        code: 'invalid set or list object',\n        element: rval\n      });\n    }\n    // optimize away @set\n    if ('@set' in rval) {\n      rval = rval['@set'];\n      keys = Object.keys(rval);\n      count = keys.length;\n    }\n  } else if (count === 1 && '@language' in rval) {\n    // drop objects with only @language\n    // FIXME\n    if (options.eventHandler) {\n      _handleEvent({\n        event: {\n          type: ['JsonLdEvent'],\n          code: 'object with only @language',\n          level: 'warning',\n          message: 'Dropping object with only @language.',\n          details: {\n            value: rval\n          }\n        },\n        options\n      });\n    }\n    rval = null;\n  }\n\n  // drop certain top-level objects that do not occur in lists\n  if (_isObject(rval) && !options.keepFreeFloatingNodes && !insideList && (activeProperty === null || expandedActiveProperty === '@graph' || (_getContextValue(activeCtx, activeProperty, '@container') || []).includes('@graph'))) {\n    // drop empty object, top-level @value/@list, or object with only @id\n    rval = _dropUnsafeObject({\n      value: rval,\n      count,\n      options\n    });\n  }\n  return rval;\n};\n\n/**\n * Drop empty object, top-level @value/@list, or object with only @id\n */\nfunction _dropUnsafeObject({\n  value,\n  count,\n  options\n}) {\n  if (count === 0 || '@value' in value || '@list' in value || count === 1 && '@id' in value) {\n    // FIXME\n    if (options.eventHandler) {\n      // FIXME: one event or diff event for empty, @v/@l, {@id}?\n      let code;\n      let message;\n      if (count === 0) {\n        code = 'empty object';\n        message = 'Dropping empty object.';\n      } else if ('@value' in value) {\n        code = 'object with only @value';\n        message = 'Dropping object with only @value.';\n      } else if ('@list' in value) {\n        code = 'object with only @list';\n        message = 'Dropping object with only @list.';\n      } else if (count === 1 && '@id' in value) {\n        code = 'object with only @id';\n        message = 'Dropping object with only @id.';\n      }\n      _handleEvent({\n        event: {\n          type: ['JsonLdEvent'],\n          code,\n          level: 'warning',\n          message,\n          details: {\n            value\n          }\n        },\n        options\n      });\n    }\n    return null;\n  }\n  return value;\n}\n\n/**\n * Expand each key and value of element adding to result\n *\n * @param activeCtx the context to use.\n * @param activeProperty the property for the element.\n * @param expandedActiveProperty the expansion of activeProperty\n * @param element the element to expand.\n * @param expandedParent the expanded result into which to add values.\n * @param options the expansion options.\n * @param insideList true if the element is a list, false if not.\n * @param typeKey first key found expanding to @type.\n * @param typeScopedContext the context before reverting.\n */\nasync function _expandObject({\n  activeCtx,\n  activeProperty,\n  expandedActiveProperty,\n  element,\n  expandedParent,\n  options = {},\n  insideList,\n  typeKey,\n  typeScopedContext\n}) {\n  const keys = Object.keys(element).sort();\n  const nests = [];\n  let unexpandedValue;\n\n  // Figure out if this is the type for a JSON literal\n  const isJsonType = element[typeKey] && _expandIri(activeCtx, _isArray(element[typeKey]) ? element[typeKey][0] : element[typeKey], {\n    vocab: true\n  }, {\n    ...options,\n    typeExpansion: true\n  }) === '@json';\n  for (const key of keys) {\n    let value = element[key];\n    let expandedValue;\n\n    // skip @context\n    if (key === '@context') {\n      continue;\n    }\n\n    // expand property\n    const expandedProperty = _expandIri(activeCtx, key, {\n      vocab: true\n    }, options);\n\n    // drop non-absolute IRI keys that aren't keywords\n    if (expandedProperty === null || !(_isAbsoluteIri(expandedProperty) || _isKeyword(expandedProperty))) {\n      if (options.eventHandler) {\n        _handleEvent({\n          event: {\n            type: ['JsonLdEvent'],\n            code: 'invalid property',\n            level: 'warning',\n            message: 'Dropping property that did not expand into an ' + 'absolute IRI or keyword.',\n            details: {\n              property: key,\n              expandedProperty\n            }\n          },\n          options\n        });\n      }\n      continue;\n    }\n    if (_isKeyword(expandedProperty)) {\n      if (expandedActiveProperty === '@reverse') {\n        throw new JsonLdError('Invalid JSON-LD syntax; a keyword cannot be used as a @reverse ' + 'property.', 'jsonld.SyntaxError', {\n          code: 'invalid reverse property map',\n          value\n        });\n      }\n      if (expandedProperty in expandedParent && expandedProperty !== '@included' && expandedProperty !== '@type') {\n        throw new JsonLdError('Invalid JSON-LD syntax; colliding keywords detected.', 'jsonld.SyntaxError', {\n          code: 'colliding keywords',\n          keyword: expandedProperty\n        });\n      }\n    }\n\n    // syntax error if @id is not a string\n    if (expandedProperty === '@id') {\n      if (!_isString(value)) {\n        if (!options.isFrame) {\n          throw new JsonLdError('Invalid JSON-LD syntax; \"@id\" value must a string.', 'jsonld.SyntaxError', {\n            code: 'invalid @id value',\n            value\n          });\n        }\n        if (_isObject(value)) {\n          // empty object is a wildcard\n          if (!_isEmptyObject(value)) {\n            throw new JsonLdError('Invalid JSON-LD syntax; \"@id\" value an empty object or array ' + 'of strings, if framing', 'jsonld.SyntaxError', {\n              code: 'invalid @id value',\n              value\n            });\n          }\n        } else if (_isArray(value)) {\n          if (!value.every(v => _isString(v))) {\n            throw new JsonLdError('Invalid JSON-LD syntax; \"@id\" value an empty object or array ' + 'of strings, if framing', 'jsonld.SyntaxError', {\n              code: 'invalid @id value',\n              value\n            });\n          }\n        } else {\n          throw new JsonLdError('Invalid JSON-LD syntax; \"@id\" value an empty object or array ' + 'of strings, if framing', 'jsonld.SyntaxError', {\n            code: 'invalid @id value',\n            value\n          });\n        }\n      }\n      _addValue(expandedParent, '@id', _asArray(value).map(v => {\n        if (_isString(v)) {\n          const ve = _expandIri(activeCtx, v, {\n            base: true\n          }, options);\n          if (options.eventHandler) {\n            if (ve === null) {\n              // NOTE: spec edge case\n              // See https://github.com/w3c/json-ld-api/issues/480\n              if (v === null) {\n                _handleEvent({\n                  event: {\n                    type: ['JsonLdEvent'],\n                    code: 'null @id value',\n                    level: 'warning',\n                    message: 'Null @id found.',\n                    details: {\n                      id: v\n                    }\n                  },\n                  options\n                });\n              } else {\n                // matched KEYWORD regex\n                _handleEvent({\n                  event: {\n                    type: ['JsonLdEvent'],\n                    code: 'reserved @id value',\n                    level: 'warning',\n                    message: 'Reserved @id found.',\n                    details: {\n                      id: v\n                    }\n                  },\n                  options\n                });\n              }\n            } else if (!_isAbsoluteIri(ve)) {\n              _handleEvent({\n                event: {\n                  type: ['JsonLdEvent'],\n                  code: 'relative @id reference',\n                  level: 'warning',\n                  message: 'Relative @id reference found.',\n                  details: {\n                    id: v,\n                    expandedId: ve\n                  }\n                },\n                options\n              });\n            }\n          }\n          return ve;\n        }\n        return v;\n      }), {\n        propertyIsArray: options.isFrame\n      });\n      continue;\n    }\n    if (expandedProperty === '@type') {\n      // if framing, can be a default object, but need to expand\n      // key to determine that\n      if (_isObject(value)) {\n        value = Object.fromEntries(Object.entries(value).map(([k, v]) => [_expandIri(typeScopedContext, k, {\n          vocab: true\n        }), _asArray(v).map(vv => _expandIri(typeScopedContext, vv, {\n          base: true,\n          vocab: true\n        }, {\n          ...options,\n          typeExpansion: true\n        }))]));\n      }\n      _validateTypeValue(value, options.isFrame);\n      _addValue(expandedParent, '@type', _asArray(value).map(v => {\n        if (_isString(v)) {\n          const ve = _expandIri(typeScopedContext, v, {\n            base: true,\n            vocab: true\n          }, {\n            ...options,\n            typeExpansion: true\n          });\n          if (ve !== '@json' && !_isAbsoluteIri(ve)) {\n            if (options.eventHandler) {\n              _handleEvent({\n                event: {\n                  type: ['JsonLdEvent'],\n                  code: 'relative @type reference',\n                  level: 'warning',\n                  message: 'Relative @type reference found.',\n                  details: {\n                    type: v\n                  }\n                },\n                options\n              });\n            }\n          }\n          return ve;\n        }\n        return v;\n      }), {\n        propertyIsArray: !!options.isFrame\n      });\n      continue;\n    }\n\n    // Included blocks are treated as an array of separate object nodes sharing\n    // the same referencing active_property.\n    // For 1.0, it is skipped as are other unknown keywords\n    if (expandedProperty === '@included' && _processingMode(activeCtx, 1.1)) {\n      const includedResult = _asArray(await api.expand({\n        activeCtx,\n        activeProperty,\n        element: value,\n        options\n      }));\n\n      // Expanded values must be node objects\n      if (!includedResult.every(v => _isSubject(v))) {\n        throw new JsonLdError('Invalid JSON-LD syntax; ' + 'values of @included must expand to node objects.', 'jsonld.SyntaxError', {\n          code: 'invalid @included value',\n          value\n        });\n      }\n      _addValue(expandedParent, '@included', includedResult, {\n        propertyIsArray: true\n      });\n      continue;\n    }\n\n    // @graph must be an array or an object\n    if (expandedProperty === '@graph' && !(_isObject(value) || _isArray(value))) {\n      throw new JsonLdError('Invalid JSON-LD syntax; \"@graph\" value must not be an ' + 'object or an array.', 'jsonld.SyntaxError', {\n        code: 'invalid @graph value',\n        value\n      });\n    }\n    if (expandedProperty === '@value') {\n      // capture value for later\n      // \"colliding keywords\" check prevents this from being set twice\n      unexpandedValue = value;\n      if (isJsonType && _processingMode(activeCtx, 1.1)) {\n        // no coercion to array, and retain all values\n        expandedParent['@value'] = value;\n      } else {\n        _addValue(expandedParent, '@value', value, {\n          propertyIsArray: options.isFrame\n        });\n      }\n      continue;\n    }\n\n    // @language must be a string\n    // it should match BCP47\n    if (expandedProperty === '@language') {\n      if (value === null) {\n        // drop null @language values, they expand as if they didn't exist\n        continue;\n      }\n      if (!_isString(value) && !options.isFrame) {\n        throw new JsonLdError('Invalid JSON-LD syntax; \"@language\" value must be a string.', 'jsonld.SyntaxError', {\n          code: 'invalid language-tagged string',\n          value\n        });\n      }\n      // ensure language value is lowercase\n      value = _asArray(value).map(v => _isString(v) ? v.toLowerCase() : v);\n\n      // ensure language tag matches BCP47\n      for (const language of value) {\n        if (_isString(language) && !language.match(REGEX_BCP47)) {\n          if (options.eventHandler) {\n            _handleEvent({\n              event: {\n                type: ['JsonLdEvent'],\n                code: 'invalid @language value',\n                level: 'warning',\n                message: '@language value must be valid BCP47.',\n                details: {\n                  language\n                }\n              },\n              options\n            });\n          }\n        }\n      }\n      _addValue(expandedParent, '@language', value, {\n        propertyIsArray: options.isFrame\n      });\n      continue;\n    }\n\n    // @direction must be \"ltr\" or \"rtl\"\n    if (expandedProperty === '@direction') {\n      if (!_isString(value) && !options.isFrame) {\n        throw new JsonLdError('Invalid JSON-LD syntax; \"@direction\" value must be a string.', 'jsonld.SyntaxError', {\n          code: 'invalid base direction',\n          value\n        });\n      }\n      value = _asArray(value);\n\n      // ensure direction is \"ltr\" or \"rtl\"\n      for (const dir of value) {\n        if (_isString(dir) && dir !== 'ltr' && dir !== 'rtl') {\n          throw new JsonLdError('Invalid JSON-LD syntax; \"@direction\" must be \"ltr\" or \"rtl\".', 'jsonld.SyntaxError', {\n            code: 'invalid base direction',\n            value\n          });\n        }\n      }\n      _addValue(expandedParent, '@direction', value, {\n        propertyIsArray: options.isFrame\n      });\n      continue;\n    }\n\n    // @index must be a string\n    if (expandedProperty === '@index') {\n      if (!_isString(value)) {\n        throw new JsonLdError('Invalid JSON-LD syntax; \"@index\" value must be a string.', 'jsonld.SyntaxError', {\n          code: 'invalid @index value',\n          value\n        });\n      }\n      _addValue(expandedParent, '@index', value);\n      continue;\n    }\n\n    // @reverse must be an object\n    if (expandedProperty === '@reverse') {\n      if (!_isObject(value)) {\n        throw new JsonLdError('Invalid JSON-LD syntax; \"@reverse\" value must be an object.', 'jsonld.SyntaxError', {\n          code: 'invalid @reverse value',\n          value\n        });\n      }\n      expandedValue = await api.expand({\n        activeCtx,\n        activeProperty: '@reverse',\n        element: value,\n        options\n      });\n      // properties double-reversed\n      if ('@reverse' in expandedValue) {\n        for (const property in expandedValue['@reverse']) {\n          _addValue(expandedParent, property, expandedValue['@reverse'][property], {\n            propertyIsArray: true\n          });\n        }\n      }\n\n      // FIXME: can this be merged with code below to simplify?\n      // merge in all reversed properties\n      let reverseMap = expandedParent['@reverse'] || null;\n      for (const property in expandedValue) {\n        if (property === '@reverse') {\n          continue;\n        }\n        if (reverseMap === null) {\n          reverseMap = expandedParent['@reverse'] = {};\n        }\n        _addValue(reverseMap, property, [], {\n          propertyIsArray: true\n        });\n        const items = expandedValue[property];\n        for (let ii = 0; ii < items.length; ++ii) {\n          const item = items[ii];\n          if (_isValue(item) || _isList(item)) {\n            throw new JsonLdError('Invalid JSON-LD syntax; \"@reverse\" value must not be a ' + '@value or an @list.', 'jsonld.SyntaxError', {\n              code: 'invalid reverse property value',\n              value: expandedValue\n            });\n          }\n          _addValue(reverseMap, property, item, {\n            propertyIsArray: true\n          });\n        }\n      }\n      continue;\n    }\n\n    // nested keys\n    if (expandedProperty === '@nest') {\n      nests.push(key);\n      continue;\n    }\n\n    // use potential scoped context for key\n    let termCtx = activeCtx;\n    const ctx = _getContextValue(activeCtx, key, '@context');\n    if (!_isUndefined(ctx)) {\n      termCtx = await _processContext({\n        activeCtx,\n        localCtx: ctx,\n        propagate: true,\n        overrideProtected: true,\n        options\n      });\n    }\n    const container = _getContextValue(termCtx, key, '@container') || [];\n    if (container.includes('@language') && _isObject(value)) {\n      const direction = _getContextValue(termCtx, key, '@direction');\n      // handle language map container (skip if value is not an object)\n      expandedValue = _expandLanguageMap(termCtx, value, direction, options);\n    } else if (container.includes('@index') && _isObject(value)) {\n      // handle index container (skip if value is not an object)\n      const asGraph = container.includes('@graph');\n      const indexKey = _getContextValue(termCtx, key, '@index') || '@index';\n      const propertyIndex = indexKey !== '@index' && _expandIri(activeCtx, indexKey, {\n        vocab: true\n      }, options);\n      expandedValue = await _expandIndexMap({\n        activeCtx: termCtx,\n        options,\n        activeProperty: key,\n        value,\n        asGraph,\n        indexKey,\n        propertyIndex\n      });\n    } else if (container.includes('@id') && _isObject(value)) {\n      // handle id container (skip if value is not an object)\n      const asGraph = container.includes('@graph');\n      expandedValue = await _expandIndexMap({\n        activeCtx: termCtx,\n        options,\n        activeProperty: key,\n        value,\n        asGraph,\n        indexKey: '@id'\n      });\n    } else if (container.includes('@type') && _isObject(value)) {\n      // handle type container (skip if value is not an object)\n      expandedValue = await _expandIndexMap({\n        // since container is `@type`, revert type scoped context when expanding\n        activeCtx: termCtx.revertToPreviousContext(),\n        options,\n        activeProperty: key,\n        value,\n        asGraph: false,\n        indexKey: '@type'\n      });\n    } else {\n      // recurse into @list or @set\n      const isList = expandedProperty === '@list';\n      if (isList || expandedProperty === '@set') {\n        let nextActiveProperty = activeProperty;\n        if (isList && expandedActiveProperty === '@graph') {\n          nextActiveProperty = null;\n        }\n        expandedValue = await api.expand({\n          activeCtx: termCtx,\n          activeProperty: nextActiveProperty,\n          element: value,\n          options,\n          insideList: isList\n        });\n      } else if (_getContextValue(activeCtx, key, '@type') === '@json') {\n        expandedValue = {\n          '@type': '@json',\n          '@value': value\n        };\n      } else {\n        // recursively expand value with key as new active property\n        expandedValue = await api.expand({\n          activeCtx: termCtx,\n          activeProperty: key,\n          element: value,\n          options,\n          insideList: false\n        });\n      }\n    }\n\n    // drop null values if property is not @value\n    if (expandedValue === null && expandedProperty !== '@value') {\n      // FIXME: event?\n      //unmappedValue: value,\n      //expandedProperty,\n      //key,\n      continue;\n    }\n\n    // convert expanded value to @list if container specifies it\n    if (expandedProperty !== '@list' && !_isList(expandedValue) && container.includes('@list')) {\n      // ensure expanded value in @list is an array\n      expandedValue = {\n        '@list': _asArray(expandedValue)\n      };\n    }\n\n    // convert expanded value to @graph if container specifies it\n    // and value is not, itself, a graph\n    // index cases handled above\n    if (container.includes('@graph') && !container.some(key => key === '@id' || key === '@index')) {\n      // ensure expanded values are arrays\n      // ensure an array\n      expandedValue = _asArray(expandedValue);\n      // check if needs to be dropped\n      const count = Object.keys(expandedValue[0]).length;\n      if (!options.isFrame && _dropUnsafeObject({\n        value: expandedValue[0],\n        count,\n        options\n      }) === null) {\n        // skip adding and continue\n        continue;\n      }\n      // convert to graph\n      expandedValue = expandedValue.map(v => ({\n        '@graph': _asArray(v)\n      }));\n    }\n\n    // FIXME: can this be merged with code above to simplify?\n    // merge in reverse properties\n    if (termCtx.mappings.has(key) && termCtx.mappings.get(key).reverse) {\n      const reverseMap = expandedParent['@reverse'] = expandedParent['@reverse'] || {};\n      expandedValue = _asArray(expandedValue);\n      for (let ii = 0; ii < expandedValue.length; ++ii) {\n        const item = expandedValue[ii];\n        if (_isValue(item) || _isList(item)) {\n          throw new JsonLdError('Invalid JSON-LD syntax; \"@reverse\" value must not be a ' + '@value or an @list.', 'jsonld.SyntaxError', {\n            code: 'invalid reverse property value',\n            value: expandedValue\n          });\n        }\n        _addValue(reverseMap, expandedProperty, item, {\n          propertyIsArray: true\n        });\n      }\n      continue;\n    }\n\n    // add value for property\n    // special keywords handled above\n    _addValue(expandedParent, expandedProperty, expandedValue, {\n      propertyIsArray: true\n    });\n  }\n\n  // @value must not be an object or an array (unless framing) or if @type is\n  // @json\n  if ('@value' in expandedParent) {\n    if (expandedParent['@type'] === '@json' && _processingMode(activeCtx, 1.1)) {\n      // allow any value, to be verified when the object is fully expanded and\n      // the @type is @json.\n    } else if ((_isObject(unexpandedValue) || _isArray(unexpandedValue)) && !options.isFrame) {\n      throw new JsonLdError('Invalid JSON-LD syntax; \"@value\" value must not be an ' + 'object or an array.', 'jsonld.SyntaxError', {\n        code: 'invalid value object value',\n        value: unexpandedValue\n      });\n    }\n  }\n\n  // expand each nested key\n  for (const key of nests) {\n    const nestedValues = _isArray(element[key]) ? element[key] : [element[key]];\n    for (const nv of nestedValues) {\n      if (!_isObject(nv) || Object.keys(nv).some(k => _expandIri(activeCtx, k, {\n        vocab: true\n      }, options) === '@value')) {\n        throw new JsonLdError('Invalid JSON-LD syntax; nested value must be a node object.', 'jsonld.SyntaxError', {\n          code: 'invalid @nest value',\n          value: nv\n        });\n      }\n      await _expandObject({\n        activeCtx,\n        activeProperty,\n        expandedActiveProperty,\n        element: nv,\n        expandedParent,\n        options,\n        insideList,\n        typeScopedContext,\n        typeKey\n      });\n    }\n  }\n}\n\n/**\n * Expands the given value by using the coercion and keyword rules in the\n * given context.\n *\n * @param activeCtx the active context to use.\n * @param activeProperty the active property the value is associated with.\n * @param value the value to expand.\n * @param {Object} [options] - processing options.\n *\n * @return the expanded value.\n */\nfunction _expandValue({\n  activeCtx,\n  activeProperty,\n  value,\n  options\n}) {\n  // nothing to expand\n  if (value === null || value === undefined) {\n    return null;\n  }\n\n  // special-case expand @id and @type (skips '@id' expansion)\n  const expandedProperty = _expandIri(activeCtx, activeProperty, {\n    vocab: true\n  }, options);\n  if (expandedProperty === '@id') {\n    return _expandIri(activeCtx, value, {\n      base: true\n    }, options);\n  } else if (expandedProperty === '@type') {\n    return _expandIri(activeCtx, value, {\n      vocab: true,\n      base: true\n    }, {\n      ...options,\n      typeExpansion: true\n    });\n  }\n\n  // get type definition from context\n  const type = _getContextValue(activeCtx, activeProperty, '@type');\n\n  // do @id expansion (automatic for @graph)\n  if ((type === '@id' || expandedProperty === '@graph') && _isString(value)) {\n    const expandedValue = _expandIri(activeCtx, value, {\n      base: true\n    }, options);\n    // NOTE: handle spec edge case and avoid invalid {\"@id\": null}\n    if (expandedValue === null && value.match(REGEX_KEYWORD)) {\n      if (options.eventHandler) {\n        _handleEvent({\n          event: {\n            type: ['JsonLdEvent'],\n            code: 'reserved @id value',\n            level: 'warning',\n            message: 'Reserved @id found.',\n            details: {\n              id: activeProperty\n            }\n          },\n          options\n        });\n      }\n    }\n    return {\n      '@id': expandedValue\n    };\n  }\n  // do @id expansion w/vocab\n  if (type === '@vocab' && _isString(value)) {\n    return {\n      '@id': _expandIri(activeCtx, value, {\n        vocab: true,\n        base: true\n      }, options)\n    };\n  }\n\n  // do not expand keyword values\n  if (_isKeyword(expandedProperty)) {\n    return value;\n  }\n  const rval = {};\n  if (type && !['@id', '@vocab', '@none'].includes(type)) {\n    // other type\n    rval['@type'] = type;\n  } else if (_isString(value)) {\n    // check for language tagging for strings\n    const language = _getContextValue(activeCtx, activeProperty, '@language');\n    if (language !== null) {\n      rval['@language'] = language;\n    }\n    const direction = _getContextValue(activeCtx, activeProperty, '@direction');\n    if (direction !== null) {\n      rval['@direction'] = direction;\n    }\n  }\n  // do conversion of values that aren't basic JSON types to strings\n  if (!['boolean', 'number', 'string'].includes(typeof value)) {\n    value = value.toString();\n  }\n  rval['@value'] = value;\n  return rval;\n}\n\n/**\n * Expands a language map.\n *\n * @param activeCtx the active context to use.\n * @param languageMap the language map to expand.\n * @param direction the direction to apply to values.\n * @param {Object} [options] - processing options.\n *\n * @return the expanded language map.\n */\nfunction _expandLanguageMap(activeCtx, languageMap, direction, options) {\n  const rval = [];\n  const keys = Object.keys(languageMap).sort();\n  for (const key of keys) {\n    const expandedKey = _expandIri(activeCtx, key, {\n      vocab: true\n    }, options);\n    let val = languageMap[key];\n    if (!_isArray(val)) {\n      val = [val];\n    }\n    for (const item of val) {\n      if (item === null) {\n        // null values are allowed (8.5) but ignored (3.1)\n        continue;\n      }\n      if (!_isString(item)) {\n        throw new JsonLdError('Invalid JSON-LD syntax; language map values must be strings.', 'jsonld.SyntaxError', {\n          code: 'invalid language map value',\n          languageMap\n        });\n      }\n      const val = {\n        '@value': item\n      };\n      if (expandedKey !== '@none') {\n        if (!key.match(REGEX_BCP47)) {\n          if (options.eventHandler) {\n            _handleEvent({\n              event: {\n                type: ['JsonLdEvent'],\n                code: 'invalid @language value',\n                level: 'warning',\n                message: '@language value must be valid BCP47.',\n                details: {\n                  language: key\n                }\n              },\n              options\n            });\n          }\n        }\n        val['@language'] = key.toLowerCase();\n      }\n      if (direction) {\n        val['@direction'] = direction;\n      }\n      rval.push(val);\n    }\n  }\n  return rval;\n}\nasync function _expandIndexMap({\n  activeCtx,\n  options,\n  activeProperty,\n  value,\n  asGraph,\n  indexKey,\n  propertyIndex\n}) {\n  const rval = [];\n  const keys = Object.keys(value).sort();\n  const isTypeIndex = indexKey === '@type';\n  for (let key of keys) {\n    // if indexKey is @type, there may be a context defined for it\n    if (isTypeIndex) {\n      const ctx = _getContextValue(activeCtx, key, '@context');\n      if (!_isUndefined(ctx)) {\n        activeCtx = await _processContext({\n          activeCtx,\n          localCtx: ctx,\n          propagate: false,\n          options\n        });\n      }\n    }\n    let val = value[key];\n    if (!_isArray(val)) {\n      val = [val];\n    }\n    val = await api.expand({\n      activeCtx,\n      activeProperty,\n      element: val,\n      options,\n      insideList: false,\n      insideIndex: true\n    });\n\n    // expand for @type, but also for @none\n    let expandedKey;\n    if (propertyIndex) {\n      if (key === '@none') {\n        expandedKey = '@none';\n      } else {\n        expandedKey = _expandValue({\n          activeCtx,\n          activeProperty: indexKey,\n          value: key,\n          options\n        });\n      }\n    } else {\n      expandedKey = _expandIri(activeCtx, key, {\n        vocab: true\n      }, options);\n    }\n    if (indexKey === '@id') {\n      // expand document relative\n      key = _expandIri(activeCtx, key, {\n        base: true\n      }, options);\n    } else if (isTypeIndex) {\n      key = expandedKey;\n    }\n    for (let item of val) {\n      // If this is also a @graph container, turn items into graphs\n      if (asGraph && !_isGraph(item)) {\n        item = {\n          '@graph': [item]\n        };\n      }\n      if (indexKey === '@type') {\n        if (expandedKey === '@none') {\n          // ignore @none\n        } else if (item['@type']) {\n          item['@type'] = [key].concat(item['@type']);\n        } else {\n          item['@type'] = [key];\n        }\n      } else if (_isValue(item) && !['@language', '@type', '@index'].includes(indexKey)) {\n        throw new JsonLdError('Invalid JSON-LD syntax; Attempt to add illegal key to value ' + `object: \"${indexKey}\".`, 'jsonld.SyntaxError', {\n          code: 'invalid value object',\n          value: item\n        });\n      } else if (propertyIndex) {\n        // index is a property to be expanded, and values interpreted for that\n        // property\n        if (expandedKey !== '@none') {\n          // expand key as a value\n          _addValue(item, propertyIndex, expandedKey, {\n            propertyIsArray: true,\n            prependValue: true\n          });\n        }\n      } else if (expandedKey !== '@none' && !(indexKey in item)) {\n        item[indexKey] = key;\n      }\n      rval.push(item);\n    }\n  }\n  return rval;\n}","map":{"version":3,"names":["require","JsonLdError","isArray","_isArray","isObject","_isObject","isEmptyObject","_isEmptyObject","isString","_isString","isUndefined","_isUndefined","isList","_isList","isValue","_isValue","isGraph","_isGraph","isSubject","_isSubject","expandIri","_expandIri","getContextValue","_getContextValue","isKeyword","_isKeyword","process","_processContext","processingMode","_processingMode","isAbsolute","_isAbsoluteIri","REGEX_BCP47","REGEX_KEYWORD","addValue","_addValue","asArray","_asArray","getValues","_getValues","validateTypeValue","_validateTypeValue","handleEvent","_handleEvent","api","module","exports","expand","activeCtx","activeProperty","element","options","insideList","insideIndex","typeScopedContext","undefined","Object","assign","isFrame","vocab","eventHandler","event","type","code","level","message","details","value","_expandValue","rval","container","includes","i","length","e","concat","push","expandedActiveProperty","propertyScopedCtx","previousContext","keys","sort","mustRevert","key","expandedProperty","revertToPreviousContext","localCtx","propagate","overrideProtected","typeKey","types","Array","slice","ctx","_expandObject","expandedParent","count","validCount","values","every","v","t","indexOf","keepFreeFloatingNodes","_dropUnsafeObject","nests","unexpandedValue","isJsonType","typeExpansion","expandedValue","property","keyword","map","ve","base","id","expandedId","propertyIsArray","fromEntries","entries","k","vv","includedResult","toLowerCase","language","match","dir","reverseMap","items","ii","item","termCtx","direction","_expandLanguageMap","asGraph","indexKey","propertyIndex","_expandIndexMap","nextActiveProperty","some","mappings","has","get","reverse","nestedValues","nv","toString","languageMap","expandedKey","val","isTypeIndex","prependValue"],"sources":["/home/pratap/hid-ssi-js-sdk/node_modules/jsonld/lib/expand.js"],"sourcesContent":["/*\n * Copyright (c) 2017 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n\nconst JsonLdError = require('./JsonLdError');\n\nconst {\n  isArray: _isArray,\n  isObject: _isObject,\n  isEmptyObject: _isEmptyObject,\n  isString: _isString,\n  isUndefined: _isUndefined\n} = require('./types');\n\nconst {\n  isList: _isList,\n  isValue: _isValue,\n  isGraph: _isGraph,\n  isSubject: _isSubject\n} = require('./graphTypes');\n\nconst {\n  expandIri: _expandIri,\n  getContextValue: _getContextValue,\n  isKeyword: _isKeyword,\n  process: _processContext,\n  processingMode: _processingMode\n} = require('./context');\n\nconst {\n  isAbsolute: _isAbsoluteIri\n} = require('./url');\n\nconst {\n  REGEX_BCP47,\n  REGEX_KEYWORD,\n  addValue: _addValue,\n  asArray: _asArray,\n  getValues: _getValues,\n  validateTypeValue: _validateTypeValue\n} = require('./util');\n\nconst {\n  handleEvent: _handleEvent\n} = require('./events');\n\nconst api = {};\nmodule.exports = api;\n\n/**\n * Recursively expands an element using the given context. Any context in\n * the element will be removed. All context URLs must have been retrieved\n * before calling this method.\n *\n * @param activeCtx the context to use.\n * @param activeProperty the property for the element, null for none.\n * @param element the element to expand.\n * @param options the expansion options.\n * @param insideList true if the element is a list, false if not.\n * @param insideIndex true if the element is inside an index container,\n *          false if not.\n * @param typeScopedContext an optional type-scoped active context for\n *          expanding values of nodes that were expressed according to\n *          a type-scoped context.\n *\n * @return a Promise that resolves to the expanded value.\n */\napi.expand = async ({\n  activeCtx,\n  activeProperty = null,\n  element,\n  options = {},\n  insideList = false,\n  insideIndex = false,\n  typeScopedContext = null\n}) => {\n  // nothing to expand\n  if(element === null || element === undefined) {\n    return null;\n  }\n\n  // disable framing if activeProperty is @default\n  if(activeProperty === '@default') {\n    options = Object.assign({}, options, {isFrame: false});\n  }\n\n  if(!_isArray(element) && !_isObject(element)) {\n    // drop free-floating scalars that are not in lists\n    if(!insideList && (activeProperty === null ||\n      _expandIri(activeCtx, activeProperty, {vocab: true},\n        options) === '@graph')) {\n      // FIXME\n      if(options.eventHandler) {\n        _handleEvent({\n          event: {\n            type: ['JsonLdEvent'],\n            code: 'free-floating scalar',\n            level: 'warning',\n            message: 'Dropping free-floating scalar not in a list.',\n            details: {\n              value: element\n              //activeProperty\n              //insideList\n            }\n          },\n          options\n        });\n      }\n      return null;\n    }\n\n    // expand element according to value expansion rules\n    return _expandValue({activeCtx, activeProperty, value: element, options});\n  }\n\n  // recursively expand array\n  if(_isArray(element)) {\n    let rval = [];\n    const container = _getContextValue(\n      activeCtx, activeProperty, '@container') || [];\n    insideList = insideList || container.includes('@list');\n    for(let i = 0; i < element.length; ++i) {\n      // expand element\n      let e = await api.expand({\n        activeCtx,\n        activeProperty,\n        element: element[i],\n        options,\n        insideIndex,\n        typeScopedContext\n      });\n      if(insideList && _isArray(e)) {\n        e = {'@list': e};\n      }\n\n      if(e === null) {\n        // FIXME: add debug event?\n        //unmappedValue: element[i],\n        //activeProperty,\n        //parent: element,\n        //index: i,\n        //expandedParent: rval,\n        //insideList\n\n        // NOTE: no-value events emitted at calling sites as needed\n        continue;\n      }\n\n      if(_isArray(e)) {\n        rval = rval.concat(e);\n      } else {\n        rval.push(e);\n      }\n    }\n    return rval;\n  }\n\n  // recursively expand object:\n\n  // first, expand the active property\n  const expandedActiveProperty = _expandIri(\n    activeCtx, activeProperty, {vocab: true}, options);\n\n  // Get any property-scoped context for activeProperty\n  const propertyScopedCtx =\n    _getContextValue(activeCtx, activeProperty, '@context');\n\n  // second, determine if any type-scoped context should be reverted; it\n  // should only be reverted when the following are all true:\n  // 1. `element` is not a value or subject reference\n  // 2. `insideIndex` is false\n  typeScopedContext = typeScopedContext ||\n    (activeCtx.previousContext ? activeCtx : null);\n  let keys = Object.keys(element).sort();\n  let mustRevert = !insideIndex;\n  if(mustRevert && typeScopedContext && keys.length <= 2 &&\n    !keys.includes('@context')) {\n    for(const key of keys) {\n      const expandedProperty = _expandIri(\n        typeScopedContext, key, {vocab: true}, options);\n      if(expandedProperty === '@value') {\n        // value found, ensure type-scoped context is used to expand it\n        mustRevert = false;\n        activeCtx = typeScopedContext;\n        break;\n      }\n      if(expandedProperty === '@id' && keys.length === 1) {\n        // subject reference found, do not revert\n        mustRevert = false;\n        break;\n      }\n    }\n  }\n\n  if(mustRevert) {\n    // revert type scoped context\n    activeCtx = activeCtx.revertToPreviousContext();\n  }\n\n  // apply property-scoped context after reverting term-scoped context\n  if(!_isUndefined(propertyScopedCtx)) {\n    activeCtx = await _processContext({\n      activeCtx,\n      localCtx: propertyScopedCtx,\n      propagate: true,\n      overrideProtected: true,\n      options\n    });\n  }\n\n  // if element has a context, process it\n  if('@context' in element) {\n    activeCtx = await _processContext(\n      {activeCtx, localCtx: element['@context'], options});\n  }\n\n  // set the type-scoped context to the context on input, for use later\n  typeScopedContext = activeCtx;\n\n  // Remember the first key found expanding to @type\n  let typeKey = null;\n\n  // look for scoped contexts on `@type`\n  for(const key of keys) {\n    const expandedProperty = _expandIri(activeCtx, key, {vocab: true}, options);\n    if(expandedProperty === '@type') {\n      // set scoped contexts from @type\n      // avoid sorting if possible\n      typeKey = typeKey || key;\n      const value = element[key];\n      const types =\n        Array.isArray(value) ?\n          (value.length > 1 ? value.slice().sort() : value) : [value];\n      for(const type of types) {\n        const ctx = _getContextValue(typeScopedContext, type, '@context');\n        if(!_isUndefined(ctx)) {\n          activeCtx = await _processContext({\n            activeCtx,\n            localCtx: ctx,\n            options,\n            propagate: false\n          });\n        }\n      }\n    }\n  }\n\n  // process each key and value in element, ignoring @nest content\n  let rval = {};\n  await _expandObject({\n    activeCtx,\n    activeProperty,\n    expandedActiveProperty,\n    element,\n    expandedParent: rval,\n    options,\n    insideList,\n    typeKey,\n    typeScopedContext\n  });\n\n  // get property count on expanded output\n  keys = Object.keys(rval);\n  let count = keys.length;\n\n  if('@value' in rval) {\n    // @value must only have @language or @type\n    if('@type' in rval && ('@language' in rval || '@direction' in rval)) {\n      throw new JsonLdError(\n        'Invalid JSON-LD syntax; an element containing \"@value\" may not ' +\n        'contain both \"@type\" and either \"@language\" or \"@direction\".',\n        'jsonld.SyntaxError', {code: 'invalid value object', element: rval});\n    }\n    let validCount = count - 1;\n    if('@type' in rval) {\n      validCount -= 1;\n    }\n    if('@index' in rval) {\n      validCount -= 1;\n    }\n    if('@language' in rval) {\n      validCount -= 1;\n    }\n    if('@direction' in rval) {\n      validCount -= 1;\n    }\n    if(validCount !== 0) {\n      throw new JsonLdError(\n        'Invalid JSON-LD syntax; an element containing \"@value\" may only ' +\n        'have an \"@index\" property and either \"@type\" ' +\n        'or either or both \"@language\" or \"@direction\".',\n        'jsonld.SyntaxError', {code: 'invalid value object', element: rval});\n    }\n    const values = rval['@value'] === null ? [] : _asArray(rval['@value']);\n    const types = _getValues(rval, '@type');\n\n    // drop null @values\n    if(_processingMode(activeCtx, 1.1) && types.includes('@json') &&\n      types.length === 1) {\n      // Any value of @value is okay if @type: @json\n    } else if(values.length === 0) {\n      // FIXME\n      if(options.eventHandler) {\n        _handleEvent({\n          event: {\n            type: ['JsonLdEvent'],\n            code: 'null @value value',\n            level: 'warning',\n            message: 'Dropping null @value value.',\n            details: {\n              value: rval\n            }\n          },\n          options\n        });\n      }\n      rval = null;\n    } else if(!values.every(v => (_isString(v) || _isEmptyObject(v))) &&\n      '@language' in rval) {\n      // if @language is present, @value must be a string\n      throw new JsonLdError(\n        'Invalid JSON-LD syntax; only strings may be language-tagged.',\n        'jsonld.SyntaxError',\n        {code: 'invalid language-tagged value', element: rval});\n    } else if(!types.every(t =>\n      (_isAbsoluteIri(t) && !(_isString(t) && t.indexOf('_:') === 0) ||\n      _isEmptyObject(t)))) {\n      throw new JsonLdError(\n        'Invalid JSON-LD syntax; an element containing \"@value\" and \"@type\" ' +\n        'must have an absolute IRI for the value of \"@type\".',\n        'jsonld.SyntaxError', {code: 'invalid typed value', element: rval});\n    }\n  } else if('@type' in rval && !_isArray(rval['@type'])) {\n    // convert @type to an array\n    rval['@type'] = [rval['@type']];\n  } else if('@set' in rval || '@list' in rval) {\n    // handle @set and @list\n    if(count > 1 && !(count === 2 && '@index' in rval)) {\n      throw new JsonLdError(\n        'Invalid JSON-LD syntax; if an element has the property \"@set\" ' +\n        'or \"@list\", then it can have at most one other property that is ' +\n        '\"@index\".', 'jsonld.SyntaxError',\n        {code: 'invalid set or list object', element: rval});\n    }\n    // optimize away @set\n    if('@set' in rval) {\n      rval = rval['@set'];\n      keys = Object.keys(rval);\n      count = keys.length;\n    }\n  } else if(count === 1 && '@language' in rval) {\n    // drop objects with only @language\n    // FIXME\n    if(options.eventHandler) {\n      _handleEvent({\n        event: {\n          type: ['JsonLdEvent'],\n          code: 'object with only @language',\n          level: 'warning',\n          message: 'Dropping object with only @language.',\n          details: {\n            value: rval\n          }\n        },\n        options\n      });\n    }\n    rval = null;\n  }\n\n  // drop certain top-level objects that do not occur in lists\n  if(_isObject(rval) &&\n    !options.keepFreeFloatingNodes && !insideList &&\n    (activeProperty === null ||\n      expandedActiveProperty === '@graph' ||\n      (_getContextValue(activeCtx, activeProperty, '@container') || [])\n        .includes('@graph')\n    )) {\n    // drop empty object, top-level @value/@list, or object with only @id\n    rval = _dropUnsafeObject({value: rval, count, options});\n  }\n\n  return rval;\n};\n\n/**\n * Drop empty object, top-level @value/@list, or object with only @id\n */\nfunction _dropUnsafeObject({\n  value,\n  count,\n  options\n}) {\n  if(count === 0 || '@value' in value || '@list' in value ||\n    (count === 1 && '@id' in value)) {\n    // FIXME\n    if(options.eventHandler) {\n      // FIXME: one event or diff event for empty, @v/@l, {@id}?\n      let code;\n      let message;\n      if(count === 0) {\n        code = 'empty object';\n        message = 'Dropping empty object.';\n      } else if('@value' in value) {\n        code = 'object with only @value';\n        message = 'Dropping object with only @value.';\n      } else if('@list' in value) {\n        code = 'object with only @list';\n        message = 'Dropping object with only @list.';\n      } else if(count === 1 && '@id' in value) {\n        code = 'object with only @id';\n        message = 'Dropping object with only @id.';\n      }\n      _handleEvent({\n        event: {\n          type: ['JsonLdEvent'],\n          code,\n          level: 'warning',\n          message,\n          details: {\n            value\n          }\n        },\n        options\n      });\n    }\n    return null;\n  }\n  return value;\n}\n\n/**\n * Expand each key and value of element adding to result\n *\n * @param activeCtx the context to use.\n * @param activeProperty the property for the element.\n * @param expandedActiveProperty the expansion of activeProperty\n * @param element the element to expand.\n * @param expandedParent the expanded result into which to add values.\n * @param options the expansion options.\n * @param insideList true if the element is a list, false if not.\n * @param typeKey first key found expanding to @type.\n * @param typeScopedContext the context before reverting.\n */\nasync function _expandObject({\n  activeCtx,\n  activeProperty,\n  expandedActiveProperty,\n  element,\n  expandedParent,\n  options = {},\n  insideList,\n  typeKey,\n  typeScopedContext\n}) {\n  const keys = Object.keys(element).sort();\n  const nests = [];\n  let unexpandedValue;\n\n  // Figure out if this is the type for a JSON literal\n  const isJsonType = element[typeKey] &&\n    _expandIri(activeCtx,\n      (_isArray(element[typeKey]) ? element[typeKey][0] : element[typeKey]),\n      {vocab: true}, {\n        ...options,\n        typeExpansion: true\n      }) === '@json';\n\n  for(const key of keys) {\n    let value = element[key];\n    let expandedValue;\n\n    // skip @context\n    if(key === '@context') {\n      continue;\n    }\n\n    // expand property\n    const expandedProperty = _expandIri(activeCtx, key, {vocab: true}, options);\n\n    // drop non-absolute IRI keys that aren't keywords\n    if(expandedProperty === null ||\n      !(_isAbsoluteIri(expandedProperty) || _isKeyword(expandedProperty))) {\n      if(options.eventHandler) {\n        _handleEvent({\n          event: {\n            type: ['JsonLdEvent'],\n            code: 'invalid property',\n            level: 'warning',\n            message: 'Dropping property that did not expand into an ' +\n              'absolute IRI or keyword.',\n            details: {\n              property: key,\n              expandedProperty\n            }\n          },\n          options\n        });\n      }\n      continue;\n    }\n\n    if(_isKeyword(expandedProperty)) {\n      if(expandedActiveProperty === '@reverse') {\n        throw new JsonLdError(\n          'Invalid JSON-LD syntax; a keyword cannot be used as a @reverse ' +\n          'property.', 'jsonld.SyntaxError',\n          {code: 'invalid reverse property map', value});\n      }\n      if(expandedProperty in expandedParent &&\n         expandedProperty !== '@included' &&\n         expandedProperty !== '@type') {\n        throw new JsonLdError(\n          'Invalid JSON-LD syntax; colliding keywords detected.',\n          'jsonld.SyntaxError',\n          {code: 'colliding keywords', keyword: expandedProperty});\n      }\n    }\n\n    // syntax error if @id is not a string\n    if(expandedProperty === '@id') {\n      if(!_isString(value)) {\n        if(!options.isFrame) {\n          throw new JsonLdError(\n            'Invalid JSON-LD syntax; \"@id\" value must a string.',\n            'jsonld.SyntaxError', {code: 'invalid @id value', value});\n        }\n        if(_isObject(value)) {\n          // empty object is a wildcard\n          if(!_isEmptyObject(value)) {\n            throw new JsonLdError(\n              'Invalid JSON-LD syntax; \"@id\" value an empty object or array ' +\n              'of strings, if framing',\n              'jsonld.SyntaxError', {code: 'invalid @id value', value});\n          }\n        } else if(_isArray(value)) {\n          if(!value.every(v => _isString(v))) {\n            throw new JsonLdError(\n              'Invalid JSON-LD syntax; \"@id\" value an empty object or array ' +\n              'of strings, if framing',\n              'jsonld.SyntaxError', {code: 'invalid @id value', value});\n          }\n        } else {\n          throw new JsonLdError(\n            'Invalid JSON-LD syntax; \"@id\" value an empty object or array ' +\n            'of strings, if framing',\n            'jsonld.SyntaxError', {code: 'invalid @id value', value});\n        }\n      }\n\n      _addValue(\n        expandedParent, '@id',\n        _asArray(value).map(v => {\n          if(_isString(v)) {\n            const ve = _expandIri(activeCtx, v, {base: true}, options);\n            if(options.eventHandler) {\n              if(ve === null) {\n                // NOTE: spec edge case\n                // See https://github.com/w3c/json-ld-api/issues/480\n                if(v === null) {\n                  _handleEvent({\n                    event: {\n                      type: ['JsonLdEvent'],\n                      code: 'null @id value',\n                      level: 'warning',\n                      message: 'Null @id found.',\n                      details: {\n                        id: v\n                      }\n                    },\n                    options\n                  });\n                } else {\n                  // matched KEYWORD regex\n                  _handleEvent({\n                    event: {\n                      type: ['JsonLdEvent'],\n                      code: 'reserved @id value',\n                      level: 'warning',\n                      message: 'Reserved @id found.',\n                      details: {\n                        id: v\n                      }\n                    },\n                    options\n                  });\n                }\n              } else if(!_isAbsoluteIri(ve)) {\n                _handleEvent({\n                  event: {\n                    type: ['JsonLdEvent'],\n                    code: 'relative @id reference',\n                    level: 'warning',\n                    message: 'Relative @id reference found.',\n                    details: {\n                      id: v,\n                      expandedId: ve\n                    }\n                  },\n                  options\n                });\n              }\n            }\n            return ve;\n          }\n          return v;\n        }),\n        {propertyIsArray: options.isFrame});\n      continue;\n    }\n\n    if(expandedProperty === '@type') {\n      // if framing, can be a default object, but need to expand\n      // key to determine that\n      if(_isObject(value)) {\n        value = Object.fromEntries(Object.entries(value).map(([k, v]) => [\n          _expandIri(typeScopedContext, k, {vocab: true}),\n          _asArray(v).map(vv =>\n            _expandIri(typeScopedContext, vv, {base: true, vocab: true},\n              {...options, typeExpansion: true})\n          )\n        ]));\n      }\n      _validateTypeValue(value, options.isFrame);\n      _addValue(\n        expandedParent, '@type',\n        _asArray(value).map(v => {\n          if(_isString(v)) {\n            const ve = _expandIri(typeScopedContext, v,\n              {base: true, vocab: true},\n              {...options, typeExpansion: true});\n            if(ve !== '@json' && !_isAbsoluteIri(ve)) {\n              if(options.eventHandler) {\n                _handleEvent({\n                  event: {\n                    type: ['JsonLdEvent'],\n                    code: 'relative @type reference',\n                    level: 'warning',\n                    message: 'Relative @type reference found.',\n                    details: {\n                      type: v\n                    }\n                  },\n                  options\n                });\n              }\n            }\n            return ve;\n          }\n          return v;\n        }),\n        {propertyIsArray: !!options.isFrame});\n      continue;\n    }\n\n    // Included blocks are treated as an array of separate object nodes sharing\n    // the same referencing active_property.\n    // For 1.0, it is skipped as are other unknown keywords\n    if(expandedProperty === '@included' && _processingMode(activeCtx, 1.1)) {\n      const includedResult = _asArray(await api.expand({\n        activeCtx,\n        activeProperty,\n        element: value,\n        options\n      }));\n\n      // Expanded values must be node objects\n      if(!includedResult.every(v => _isSubject(v))) {\n        throw new JsonLdError(\n          'Invalid JSON-LD syntax; ' +\n          'values of @included must expand to node objects.',\n          'jsonld.SyntaxError', {code: 'invalid @included value', value});\n      }\n\n      _addValue(\n        expandedParent, '@included', includedResult, {propertyIsArray: true});\n      continue;\n    }\n\n    // @graph must be an array or an object\n    if(expandedProperty === '@graph' &&\n      !(_isObject(value) || _isArray(value))) {\n      throw new JsonLdError(\n        'Invalid JSON-LD syntax; \"@graph\" value must not be an ' +\n        'object or an array.',\n        'jsonld.SyntaxError', {code: 'invalid @graph value', value});\n    }\n\n    if(expandedProperty === '@value') {\n      // capture value for later\n      // \"colliding keywords\" check prevents this from being set twice\n      unexpandedValue = value;\n      if(isJsonType && _processingMode(activeCtx, 1.1)) {\n        // no coercion to array, and retain all values\n        expandedParent['@value'] = value;\n      } else {\n        _addValue(\n          expandedParent, '@value', value, {propertyIsArray: options.isFrame});\n      }\n      continue;\n    }\n\n    // @language must be a string\n    // it should match BCP47\n    if(expandedProperty === '@language') {\n      if(value === null) {\n        // drop null @language values, they expand as if they didn't exist\n        continue;\n      }\n      if(!_isString(value) && !options.isFrame) {\n        throw new JsonLdError(\n          'Invalid JSON-LD syntax; \"@language\" value must be a string.',\n          'jsonld.SyntaxError',\n          {code: 'invalid language-tagged string', value});\n      }\n      // ensure language value is lowercase\n      value = _asArray(value).map(v => _isString(v) ? v.toLowerCase() : v);\n\n      // ensure language tag matches BCP47\n      for(const language of value) {\n        if(_isString(language) && !language.match(REGEX_BCP47)) {\n          if(options.eventHandler) {\n            _handleEvent({\n              event: {\n                type: ['JsonLdEvent'],\n                code: 'invalid @language value',\n                level: 'warning',\n                message: '@language value must be valid BCP47.',\n                details: {\n                  language\n                }\n              },\n              options\n            });\n          }\n        }\n      }\n\n      _addValue(\n        expandedParent, '@language', value, {propertyIsArray: options.isFrame});\n      continue;\n    }\n\n    // @direction must be \"ltr\" or \"rtl\"\n    if(expandedProperty === '@direction') {\n      if(!_isString(value) && !options.isFrame) {\n        throw new JsonLdError(\n          'Invalid JSON-LD syntax; \"@direction\" value must be a string.',\n          'jsonld.SyntaxError',\n          {code: 'invalid base direction', value});\n      }\n\n      value = _asArray(value);\n\n      // ensure direction is \"ltr\" or \"rtl\"\n      for(const dir of value) {\n        if(_isString(dir) && dir !== 'ltr' && dir !== 'rtl') {\n          throw new JsonLdError(\n            'Invalid JSON-LD syntax; \"@direction\" must be \"ltr\" or \"rtl\".',\n            'jsonld.SyntaxError',\n            {code: 'invalid base direction', value});\n        }\n      }\n\n      _addValue(\n        expandedParent, '@direction', value,\n        {propertyIsArray: options.isFrame});\n      continue;\n    }\n\n    // @index must be a string\n    if(expandedProperty === '@index') {\n      if(!_isString(value)) {\n        throw new JsonLdError(\n          'Invalid JSON-LD syntax; \"@index\" value must be a string.',\n          'jsonld.SyntaxError',\n          {code: 'invalid @index value', value});\n      }\n      _addValue(expandedParent, '@index', value);\n      continue;\n    }\n\n    // @reverse must be an object\n    if(expandedProperty === '@reverse') {\n      if(!_isObject(value)) {\n        throw new JsonLdError(\n          'Invalid JSON-LD syntax; \"@reverse\" value must be an object.',\n          'jsonld.SyntaxError', {code: 'invalid @reverse value', value});\n      }\n\n      expandedValue = await api.expand({\n        activeCtx,\n        activeProperty: '@reverse',\n        element: value,\n        options\n      });\n      // properties double-reversed\n      if('@reverse' in expandedValue) {\n        for(const property in expandedValue['@reverse']) {\n          _addValue(\n            expandedParent, property, expandedValue['@reverse'][property],\n            {propertyIsArray: true});\n        }\n      }\n\n      // FIXME: can this be merged with code below to simplify?\n      // merge in all reversed properties\n      let reverseMap = expandedParent['@reverse'] || null;\n      for(const property in expandedValue) {\n        if(property === '@reverse') {\n          continue;\n        }\n        if(reverseMap === null) {\n          reverseMap = expandedParent['@reverse'] = {};\n        }\n        _addValue(reverseMap, property, [], {propertyIsArray: true});\n        const items = expandedValue[property];\n        for(let ii = 0; ii < items.length; ++ii) {\n          const item = items[ii];\n          if(_isValue(item) || _isList(item)) {\n            throw new JsonLdError(\n              'Invalid JSON-LD syntax; \"@reverse\" value must not be a ' +\n              '@value or an @list.', 'jsonld.SyntaxError',\n              {code: 'invalid reverse property value', value: expandedValue});\n          }\n          _addValue(reverseMap, property, item, {propertyIsArray: true});\n        }\n      }\n\n      continue;\n    }\n\n    // nested keys\n    if(expandedProperty === '@nest') {\n      nests.push(key);\n      continue;\n    }\n\n    // use potential scoped context for key\n    let termCtx = activeCtx;\n    const ctx = _getContextValue(activeCtx, key, '@context');\n    if(!_isUndefined(ctx)) {\n      termCtx = await _processContext({\n        activeCtx,\n        localCtx: ctx,\n        propagate: true,\n        overrideProtected: true,\n        options\n      });\n    }\n\n    const container = _getContextValue(termCtx, key, '@container') || [];\n\n    if(container.includes('@language') && _isObject(value)) {\n      const direction = _getContextValue(termCtx, key, '@direction');\n      // handle language map container (skip if value is not an object)\n      expandedValue = _expandLanguageMap(termCtx, value, direction, options);\n    } else if(container.includes('@index') && _isObject(value)) {\n      // handle index container (skip if value is not an object)\n      const asGraph = container.includes('@graph');\n      const indexKey = _getContextValue(termCtx, key, '@index') || '@index';\n      const propertyIndex = indexKey !== '@index' &&\n        _expandIri(activeCtx, indexKey, {vocab: true}, options);\n\n      expandedValue = await _expandIndexMap({\n        activeCtx: termCtx,\n        options,\n        activeProperty: key,\n        value,\n        asGraph,\n        indexKey,\n        propertyIndex\n      });\n    } else if(container.includes('@id') && _isObject(value)) {\n      // handle id container (skip if value is not an object)\n      const asGraph = container.includes('@graph');\n      expandedValue = await _expandIndexMap({\n        activeCtx: termCtx,\n        options,\n        activeProperty: key,\n        value,\n        asGraph,\n        indexKey: '@id'\n      });\n    } else if(container.includes('@type') && _isObject(value)) {\n      // handle type container (skip if value is not an object)\n      expandedValue = await _expandIndexMap({\n        // since container is `@type`, revert type scoped context when expanding\n        activeCtx: termCtx.revertToPreviousContext(),\n        options,\n        activeProperty: key,\n        value,\n        asGraph: false,\n        indexKey: '@type'\n      });\n    } else {\n      // recurse into @list or @set\n      const isList = expandedProperty === '@list';\n      if(isList || expandedProperty === '@set') {\n        let nextActiveProperty = activeProperty;\n        if(isList && expandedActiveProperty === '@graph') {\n          nextActiveProperty = null;\n        }\n        expandedValue = await api.expand({\n          activeCtx: termCtx,\n          activeProperty: nextActiveProperty,\n          element: value,\n          options,\n          insideList: isList\n        });\n      } else if(\n        _getContextValue(activeCtx, key, '@type') === '@json') {\n        expandedValue = {\n          '@type': '@json',\n          '@value': value\n        };\n      } else {\n        // recursively expand value with key as new active property\n        expandedValue = await api.expand({\n          activeCtx: termCtx,\n          activeProperty: key,\n          element: value,\n          options,\n          insideList: false\n        });\n      }\n    }\n\n    // drop null values if property is not @value\n    if(expandedValue === null && expandedProperty !== '@value') {\n      // FIXME: event?\n      //unmappedValue: value,\n      //expandedProperty,\n      //key,\n      continue;\n    }\n\n    // convert expanded value to @list if container specifies it\n    if(expandedProperty !== '@list' && !_isList(expandedValue) &&\n      container.includes('@list')) {\n      // ensure expanded value in @list is an array\n      expandedValue = {'@list': _asArray(expandedValue)};\n    }\n\n    // convert expanded value to @graph if container specifies it\n    // and value is not, itself, a graph\n    // index cases handled above\n    if(container.includes('@graph') &&\n      !container.some(key => key === '@id' || key === '@index')) {\n      // ensure expanded values are arrays\n      // ensure an array\n      expandedValue = _asArray(expandedValue);\n      // check if needs to be dropped\n      const count = Object.keys(expandedValue[0]).length;\n      if(!options.isFrame && _dropUnsafeObject({\n        value: expandedValue[0], count, options\n      }) === null) {\n        // skip adding and continue\n        continue;\n      }\n      // convert to graph\n      expandedValue = expandedValue.map(v => ({'@graph': _asArray(v)}));\n    }\n\n    // FIXME: can this be merged with code above to simplify?\n    // merge in reverse properties\n    if(termCtx.mappings.has(key) && termCtx.mappings.get(key).reverse) {\n      const reverseMap =\n        expandedParent['@reverse'] = expandedParent['@reverse'] || {};\n      expandedValue = _asArray(expandedValue);\n      for(let ii = 0; ii < expandedValue.length; ++ii) {\n        const item = expandedValue[ii];\n        if(_isValue(item) || _isList(item)) {\n          throw new JsonLdError(\n            'Invalid JSON-LD syntax; \"@reverse\" value must not be a ' +\n            '@value or an @list.', 'jsonld.SyntaxError',\n            {code: 'invalid reverse property value', value: expandedValue});\n        }\n        _addValue(reverseMap, expandedProperty, item, {propertyIsArray: true});\n      }\n      continue;\n    }\n\n    // add value for property\n    // special keywords handled above\n    _addValue(expandedParent, expandedProperty, expandedValue, {\n      propertyIsArray: true\n    });\n  }\n\n  // @value must not be an object or an array (unless framing) or if @type is\n  // @json\n  if('@value' in expandedParent) {\n    if(expandedParent['@type'] === '@json' && _processingMode(activeCtx, 1.1)) {\n      // allow any value, to be verified when the object is fully expanded and\n      // the @type is @json.\n    } else if((_isObject(unexpandedValue) || _isArray(unexpandedValue)) &&\n      !options.isFrame) {\n      throw new JsonLdError(\n        'Invalid JSON-LD syntax; \"@value\" value must not be an ' +\n        'object or an array.',\n        'jsonld.SyntaxError',\n        {code: 'invalid value object value', value: unexpandedValue});\n    }\n  }\n\n  // expand each nested key\n  for(const key of nests) {\n    const nestedValues = _isArray(element[key]) ? element[key] : [element[key]];\n    for(const nv of nestedValues) {\n      if(!_isObject(nv) || Object.keys(nv).some(k =>\n        _expandIri(activeCtx, k, {vocab: true}, options) === '@value')) {\n        throw new JsonLdError(\n          'Invalid JSON-LD syntax; nested value must be a node object.',\n          'jsonld.SyntaxError',\n          {code: 'invalid @nest value', value: nv});\n      }\n      await _expandObject({\n        activeCtx,\n        activeProperty,\n        expandedActiveProperty,\n        element: nv,\n        expandedParent,\n        options,\n        insideList,\n        typeScopedContext,\n        typeKey\n      });\n    }\n  }\n}\n\n/**\n * Expands the given value by using the coercion and keyword rules in the\n * given context.\n *\n * @param activeCtx the active context to use.\n * @param activeProperty the active property the value is associated with.\n * @param value the value to expand.\n * @param {Object} [options] - processing options.\n *\n * @return the expanded value.\n */\nfunction _expandValue({activeCtx, activeProperty, value, options}) {\n  // nothing to expand\n  if(value === null || value === undefined) {\n    return null;\n  }\n\n  // special-case expand @id and @type (skips '@id' expansion)\n  const expandedProperty = _expandIri(\n    activeCtx, activeProperty, {vocab: true}, options);\n  if(expandedProperty === '@id') {\n    return _expandIri(activeCtx, value, {base: true}, options);\n  } else if(expandedProperty === '@type') {\n    return _expandIri(activeCtx, value, {vocab: true, base: true},\n      {...options, typeExpansion: true});\n  }\n\n  // get type definition from context\n  const type = _getContextValue(activeCtx, activeProperty, '@type');\n\n  // do @id expansion (automatic for @graph)\n  if((type === '@id' || expandedProperty === '@graph') && _isString(value)) {\n    const expandedValue = _expandIri(activeCtx, value, {base: true}, options);\n    // NOTE: handle spec edge case and avoid invalid {\"@id\": null}\n    if(expandedValue === null && value.match(REGEX_KEYWORD)) {\n      if(options.eventHandler) {\n        _handleEvent({\n          event: {\n            type: ['JsonLdEvent'],\n            code: 'reserved @id value',\n            level: 'warning',\n            message: 'Reserved @id found.',\n            details: {\n              id: activeProperty\n            }\n          },\n          options\n        });\n      }\n    }\n    return {'@id': expandedValue};\n  }\n  // do @id expansion w/vocab\n  if(type === '@vocab' && _isString(value)) {\n    return {\n      '@id': _expandIri(activeCtx, value, {vocab: true, base: true}, options)\n    };\n  }\n\n  // do not expand keyword values\n  if(_isKeyword(expandedProperty)) {\n    return value;\n  }\n\n  const rval = {};\n\n  if(type && !['@id', '@vocab', '@none'].includes(type)) {\n    // other type\n    rval['@type'] = type;\n  } else if(_isString(value)) {\n    // check for language tagging for strings\n    const language = _getContextValue(activeCtx, activeProperty, '@language');\n    if(language !== null) {\n      rval['@language'] = language;\n    }\n    const direction = _getContextValue(activeCtx, activeProperty, '@direction');\n    if(direction !== null) {\n      rval['@direction'] = direction;\n    }\n  }\n  // do conversion of values that aren't basic JSON types to strings\n  if(!['boolean', 'number', 'string'].includes(typeof value)) {\n    value = value.toString();\n  }\n  rval['@value'] = value;\n\n  return rval;\n}\n\n/**\n * Expands a language map.\n *\n * @param activeCtx the active context to use.\n * @param languageMap the language map to expand.\n * @param direction the direction to apply to values.\n * @param {Object} [options] - processing options.\n *\n * @return the expanded language map.\n */\nfunction _expandLanguageMap(activeCtx, languageMap, direction, options) {\n  const rval = [];\n  const keys = Object.keys(languageMap).sort();\n  for(const key of keys) {\n    const expandedKey = _expandIri(activeCtx, key, {vocab: true}, options);\n    let val = languageMap[key];\n    if(!_isArray(val)) {\n      val = [val];\n    }\n    for(const item of val) {\n      if(item === null) {\n        // null values are allowed (8.5) but ignored (3.1)\n        continue;\n      }\n      if(!_isString(item)) {\n        throw new JsonLdError(\n          'Invalid JSON-LD syntax; language map values must be strings.',\n          'jsonld.SyntaxError',\n          {code: 'invalid language map value', languageMap});\n      }\n      const val = {'@value': item};\n      if(expandedKey !== '@none') {\n        if(!key.match(REGEX_BCP47)) {\n          if(options.eventHandler) {\n            _handleEvent({\n              event: {\n                type: ['JsonLdEvent'],\n                code: 'invalid @language value',\n                level: 'warning',\n                message: '@language value must be valid BCP47.',\n                details: {\n                  language: key\n                }\n              },\n              options\n            });\n          }\n        }\n        val['@language'] = key.toLowerCase();\n      }\n      if(direction) {\n        val['@direction'] = direction;\n      }\n      rval.push(val);\n    }\n  }\n  return rval;\n}\n\nasync function _expandIndexMap({\n  activeCtx, options, activeProperty, value, asGraph, indexKey, propertyIndex\n}) {\n  const rval = [];\n  const keys = Object.keys(value).sort();\n  const isTypeIndex = indexKey === '@type';\n  for(let key of keys) {\n    // if indexKey is @type, there may be a context defined for it\n    if(isTypeIndex) {\n      const ctx = _getContextValue(activeCtx, key, '@context');\n      if(!_isUndefined(ctx)) {\n        activeCtx = await _processContext({\n          activeCtx,\n          localCtx: ctx,\n          propagate: false,\n          options\n        });\n      }\n    }\n\n    let val = value[key];\n    if(!_isArray(val)) {\n      val = [val];\n    }\n\n    val = await api.expand({\n      activeCtx,\n      activeProperty,\n      element: val,\n      options,\n      insideList: false,\n      insideIndex: true\n    });\n\n    // expand for @type, but also for @none\n    let expandedKey;\n    if(propertyIndex) {\n      if(key === '@none') {\n        expandedKey = '@none';\n      } else {\n        expandedKey = _expandValue(\n          {activeCtx, activeProperty: indexKey, value: key, options});\n      }\n    } else {\n      expandedKey = _expandIri(activeCtx, key, {vocab: true}, options);\n    }\n\n    if(indexKey === '@id') {\n      // expand document relative\n      key = _expandIri(activeCtx, key, {base: true}, options);\n    } else if(isTypeIndex) {\n      key = expandedKey;\n    }\n\n    for(let item of val) {\n      // If this is also a @graph container, turn items into graphs\n      if(asGraph && !_isGraph(item)) {\n        item = {'@graph': [item]};\n      }\n      if(indexKey === '@type') {\n        if(expandedKey === '@none') {\n          // ignore @none\n        } else if(item['@type']) {\n          item['@type'] = [key].concat(item['@type']);\n        } else {\n          item['@type'] = [key];\n        }\n      } else if(_isValue(item) &&\n        !['@language', '@type', '@index'].includes(indexKey)) {\n        throw new JsonLdError(\n          'Invalid JSON-LD syntax; Attempt to add illegal key to value ' +\n          `object: \"${indexKey}\".`,\n          'jsonld.SyntaxError',\n          {code: 'invalid value object', value: item});\n      } else if(propertyIndex) {\n        // index is a property to be expanded, and values interpreted for that\n        // property\n        if(expandedKey !== '@none') {\n          // expand key as a value\n          _addValue(item, propertyIndex, expandedKey, {\n            propertyIsArray: true,\n            prependValue: true\n          });\n        }\n      } else if(expandedKey !== '@none' && !(indexKey in item)) {\n        item[indexKey] = key;\n      }\n      rval.push(item);\n    }\n  }\n  return rval;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}