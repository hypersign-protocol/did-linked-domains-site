{"ast":null,"code":"/*!\n * Copyright (c) 2020-2022 Digital Bazaar, Inc. All rights reserved.\n */\n\n/**\n * General purpose key generation driver for Linked Data cryptographic key\n * pairs.\n *\n * @param {Map} [suites] - Optional map of supported suites, by suite id.\n */\nexport class CryptoLD {\n  constructor({\n    suites\n  } = {}) {\n    this.suites = suites || new Map();\n  }\n\n  /**\n   * Installs support for a key type (suite).\n   *\n   * @param {LDKeyPair} keyPairLib - Conforming key pair library for a suite.\n   */\n  use(keyPairLib) {\n    this.suites.set(keyPairLib.suite, keyPairLib);\n  }\n\n  /**\n   * Generates a public/private LDKeyPair.\n   *\n   * @param {object} options - Suite-specific key options.\n   * @param {string} options.type - Key suite id (for example,\n   *   'Ed25519VerificationKey2020').\n   * @param {string} [options.controller] - Controller DID or URL for the\n   *   generated key pair. If present, used to auto-initialize the key.id.\n   *\n   * @returns {Promise<LDKeyPair>} Generated key pair.\n   */\n  async generate(options = {}) {\n    const Suite = this._suiteForType(options);\n    return Suite.generate(options);\n  }\n\n  /**\n   * Imports a public/private key pair from serialized data.\n   *\n   * @param {object} serialized - Serialized key object.\n   *\n   * @throws {Error} - On missing or invalid serialized key data.\n   *\n   * @returns {Promise<LDKeyPair>} Imported key pair.\n   */\n  async from(serialized = {}) {\n    const Suite = this._suiteForType(serialized);\n    if (serialized['@context']) {\n      // presume this may be an untrusted (fetched, etc) key document\n      return Suite.fromKeyDocument({\n        document: serialized\n      });\n    }\n    return Suite.from(serialized);\n  }\n\n  /**\n   * Imports a key pair instance from a provided externally fetched key\n   * document (fetched via a secure JSON-LD `documentLoader` or via\n   * `cryptoLd.fromKeyId()`), optionally checking it for revocation and required\n   * context.\n   *\n   * @param {object} options - Options hashmap.\n   * @param {string} options.document - Externally fetched key document.\n   * @param {boolean} [options.checkContext=true] - Whether to check that the\n   *   fetched key document contains the context required by the key's crypto\n   *   suite.\n   * @param {boolean} [options.checkRevoked=true] - Whether to check the key\n   *   object for the presence of the `revoked` timestamp.\n   *\n   * @returns {Promise<LDKeyPair>} Resolves with the resulting key pair\n   *   instance.\n   */\n  async fromKeyDocument({\n    document,\n    checkContext = true,\n    checkRevoked = true\n  } = {}) {\n    if (!document) {\n      throw new TypeError('The \"document\" parameter is required.');\n    }\n    const Suite = this._suiteForType(document);\n    return Suite.fromKeyDocument({\n      document,\n      checkContext,\n      checkRevoked\n    });\n  }\n\n  /**\n   * Imports a key pair instance via the provided `documentLoader` function,\n   * optionally checking it for revocation and required context.\n   *\n   * @param {object} options - Options hashmap.\n   * @param {string} options.id - Key ID or URI.\n   * @param {Function} options.documentLoader - JSON-LD Document Loader.\n   * @param {boolean} [options.checkContext=true] - Whether to check that the\n   *   fetched key document contains the context required by the key's crypto\n   *   suite.\n   * @param {boolean} [options.checkRevoked=true] - Whether to check the key\n   *   object for the presence of the `revoked` timestamp.\n   *\n   * @returns {Promise<LDKeyPair>} Resolves with the appropriate key pair\n   *   instance.\n   */\n  async fromKeyId({\n    id,\n    documentLoader,\n    checkContext = true,\n    checkRevoked = true\n  } = {}) {\n    if (!id) {\n      throw new TypeError('The \"id\" parameter is required.');\n    }\n    if (!documentLoader) {\n      throw new TypeError('The \"documentLoader\" parameter is required.');\n    }\n    let keyDocument;\n    try {\n      ({\n        document: keyDocument\n      } = await documentLoader(id));\n      // the supplied documentLoader may not be properly implemented\n      if (!keyDocument) {\n        throw new Error('The \"documentLoader\" function must return a \"document\" object.');\n      }\n    } catch (e) {\n      const error = new Error('Error fetching document: ' + e.message);\n      error.cause = e;\n      throw error;\n    }\n    const fetchedType = keyDocument.type;\n    if (!fetchedType) {\n      throw new Error('Key suite type not found in fetched document.');\n    }\n    const keySuite = this.suites.get(fetchedType);\n    if (!keySuite) {\n      throw new Error(`Support for suite \"${fetchedType}\" is not installed.`);\n    }\n    return keySuite.fromKeyDocument({\n      document: keyDocument,\n      checkContext,\n      checkRevoked\n    });\n  }\n\n  /**\n   * Tests if a given key type is currently installed.\n   *\n   * @param {string} [type] - Key suite id ('Ed25519VerificationKey2020').\n   * @private\n   *\n   * @returns {boolean} True if key type installed.\n   */\n  _installed({\n    type\n  }) {\n    return this.suites.has(type);\n  }\n\n  /**\n   * Returns the installed crypto suite class for a given document's type.\n   *\n   * @param {object} document - A serialized key document (or options document).\n   * @param {string} document.type - Key suite id (for example,\n   *   'Ed25519VerificationKey2020').\n   *\n   * @returns {object} LDKeyPair (crypto suite) class.\n   */\n  _suiteForType(document) {\n    const type = document && document.type;\n    if (!type) {\n      throw new TypeError('Missing key type.');\n    }\n    if (!this._installed({\n      type\n    })) {\n      throw new Error(`Support for key type \"${type}\" is not installed.`);\n    }\n    return this.suites.get(type);\n  }\n}\n\n/**\n * @typedef LDKeyPair\n */","map":{"version":3,"names":["CryptoLD","constructor","suites","Map","use","keyPairLib","set","suite","generate","options","Suite","_suiteForType","from","serialized","fromKeyDocument","document","checkContext","checkRevoked","TypeError","fromKeyId","id","documentLoader","keyDocument","Error","e","error","message","cause","fetchedType","type","keySuite","get","_installed","has"],"sources":["/home/pratap/domain-linkege/node_modules/crypto-ld/lib/CryptoLD.js"],"sourcesContent":["/*!\n * Copyright (c) 2020-2022 Digital Bazaar, Inc. All rights reserved.\n */\n\n/**\n * General purpose key generation driver for Linked Data cryptographic key\n * pairs.\n *\n * @param {Map} [suites] - Optional map of supported suites, by suite id.\n */\nexport class CryptoLD {\n  constructor({suites} = {}) {\n    this.suites = suites || new Map();\n  }\n\n  /**\n   * Installs support for a key type (suite).\n   *\n   * @param {LDKeyPair} keyPairLib - Conforming key pair library for a suite.\n   */\n  use(keyPairLib) {\n    this.suites.set(keyPairLib.suite, keyPairLib);\n  }\n\n  /**\n   * Generates a public/private LDKeyPair.\n   *\n   * @param {object} options - Suite-specific key options.\n   * @param {string} options.type - Key suite id (for example,\n   *   'Ed25519VerificationKey2020').\n   * @param {string} [options.controller] - Controller DID or URL for the\n   *   generated key pair. If present, used to auto-initialize the key.id.\n   *\n   * @returns {Promise<LDKeyPair>} Generated key pair.\n   */\n  async generate(options = {}) {\n    const Suite = this._suiteForType(options);\n    return Suite.generate(options);\n  }\n\n  /**\n   * Imports a public/private key pair from serialized data.\n   *\n   * @param {object} serialized - Serialized key object.\n   *\n   * @throws {Error} - On missing or invalid serialized key data.\n   *\n   * @returns {Promise<LDKeyPair>} Imported key pair.\n   */\n  async from(serialized = {}) {\n    const Suite = this._suiteForType(serialized);\n\n    if(serialized['@context']) {\n      // presume this may be an untrusted (fetched, etc) key document\n      return Suite.fromKeyDocument({document: serialized});\n    }\n\n    return Suite.from(serialized);\n  }\n\n  /**\n   * Imports a key pair instance from a provided externally fetched key\n   * document (fetched via a secure JSON-LD `documentLoader` or via\n   * `cryptoLd.fromKeyId()`), optionally checking it for revocation and required\n   * context.\n   *\n   * @param {object} options - Options hashmap.\n   * @param {string} options.document - Externally fetched key document.\n   * @param {boolean} [options.checkContext=true] - Whether to check that the\n   *   fetched key document contains the context required by the key's crypto\n   *   suite.\n   * @param {boolean} [options.checkRevoked=true] - Whether to check the key\n   *   object for the presence of the `revoked` timestamp.\n   *\n   * @returns {Promise<LDKeyPair>} Resolves with the resulting key pair\n   *   instance.\n   */\n  async fromKeyDocument({\n    document, checkContext = true, checkRevoked = true\n  } = {}) {\n    if(!document) {\n      throw new TypeError('The \"document\" parameter is required.');\n    }\n    const Suite = this._suiteForType(document);\n\n    return Suite.fromKeyDocument({document, checkContext, checkRevoked});\n  }\n\n  /**\n   * Imports a key pair instance via the provided `documentLoader` function,\n   * optionally checking it for revocation and required context.\n   *\n   * @param {object} options - Options hashmap.\n   * @param {string} options.id - Key ID or URI.\n   * @param {Function} options.documentLoader - JSON-LD Document Loader.\n   * @param {boolean} [options.checkContext=true] - Whether to check that the\n   *   fetched key document contains the context required by the key's crypto\n   *   suite.\n   * @param {boolean} [options.checkRevoked=true] - Whether to check the key\n   *   object for the presence of the `revoked` timestamp.\n   *\n   * @returns {Promise<LDKeyPair>} Resolves with the appropriate key pair\n   *   instance.\n   */\n  async fromKeyId({\n    id, documentLoader, checkContext = true, checkRevoked = true\n  } = {}) {\n    if(!id) {\n      throw new TypeError('The \"id\" parameter is required.');\n    }\n    if(!documentLoader) {\n      throw new TypeError('The \"documentLoader\" parameter is required.');\n    }\n    let keyDocument;\n    try {\n      ({document: keyDocument} = await documentLoader(id));\n      // the supplied documentLoader may not be properly implemented\n      if(!keyDocument) {\n        throw new Error(\n          'The \"documentLoader\" function must return a \"document\" object.');\n      }\n    } catch(e) {\n      const error = new Error('Error fetching document: ' + e.message);\n      error.cause = e;\n      throw error;\n    }\n    const fetchedType = keyDocument.type;\n    if(!fetchedType) {\n      throw new Error('Key suite type not found in fetched document.');\n    }\n    const keySuite = this.suites.get(fetchedType);\n    if(!keySuite) {\n      throw new Error(`Support for suite \"${fetchedType}\" is not installed.`);\n    }\n\n    return keySuite.fromKeyDocument({document: keyDocument, checkContext,\n      checkRevoked});\n  }\n\n  /**\n   * Tests if a given key type is currently installed.\n   *\n   * @param {string} [type] - Key suite id ('Ed25519VerificationKey2020').\n   * @private\n   *\n   * @returns {boolean} True if key type installed.\n   */\n  _installed({type}) {\n    return this.suites.has(type);\n  }\n\n  /**\n   * Returns the installed crypto suite class for a given document's type.\n   *\n   * @param {object} document - A serialized key document (or options document).\n   * @param {string} document.type - Key suite id (for example,\n   *   'Ed25519VerificationKey2020').\n   *\n   * @returns {object} LDKeyPair (crypto suite) class.\n   */\n  _suiteForType(document) {\n    const type = document && document.type;\n\n    if(!type) {\n      throw new TypeError('Missing key type.');\n    }\n    if(!this._installed({type})) {\n      throw new Error(`Support for key type \"${type}\" is not installed.`);\n    }\n\n    return this.suites.get(type);\n  }\n}\n\n/**\n * @typedef LDKeyPair\n */\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}