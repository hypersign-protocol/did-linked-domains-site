{"ast":null,"code":"/*!\n * Copyright (c) 2018-2022 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n\nrequire(\"core-js/modules/es.array.push.js\");\nconst constants = require('./constants');\nconst jsonld = require('jsonld');\nconst {\n  extendContextLoader,\n  strictDocumentLoader\n} = require('./documentLoader');\nconst {\n  serializeError\n} = require('serialize-error');\nmodule.exports = class ProofSet {\n  /**\n   * Adds a Linked Data proof to a document. If the document contains other\n   * proofs, the new proof will be appended to the existing set of proofs.\n   *\n   * Important note: This method assumes that the term `proof` in the given\n   * document has the same definition as the `https://w3id.org/security/v2`\n   * JSON-LD @context.\n   *\n   * @param document {object} - JSON-LD Document to be signed.\n   * @param options {object} Options hashmap.\n   *\n   * A `suite` option is required:\n   *\n   * @param options.suite {LinkedDataSignature} a signature suite instance\n   *   that will create the proof.\n   *\n   * A `purpose` option is required:\n   *\n   * @param options.purpose {ProofPurpose} a proof purpose instance that will\n   *   augment the proof with information describing its intended purpose.\n   *\n   * Advanced optional parameters and overrides:\n   *\n   * @param [documentLoader] {function} a custom document loader,\n   *   `Promise<RemoteDocument> documentLoader(url)`.\n   *\n   * @return {Promise<object>} resolves with the signed document, with\n   *   the signature in the top-level `proof` property.\n   */\n  async add(document, {\n    suite,\n    purpose,\n    documentLoader\n  } = {}) {\n    if (!suite) {\n      throw new TypeError('\"options.suite\" is required.');\n    }\n    if (!purpose) {\n      throw new TypeError('\"options.purpose\" is required.');\n    }\n    if (documentLoader) {\n      documentLoader = extendContextLoader(documentLoader);\n    } else {\n      documentLoader = strictDocumentLoader;\n    }\n\n    // shallow copy document to allow removal of existing proofs\n    const input = {\n      ...document\n    };\n    delete input.proof;\n\n    // get existing proof set, if any\n    const proofSet = _getProofs({\n      document\n    });\n\n    // create the new proof\n    const proof = await suite.createProof({\n      document: input,\n      purpose,\n      proofSet,\n      documentLoader\n    });\n    jsonld.addValue(document, 'proof', proof);\n    return document;\n  }\n\n  /**\n   * Derives a new Linked Data document with a new `proof` from an existing\n   * document with an existing proof set.\n   *\n   * Important note: This method assumes that the term `proof` in the given\n   * document has the same definition as the `https://w3id.org/security/v2`\n   * JSON-LD @context.\n   *\n   * @param document {object} - JSON-LD Document from which to derive a proof.\n   * @param options {object} Options hashmap.\n   *\n   * A `suite` option is required:\n   *\n   * @param options.suite {LinkedDataSignature} a signature suite instance\n   *   that will derive the new document and new `proof`.\n   *\n   * A `purpose` option is required:\n   *\n   * @param options.purpose {ProofPurpose} a proof purpose instance that will\n   *   augment the proof with information describing its intended purpose.\n   *\n   * Advanced optional parameters and overrides:\n   *\n   * @param [documentLoader] {function} a custom document loader,\n   *   `Promise<RemoteDocument> documentLoader(url)`.\n   *\n   * @return {Promise<object>} resolves with the new document, with a new\n   *   top-level `proof` property.\n   */\n  async derive(document, {\n    suite,\n    purpose,\n    documentLoader\n  } = {}) {\n    if (!suite) {\n      throw new TypeError('\"options.suite\" is required.');\n    }\n    if (!purpose) {\n      throw new TypeError('\"options.purpose\" is required.');\n    }\n    if (documentLoader) {\n      documentLoader = extendContextLoader(documentLoader);\n    } else {\n      documentLoader = strictDocumentLoader;\n    }\n\n    // shallow copy document to allow removal of existing proofs\n    const input = {\n      ...document\n    };\n    delete input.proof;\n\n    // get existing proof set, if any\n    const proofSet = _getProofs({\n      document\n    });\n\n    // create the new document and proof\n    const newDocument = await suite.derive({\n      document: input,\n      purpose,\n      proofSet,\n      documentLoader\n    });\n    return newDocument;\n  }\n\n  /**\n   * Verifies Linked Data proof(s) on a document. The proofs to be verified\n   * must match the given proof purpose.\n   *\n   * Important note: This method assumes that the term `proof` in the given\n   * document has the same definition as the `https://w3id.org/security/v2`\n   * JSON-LD @context.\n   *\n   * @param {object} document - The JSON-LD document with one or more proofs to\n   *   be verified.\n   *\n   * @param {LinkedDataSignature|LinkedDataSignature[]} suite -\n   *   Acceptable signature suite instances for verifying the proof(s).\n   *\n   * @param {ProofPurpose} purpose - A proof purpose instance that will\n   *   match proofs to be verified and ensure they were created according to\n   *   the appropriate purpose.\n   *\n   * Advanced optional parameters and overrides:\n   *\n   * @param {function} [documentLoader]  a custom document loader,\n   *   `Promise<RemoteDocument> documentLoader(url)`.\n   *\n   * @return {Promise<{verified: boolean, results: Array, error: *}>} resolves\n   *   with an object with a `verified`boolean property that is `true` if at\n   *   least one proof matching the given purpose and suite verifies and `false`\n   *   otherwise; a `results` property with an array of detailed results;\n   *   if `false` an `error` property will be present.\n   */\n  async verify(document, {\n    suite,\n    purpose,\n    documentLoader\n  } = {}) {\n    if (!suite) {\n      throw new TypeError('\"options.suite\" is required.');\n    }\n    if (!purpose) {\n      throw new TypeError('\"options.purpose\" is required.');\n    }\n    const suites = Array.isArray(suite) ? suite : [suite];\n    if (suites.length === 0) {\n      throw new TypeError('At least one suite is required.');\n    }\n    if (documentLoader) {\n      documentLoader = extendContextLoader(documentLoader);\n    } else {\n      documentLoader = strictDocumentLoader;\n    }\n    try {\n      // shallow copy to allow for removal of proof set prior to canonize\n      document = {\n        ...document\n      };\n\n      // get proofs from document\n      const proofSet = _getProofs({\n        document\n      });\n      if (proofSet.length === 0) {\n        // no possible matches\n        throw new Error('No matching proofs found in the given document.');\n      }\n      // clear proofs from shallow copy\n      delete document.proof;\n\n      // verify proofs\n      const results = await _verify({\n        document,\n        suites,\n        proofSet,\n        purpose,\n        documentLoader\n      });\n      if (results.length === 0) {\n        const error = new Error('Did not verify any proofs; insufficient proofs matched the ' + 'acceptable suite(s) and required purpose(s).');\n        error.name = 'NotFoundError';\n        throw error;\n      }\n\n      // combine results\n      const verified = results.some(r => r.verified);\n      if (!verified) {\n        const errors = [].concat(...results.filter(r => r.error).map(r => r.error));\n        const result = {\n          verified,\n          results\n        };\n        if (errors.length > 0) {\n          result.error = errors;\n        }\n        return result;\n      }\n      return {\n        verified,\n        results\n      };\n    } catch (error) {\n      _makeSerializable(error);\n      return {\n        verified: false,\n        error\n      };\n    }\n  }\n};\nfunction _getProofs({\n  document\n}) {\n  // handle document preprocessing to find proofs\n  let proofSet;\n  proofSet = jsonld.getValues(document, 'proof');\n\n  // shallow copy proofs and add document context or SECURITY_CONTEXT_URL\n  const context = document['@context'] || constants.SECURITY_CONTEXT_URL;\n  proofSet = proofSet.map(proof => ({\n    '@context': context,\n    ...proof\n  }));\n  return proofSet;\n}\nasync function _verify({\n  document,\n  suites,\n  proofSet,\n  purpose,\n  documentLoader\n}) {\n  // map each purpose to at least one proof to verify\n  const purposes = Array.isArray(purpose) ? purpose : [purpose];\n  const purposeToProofs = new Map();\n  const proofToSuite = new Map();\n  const suiteMatchQueue = new Map();\n  await Promise.all(purposes.map(purpose => _matchProofSet({\n    purposeToProofs,\n    proofToSuite,\n    purpose,\n    proofSet,\n    suites,\n    suiteMatchQueue,\n    document,\n    documentLoader\n  })));\n\n  // every purpose must have at least one matching proof or verify will fail\n  if (purposeToProofs.size < purposes.length) {\n    // insufficient proofs to verify, so don't bother verifying any\n    return [];\n  }\n\n  // verify every proof in `proofToSuite`; these proofs matched a purpose\n  const verifyResults = new Map();\n  await Promise.all([...proofToSuite.entries()].map(async ([proof, suite]) => {\n    let result;\n    try {\n      // create backwards-compatible deferred proof purpose to capture\n      // verification method from old-style suites\n      let vm;\n      const purpose = {\n        async validate(proof, {\n          verificationMethod\n        }) {\n          vm = verificationMethod;\n          return {\n            valid: true\n          };\n        }\n      };\n      const {\n        verified,\n        verificationMethod,\n        error\n      } = await suite.verifyProof({\n        proof,\n        document,\n        purpose,\n        proofSet,\n        documentLoader\n      });\n      if (!vm) {\n        vm = verificationMethod;\n      }\n      result = {\n        proof,\n        verified,\n        verificationMethod: vm,\n        error\n      };\n    } catch (error) {\n      result = {\n        proof,\n        verified: false,\n        error\n      };\n    }\n    if (result.error) {\n      // ensure error is serializable\n      _makeSerializable(result.error);\n    }\n    verifyResults.set(proof, result);\n  }));\n\n  // validate proof against each purpose that matched it\n  await Promise.all([...purposeToProofs.entries()].map(async ([purpose, proofs]) => {\n    for (const proof of proofs) {\n      const result = verifyResults.get(proof);\n      if (!result.verified) {\n        // if proof was not verified, so not bother validating purpose\n        continue;\n      }\n\n      // validate purpose\n      const {\n        verificationMethod\n      } = result;\n      const suite = proofToSuite.get(proof);\n      let purposeResult;\n      try {\n        purposeResult = await purpose.validate(proof, {\n          document,\n          suite,\n          verificationMethod,\n          documentLoader\n        });\n      } catch (error) {\n        purposeResult = {\n          valid: false,\n          error\n        };\n      }\n\n      // add `purposeResult` to verification result regardless of validity\n      // to ensure that all purposes are represented\n      if (result.purposeResult) {\n        if (Array.isArray(result.purposeResult)) {\n          result.purposeResult.push(purposeResult);\n        } else {\n          result.purposeResult = [result.purposeResult, purposeResult];\n        }\n      } else {\n        result.purposeResult = purposeResult;\n      }\n      if (!purposeResult.valid) {\n        // ensure error is serializable\n        _makeSerializable(purposeResult.error);\n\n        // if no top level error set yet, set it\n        if (!result.error) {\n          result.verified = false;\n          result.error = purposeResult.error;\n        }\n      }\n    }\n  }));\n  return [...verifyResults.values()];\n}\n\n// add a `toJSON` method to an error which allows for errors in validation\n// reports to be serialized properly by `JSON.stringify`.\nfunction _makeSerializable(error) {\n  Object.defineProperty(error, 'toJSON', {\n    value: function () {\n      return serializeError(this);\n    },\n    configurable: true,\n    writable: true\n  });\n}\nasync function _matchProofSet({\n  purposeToProofs,\n  proofToSuite,\n  purpose,\n  proofSet,\n  suites,\n  suiteMatchQueue,\n  document,\n  documentLoader\n}) {\n  for (const proof of proofSet) {\n    // first check if the proof matches the purpose; if it doesn't continue\n    if (!(await purpose.match(proof, {\n      document,\n      documentLoader\n    }))) {\n      continue;\n    }\n\n    // next, find the suite that can verify the proof; if found, `matched`\n    // will be set to `true` and the proof will be added to `purposeToProofs`\n    // and `proofToSuite` to be processed -- otherwise it will not be; if\n    // no proofs are added for a given purpose, an exception will be thrown\n    let matched = false;\n    for (const s of suites) {\n      // `matchingProofs` is a map of promises that resolve to whether a\n      // proof matches a suite; multiple purposes and suites may be checked\n      // in parallel so a promise queue is used to prevent duplicate work\n      let matchingProofs = suiteMatchQueue.get(s);\n      if (!matchingProofs) {\n        suiteMatchQueue.set(s, matchingProofs = new Map());\n      }\n      let promise = matchingProofs.get(proof);\n      if (!promise) {\n        promise = s.matchProof({\n          proof,\n          document,\n          documentLoader\n        });\n        matchingProofs.set(proof, promise);\n      }\n      if (await promise) {\n        // found the matching suite for the proof; there should only be one\n        // suite that can verify a particular proof; add the proof to the\n        // map of proofs to be verified along with the matching suite\n        matched = true;\n        proofToSuite.set(proof, s);\n        break;\n      }\n    }\n    if (matched) {\n      // note proof was a match for the purpose and an acceptable suite; it\n      // will need to be verified by the suite and then validated against the\n      // purpose\n      const matches = purposeToProofs.get(purpose);\n      if (matches) {\n        matches.push(proof);\n      } else {\n        purposeToProofs.set(purpose, [proof]);\n      }\n    }\n  }\n}","map":{"version":3,"names":["require","constants","jsonld","extendContextLoader","strictDocumentLoader","serializeError","module","exports","ProofSet","add","document","suite","purpose","documentLoader","TypeError","input","proof","proofSet","_getProofs","createProof","addValue","derive","newDocument","verify","suites","Array","isArray","length","Error","results","_verify","error","name","verified","some","r","errors","concat","filter","map","result","_makeSerializable","getValues","context","SECURITY_CONTEXT_URL","purposes","purposeToProofs","Map","proofToSuite","suiteMatchQueue","Promise","all","_matchProofSet","size","verifyResults","entries","vm","validate","verificationMethod","valid","verifyProof","set","proofs","get","purposeResult","push","values","Object","defineProperty","value","configurable","writable","match","matched","s","matchingProofs","promise","matchProof","matches"],"sources":["/home/pratap/did-linked-domain/node_modules/jsonld-signatures/lib/ProofSet.js"],"sourcesContent":["/*!\n * Copyright (c) 2018-2022 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n\nconst constants = require('./constants');\nconst jsonld = require('jsonld');\nconst {extendContextLoader, strictDocumentLoader} = require('./documentLoader');\nconst {serializeError} = require('serialize-error');\n\nmodule.exports = class ProofSet {\n  /**\n   * Adds a Linked Data proof to a document. If the document contains other\n   * proofs, the new proof will be appended to the existing set of proofs.\n   *\n   * Important note: This method assumes that the term `proof` in the given\n   * document has the same definition as the `https://w3id.org/security/v2`\n   * JSON-LD @context.\n   *\n   * @param document {object} - JSON-LD Document to be signed.\n   * @param options {object} Options hashmap.\n   *\n   * A `suite` option is required:\n   *\n   * @param options.suite {LinkedDataSignature} a signature suite instance\n   *   that will create the proof.\n   *\n   * A `purpose` option is required:\n   *\n   * @param options.purpose {ProofPurpose} a proof purpose instance that will\n   *   augment the proof with information describing its intended purpose.\n   *\n   * Advanced optional parameters and overrides:\n   *\n   * @param [documentLoader] {function} a custom document loader,\n   *   `Promise<RemoteDocument> documentLoader(url)`.\n   *\n   * @return {Promise<object>} resolves with the signed document, with\n   *   the signature in the top-level `proof` property.\n   */\n  async add(document, {suite, purpose, documentLoader} = {}) {\n    if(!suite) {\n      throw new TypeError('\"options.suite\" is required.');\n    }\n    if(!purpose) {\n      throw new TypeError('\"options.purpose\" is required.');\n    }\n\n    if(documentLoader) {\n      documentLoader = extendContextLoader(documentLoader);\n    } else {\n      documentLoader = strictDocumentLoader;\n    }\n\n    // shallow copy document to allow removal of existing proofs\n    const input = {...document};\n    delete input.proof;\n\n    // get existing proof set, if any\n    const proofSet = _getProofs({document});\n\n    // create the new proof\n    const proof = await suite.createProof({\n      document: input, purpose, proofSet, documentLoader\n    });\n\n    jsonld.addValue(document, 'proof', proof);\n\n    return document;\n  }\n\n  /**\n   * Derives a new Linked Data document with a new `proof` from an existing\n   * document with an existing proof set.\n   *\n   * Important note: This method assumes that the term `proof` in the given\n   * document has the same definition as the `https://w3id.org/security/v2`\n   * JSON-LD @context.\n   *\n   * @param document {object} - JSON-LD Document from which to derive a proof.\n   * @param options {object} Options hashmap.\n   *\n   * A `suite` option is required:\n   *\n   * @param options.suite {LinkedDataSignature} a signature suite instance\n   *   that will derive the new document and new `proof`.\n   *\n   * A `purpose` option is required:\n   *\n   * @param options.purpose {ProofPurpose} a proof purpose instance that will\n   *   augment the proof with information describing its intended purpose.\n   *\n   * Advanced optional parameters and overrides:\n   *\n   * @param [documentLoader] {function} a custom document loader,\n   *   `Promise<RemoteDocument> documentLoader(url)`.\n   *\n   * @return {Promise<object>} resolves with the new document, with a new\n   *   top-level `proof` property.\n   */\n  async derive(document, {suite, purpose, documentLoader} = {}) {\n    if(!suite) {\n      throw new TypeError('\"options.suite\" is required.');\n    }\n    if(!purpose) {\n      throw new TypeError('\"options.purpose\" is required.');\n    }\n\n    if(documentLoader) {\n      documentLoader = extendContextLoader(documentLoader);\n    } else {\n      documentLoader = strictDocumentLoader;\n    }\n\n    // shallow copy document to allow removal of existing proofs\n    const input = {...document};\n    delete input.proof;\n\n    // get existing proof set, if any\n    const proofSet = _getProofs({document});\n\n    // create the new document and proof\n    const newDocument = await suite.derive({\n      document: input, purpose, proofSet, documentLoader\n    });\n\n    return newDocument;\n  }\n\n  /**\n   * Verifies Linked Data proof(s) on a document. The proofs to be verified\n   * must match the given proof purpose.\n   *\n   * Important note: This method assumes that the term `proof` in the given\n   * document has the same definition as the `https://w3id.org/security/v2`\n   * JSON-LD @context.\n   *\n   * @param {object} document - The JSON-LD document with one or more proofs to\n   *   be verified.\n   *\n   * @param {LinkedDataSignature|LinkedDataSignature[]} suite -\n   *   Acceptable signature suite instances for verifying the proof(s).\n   *\n   * @param {ProofPurpose} purpose - A proof purpose instance that will\n   *   match proofs to be verified and ensure they were created according to\n   *   the appropriate purpose.\n   *\n   * Advanced optional parameters and overrides:\n   *\n   * @param {function} [documentLoader]  a custom document loader,\n   *   `Promise<RemoteDocument> documentLoader(url)`.\n   *\n   * @return {Promise<{verified: boolean, results: Array, error: *}>} resolves\n   *   with an object with a `verified`boolean property that is `true` if at\n   *   least one proof matching the given purpose and suite verifies and `false`\n   *   otherwise; a `results` property with an array of detailed results;\n   *   if `false` an `error` property will be present.\n   */\n  async verify(document, {suite, purpose, documentLoader} = {}) {\n    if(!suite) {\n      throw new TypeError('\"options.suite\" is required.');\n    }\n    if(!purpose) {\n      throw new TypeError('\"options.purpose\" is required.');\n    }\n    const suites = Array.isArray(suite) ? suite : [suite];\n    if(suites.length === 0) {\n      throw new TypeError('At least one suite is required.');\n    }\n\n    if(documentLoader) {\n      documentLoader = extendContextLoader(documentLoader);\n    } else {\n      documentLoader = strictDocumentLoader;\n    }\n\n    try {\n      // shallow copy to allow for removal of proof set prior to canonize\n      document = {...document};\n\n      // get proofs from document\n      const proofSet = _getProofs({document});\n      if(proofSet.length === 0) {\n        // no possible matches\n        throw new Error('No matching proofs found in the given document.');\n      }\n      // clear proofs from shallow copy\n      delete document.proof;\n\n      // verify proofs\n      const results = await _verify(\n        {document, suites, proofSet, purpose, documentLoader});\n      if(results.length === 0) {\n        const error = new Error(\n          'Did not verify any proofs; insufficient proofs matched the ' +\n          'acceptable suite(s) and required purpose(s).');\n        error.name = 'NotFoundError';\n        throw error;\n      }\n\n      // combine results\n      const verified = results.some(r => r.verified);\n      if(!verified) {\n        const errors = [].concat(\n          ...results.filter(r => r.error).map(r => r.error));\n        const result = {verified, results};\n        if(errors.length > 0) {\n          result.error = errors;\n        }\n        return result;\n      }\n      return {verified, results};\n    } catch(error) {\n      _makeSerializable(error);\n      return {verified: false, error};\n    }\n  }\n};\n\nfunction _getProofs({document}) {\n  // handle document preprocessing to find proofs\n  let proofSet;\n  proofSet = jsonld.getValues(document, 'proof');\n\n  // shallow copy proofs and add document context or SECURITY_CONTEXT_URL\n  const context = document['@context'] || constants.SECURITY_CONTEXT_URL;\n  proofSet = proofSet.map(proof => ({\n    '@context': context,\n    ...proof\n  }));\n\n  return proofSet;\n}\n\nasync function _verify({\n  document, suites, proofSet, purpose, documentLoader\n}) {\n  // map each purpose to at least one proof to verify\n  const purposes = Array.isArray(purpose) ? purpose : [purpose];\n  const purposeToProofs = new Map();\n  const proofToSuite = new Map();\n  const suiteMatchQueue = new Map();\n  await Promise.all(purposes.map(purpose => _matchProofSet({\n    purposeToProofs, proofToSuite, purpose, proofSet, suites,\n    suiteMatchQueue, document, documentLoader\n  })));\n\n  // every purpose must have at least one matching proof or verify will fail\n  if(purposeToProofs.size < purposes.length) {\n    // insufficient proofs to verify, so don't bother verifying any\n    return [];\n  }\n\n  // verify every proof in `proofToSuite`; these proofs matched a purpose\n  const verifyResults = new Map();\n  await Promise.all([...proofToSuite.entries()].map(async ([proof, suite]) => {\n    let result;\n    try {\n      // create backwards-compatible deferred proof purpose to capture\n      // verification method from old-style suites\n      let vm;\n      const purpose = {\n        async validate(proof, {verificationMethod}) {\n          vm = verificationMethod;\n          return {valid: true};\n        }\n      };\n      const {verified, verificationMethod, error} = await suite.verifyProof(\n        {proof, document, purpose, proofSet, documentLoader});\n      if(!vm) {\n        vm = verificationMethod;\n      }\n      result = {proof, verified, verificationMethod: vm, error};\n    } catch(error) {\n      result = {proof, verified: false, error};\n    }\n\n    if(result.error) {\n      // ensure error is serializable\n      _makeSerializable(result.error);\n    }\n\n    verifyResults.set(proof, result);\n  }));\n\n  // validate proof against each purpose that matched it\n  await Promise.all([...purposeToProofs.entries()].map(\n    async ([purpose, proofs]) => {\n      for(const proof of proofs) {\n        const result = verifyResults.get(proof);\n        if(!result.verified) {\n          // if proof was not verified, so not bother validating purpose\n          continue;\n        }\n\n        // validate purpose\n        const {verificationMethod} = result;\n        const suite = proofToSuite.get(proof);\n        let purposeResult;\n        try {\n          purposeResult = await purpose.validate(proof, {\n            document, suite, verificationMethod, documentLoader\n          });\n        } catch(error) {\n          purposeResult = {valid: false, error};\n        }\n\n        // add `purposeResult` to verification result regardless of validity\n        // to ensure that all purposes are represented\n        if(result.purposeResult) {\n          if(Array.isArray(result.purposeResult)) {\n            result.purposeResult.push(purposeResult);\n          } else {\n            result.purposeResult = [result.purposeResult, purposeResult];\n          }\n        } else {\n          result.purposeResult = purposeResult;\n        }\n\n        if(!purposeResult.valid) {\n          // ensure error is serializable\n          _makeSerializable(purposeResult.error);\n\n          // if no top level error set yet, set it\n          if(!result.error) {\n            result.verified = false;\n            result.error = purposeResult.error;\n          }\n        }\n      }\n    }));\n\n  return [...verifyResults.values()];\n}\n\n// add a `toJSON` method to an error which allows for errors in validation\n// reports to be serialized properly by `JSON.stringify`.\nfunction _makeSerializable(error) {\n  Object.defineProperty(error, 'toJSON', {\n    value: function() {\n      return serializeError(this);\n    },\n    configurable: true,\n    writable: true\n  });\n}\n\nasync function _matchProofSet({\n  purposeToProofs, proofToSuite, purpose, proofSet, suites,\n  suiteMatchQueue, document, documentLoader\n}) {\n  for(const proof of proofSet) {\n    // first check if the proof matches the purpose; if it doesn't continue\n    if(!await purpose.match(proof, {document, documentLoader})) {\n      continue;\n    }\n\n    // next, find the suite that can verify the proof; if found, `matched`\n    // will be set to `true` and the proof will be added to `purposeToProofs`\n    // and `proofToSuite` to be processed -- otherwise it will not be; if\n    // no proofs are added for a given purpose, an exception will be thrown\n    let matched = false;\n    for(const s of suites) {\n      // `matchingProofs` is a map of promises that resolve to whether a\n      // proof matches a suite; multiple purposes and suites may be checked\n      // in parallel so a promise queue is used to prevent duplicate work\n      let matchingProofs = suiteMatchQueue.get(s);\n      if(!matchingProofs) {\n        suiteMatchQueue.set(s, matchingProofs = new Map());\n      }\n      let promise = matchingProofs.get(proof);\n      if(!promise) {\n        promise = s.matchProof({proof, document, documentLoader});\n        matchingProofs.set(proof, promise);\n      }\n      if(await promise) {\n        // found the matching suite for the proof; there should only be one\n        // suite that can verify a particular proof; add the proof to the\n        // map of proofs to be verified along with the matching suite\n        matched = true;\n        proofToSuite.set(proof, s);\n        break;\n      }\n    }\n\n    if(matched) {\n      // note proof was a match for the purpose and an acceptable suite; it\n      // will need to be verified by the suite and then validated against the\n      // purpose\n      const matches = purposeToProofs.get(purpose);\n      if(matches) {\n        matches.push(proof);\n      } else {\n        purposeToProofs.set(purpose, [proof]);\n      }\n    }\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}