{"ast":null,"code":"/*!\n * Copyright (c) 2020 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n\n/**\n * General purpose key generation driver for Linked Data cryptographic key\n * pairs.\n *\n * @param {Map} [suites] - Optional map of supported suites, by suite id.\n */\nclass CryptoLD {\n  constructor({\n    suites\n  } = {}) {\n    this.suites = suites || new Map();\n  }\n\n  /**\n   * Installs support for a key type (suite).\n   *\n   * @param {LDKeyPair} keyPairLib - Conforming key pair library for a suite.\n   */\n  use(keyPairLib) {\n    this.suites.set(keyPairLib.suite, keyPairLib);\n  }\n\n  /**\n   * Generates a public/private LDKeyPair.\n   *\n   * @param {string} type - Key suite id ('Ed25519VerificationKey2020').\n   *\n   * @param {object} [options] - Optional suite-specific key options.\n   * @param {string} [options.controller] - Controller DID or URL for the\n   *   generated key pair. If present, used to auto-initialize the key.id.\n   *\n   * @returns {Promise<LDKeyPair>}\n   */\n  async generate({\n    type,\n    ...options\n  } = {}) {\n    if (!type) {\n      throw new TypeError('A key type is required to generate.');\n    }\n    if (!this._installed({\n      type\n    })) {\n      throw new TypeError(`Support for key type \"${type}\" is not installed.`);\n    }\n    return this.suites.get(type).generate(options);\n  }\n\n  /**\n   * Imports a public/private key pair from serialized data.\n   *\n   * @param {object} serialized - Serialized key object.\n   *\n   * @throws {Error} - On missing or invalid serialized key data.\n   *\n   * @returns {Promise<LDKeyPair>}\n   */\n  async from(serialized = {}) {\n    const type = serialized && serialized.type;\n    if (!type) {\n      throw new TypeError('Missing key type.');\n    }\n    if (!this._installed({\n      type\n    })) {\n      throw new Error(`Support for key type \"${type}\" is not installed.`);\n    }\n    return this.suites.get(type).from(serialized);\n  }\n\n  /**\n   * Imports a key pair instance via the provided `documentLoader` function,\n   * optionally checking it for revocation and required context.\n   *\n   * @param {object} options - Options hashmap.\n   * @param {string} options.id - Key ID or URI.\n   * @param {Function} options.documentLoader - JSON-LD Document Loader.\n   * @param {boolean} [options.checkContext=true] - Whether to check that the\n   *   fetched key document contains the context required by the key's crypto\n   *   suite.\n   * @param {boolean} [options.checkRevoked=true] - Whether to check the key\n   *   object for the presence of the `revoked` timestamp.\n   *\n   * @returns {Promise<LDKeyPair>} Resolves with the appropriate key pair\n   *   instance.\n   */\n  async fromKeyId({\n    id,\n    documentLoader,\n    checkContext = true,\n    checkRevoked = true\n  } = {}) {\n    if (!id) {\n      throw new TypeError('The \"id\" parameter is required.');\n    }\n    if (!documentLoader) {\n      throw new TypeError('The \"documentLoader\" parameter is required.');\n    }\n    let keyDocument;\n    try {\n      ({\n        document: keyDocument\n      } = await documentLoader(id));\n      // the supplied documentLoader may not be properly implemented\n      if (!keyDocument) {\n        throw new Error('The \"documentLoader\" function must return a \"document\" object.');\n      }\n    } catch (e) {\n      const error = new Error('Error fetching document: ' + e.message);\n      error.cause = e;\n      throw error;\n    }\n    const fetchedType = keyDocument.type;\n    if (!fetchedType) {\n      throw new Error('Key suite type not found in fetched document.');\n    }\n    const keySuite = this.suites.get(fetchedType);\n    if (!keySuite) {\n      throw new Error(`Support for suite \"${fetchedType}\" is not installed.`);\n    }\n    return keySuite.fromKeyDocument({\n      document: keyDocument,\n      checkContext,\n      checkRevoked\n    });\n  }\n\n  /**\n   * Tests if a given key type is currently installed.\n   *\n   * @param {string} [type] - Key suite id ('Ed25519VerificationKey2020').\n   * @private\n   */\n  _installed({\n    type\n  }) {\n    return this.suites.has(type);\n  }\n}\nmodule.exports = {\n  CryptoLD\n};","map":{"version":3,"names":["CryptoLD","constructor","suites","Map","use","keyPairLib","set","suite","generate","type","options","TypeError","_installed","get","from","serialized","Error","fromKeyId","id","documentLoader","checkContext","checkRevoked","keyDocument","document","e","error","message","cause","fetchedType","keySuite","fromKeyDocument","has","module","exports"],"sources":["/home/pratap/hid-ssi-js-sdk/node_modules/@digitalbazaar/ed25519-verification-key-2020/node_modules/crypto-ld/lib/CryptoLD.js"],"sourcesContent":["/*!\n * Copyright (c) 2020 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n\n/**\n * General purpose key generation driver for Linked Data cryptographic key\n * pairs.\n *\n * @param {Map} [suites] - Optional map of supported suites, by suite id.\n */\nclass CryptoLD {\n  constructor({suites} = {}) {\n    this.suites = suites || new Map();\n  }\n\n  /**\n   * Installs support for a key type (suite).\n   *\n   * @param {LDKeyPair} keyPairLib - Conforming key pair library for a suite.\n   */\n  use(keyPairLib) {\n    this.suites.set(keyPairLib.suite, keyPairLib);\n  }\n\n  /**\n   * Generates a public/private LDKeyPair.\n   *\n   * @param {string} type - Key suite id ('Ed25519VerificationKey2020').\n   *\n   * @param {object} [options] - Optional suite-specific key options.\n   * @param {string} [options.controller] - Controller DID or URL for the\n   *   generated key pair. If present, used to auto-initialize the key.id.\n   *\n   * @returns {Promise<LDKeyPair>}\n   */\n  async generate({type, ...options} = {}) {\n    if(!type) {\n      throw new TypeError('A key type is required to generate.');\n    }\n    if(!this._installed({type})) {\n      throw new TypeError(`Support for key type \"${type}\" is not installed.`);\n    }\n\n    return this.suites.get(type).generate(options);\n  }\n\n  /**\n   * Imports a public/private key pair from serialized data.\n   *\n   * @param {object} serialized - Serialized key object.\n   *\n   * @throws {Error} - On missing or invalid serialized key data.\n   *\n   * @returns {Promise<LDKeyPair>}\n   */\n  async from(serialized = {}) {\n    const type = serialized && serialized.type;\n\n    if(!type) {\n      throw new TypeError('Missing key type.');\n    }\n    if(!this._installed({type})) {\n      throw new Error(`Support for key type \"${type}\" is not installed.`);\n    }\n\n    return this.suites.get(type).from(serialized);\n  }\n\n  /**\n   * Imports a key pair instance via the provided `documentLoader` function,\n   * optionally checking it for revocation and required context.\n   *\n   * @param {object} options - Options hashmap.\n   * @param {string} options.id - Key ID or URI.\n   * @param {Function} options.documentLoader - JSON-LD Document Loader.\n   * @param {boolean} [options.checkContext=true] - Whether to check that the\n   *   fetched key document contains the context required by the key's crypto\n   *   suite.\n   * @param {boolean} [options.checkRevoked=true] - Whether to check the key\n   *   object for the presence of the `revoked` timestamp.\n   *\n   * @returns {Promise<LDKeyPair>} Resolves with the appropriate key pair\n   *   instance.\n   */\n  async fromKeyId({\n    id, documentLoader, checkContext = true, checkRevoked = true\n  } = {}) {\n    if(!id) {\n      throw new TypeError('The \"id\" parameter is required.');\n    }\n    if(!documentLoader) {\n      throw new TypeError('The \"documentLoader\" parameter is required.');\n    }\n    let keyDocument;\n    try {\n      ({document: keyDocument} = await documentLoader(id));\n      // the supplied documentLoader may not be properly implemented\n      if(!keyDocument) {\n        throw new Error(\n          'The \"documentLoader\" function must return a \"document\" object.');\n      }\n    } catch(e) {\n      const error = new Error('Error fetching document: ' + e.message);\n      error.cause = e;\n      throw error;\n    }\n    const fetchedType = keyDocument.type;\n    if(!fetchedType) {\n      throw new Error('Key suite type not found in fetched document.');\n    }\n    const keySuite = this.suites.get(fetchedType);\n    if(!keySuite) {\n      throw new Error(`Support for suite \"${fetchedType}\" is not installed.`);\n    }\n\n    return keySuite.fromKeyDocument({document: keyDocument, checkContext,\n      checkRevoked});\n  }\n\n  /**\n   * Tests if a given key type is currently installed.\n   *\n   * @param {string} [type] - Key suite id ('Ed25519VerificationKey2020').\n   * @private\n   */\n  _installed({type}) {\n    return this.suites.has(type);\n  }\n}\n\nmodule.exports = {\n  CryptoLD\n};\n"],"mappings":"AAAA;AACA;AACA;AACA,YAAY;;AAEZ;AACA;AACA;AACA;AACA;AACA;AACA,MAAMA,QAAQ,CAAC;EACbC,WAAWA,CAAC;IAACC;EAAM,CAAC,GAAG,CAAC,CAAC,EAAE;IACzB,IAAI,CAACA,MAAM,GAAGA,MAAM,IAAI,IAAIC,GAAG,CAAC,CAAC;EACnC;;EAEA;AACF;AACA;AACA;AACA;EACEC,GAAGA,CAACC,UAAU,EAAE;IACd,IAAI,CAACH,MAAM,CAACI,GAAG,CAACD,UAAU,CAACE,KAAK,EAAEF,UAAU,CAAC;EAC/C;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,MAAMG,QAAQA,CAAC;IAACC,IAAI;IAAE,GAAGC;EAAO,CAAC,GAAG,CAAC,CAAC,EAAE;IACtC,IAAG,CAACD,IAAI,EAAE;MACR,MAAM,IAAIE,SAAS,CAAC,qCAAqC,CAAC;IAC5D;IACA,IAAG,CAAC,IAAI,CAACC,UAAU,CAAC;MAACH;IAAI,CAAC,CAAC,EAAE;MAC3B,MAAM,IAAIE,SAAS,CAAE,yBAAwBF,IAAK,qBAAoB,CAAC;IACzE;IAEA,OAAO,IAAI,CAACP,MAAM,CAACW,GAAG,CAACJ,IAAI,CAAC,CAACD,QAAQ,CAACE,OAAO,CAAC;EAChD;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,MAAMI,IAAIA,CAACC,UAAU,GAAG,CAAC,CAAC,EAAE;IAC1B,MAAMN,IAAI,GAAGM,UAAU,IAAIA,UAAU,CAACN,IAAI;IAE1C,IAAG,CAACA,IAAI,EAAE;MACR,MAAM,IAAIE,SAAS,CAAC,mBAAmB,CAAC;IAC1C;IACA,IAAG,CAAC,IAAI,CAACC,UAAU,CAAC;MAACH;IAAI,CAAC,CAAC,EAAE;MAC3B,MAAM,IAAIO,KAAK,CAAE,yBAAwBP,IAAK,qBAAoB,CAAC;IACrE;IAEA,OAAO,IAAI,CAACP,MAAM,CAACW,GAAG,CAACJ,IAAI,CAAC,CAACK,IAAI,CAACC,UAAU,CAAC;EAC/C;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,MAAME,SAASA,CAAC;IACdC,EAAE;IAAEC,cAAc;IAAEC,YAAY,GAAG,IAAI;IAAEC,YAAY,GAAG;EAC1D,CAAC,GAAG,CAAC,CAAC,EAAE;IACN,IAAG,CAACH,EAAE,EAAE;MACN,MAAM,IAAIP,SAAS,CAAC,iCAAiC,CAAC;IACxD;IACA,IAAG,CAACQ,cAAc,EAAE;MAClB,MAAM,IAAIR,SAAS,CAAC,6CAA6C,CAAC;IACpE;IACA,IAAIW,WAAW;IACf,IAAI;MACF,CAAC;QAACC,QAAQ,EAAED;MAAW,CAAC,GAAG,MAAMH,cAAc,CAACD,EAAE,CAAC;MACnD;MACA,IAAG,CAACI,WAAW,EAAE;QACf,MAAM,IAAIN,KAAK,CACb,gEAAgE,CAAC;MACrE;IACF,CAAC,CAAC,OAAMQ,CAAC,EAAE;MACT,MAAMC,KAAK,GAAG,IAAIT,KAAK,CAAC,2BAA2B,GAAGQ,CAAC,CAACE,OAAO,CAAC;MAChED,KAAK,CAACE,KAAK,GAAGH,CAAC;MACf,MAAMC,KAAK;IACb;IACA,MAAMG,WAAW,GAAGN,WAAW,CAACb,IAAI;IACpC,IAAG,CAACmB,WAAW,EAAE;MACf,MAAM,IAAIZ,KAAK,CAAC,+CAA+C,CAAC;IAClE;IACA,MAAMa,QAAQ,GAAG,IAAI,CAAC3B,MAAM,CAACW,GAAG,CAACe,WAAW,CAAC;IAC7C,IAAG,CAACC,QAAQ,EAAE;MACZ,MAAM,IAAIb,KAAK,CAAE,sBAAqBY,WAAY,qBAAoB,CAAC;IACzE;IAEA,OAAOC,QAAQ,CAACC,eAAe,CAAC;MAACP,QAAQ,EAAED,WAAW;MAAEF,YAAY;MAClEC;IAAY,CAAC,CAAC;EAClB;;EAEA;AACF;AACA;AACA;AACA;AACA;EACET,UAAUA,CAAC;IAACH;EAAI,CAAC,EAAE;IACjB,OAAO,IAAI,CAACP,MAAM,CAAC6B,GAAG,CAACtB,IAAI,CAAC;EAC9B;AACF;AAEAuB,MAAM,CAACC,OAAO,GAAG;EACfjC;AACF,CAAC"},"metadata":{},"sourceType":"script","externalDependencies":[]}