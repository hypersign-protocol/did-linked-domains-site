{"ast":null,"code":"\"use strict\";\n\nrequire(\"core-js/modules/es.array.push.js\");\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * Copyright (c) 2023, Hypermine Pvt. Ltd.\n * All rights reserved.\n * Author: Hypermine Core Team\n */\nconst jsonld_signatures_1 = require(\"jsonld-signatures\");\nconst vc_js_1 = __importDefault(require(\"vc-js\"));\nconst utils_1 = __importDefault(require(\"../utils\"));\nconst schema_1 = __importDefault(require(\"../schema/schema\"));\nconst did_1 = __importDefault(require(\"../did/did\"));\nconst ed25519_verification_key_2020_1 = require(\"@digitalbazaar/ed25519-verification-key-2020\");\nconst ed25519_signature_2020_1 = require(\"@digitalbazaar/ed25519-signature-2020\");\nconst ed25519 = require('@stablelib/ed25519');\nconst credRPC_1 = require(\"./credRPC\");\nconst constants_1 = require(\"../constants\");\nconst credential_1 = require(\"../../libs/generated/ssi/credential\");\nconst crypto_1 = __importDefault(require(\"crypto\"));\nconst v1_1 = __importDefault(require(\"../../libs/w3cache/v1\"));\nconst ethereumeip712signature2021suite_1 = require(\"ethereumeip712signature2021suite\");\nconst jsonld_signatures_2 = require(\"jsonld-signatures\");\nconst documentLoader = (0, jsonld_signatures_2.extendContextLoader)(v1_1.default);\nclass HypersignVerifiableCredential {\n  constructor(params = {}) {\n    this._checkIfAllRequiredPropsAreSent = (sentAttributes, requiredProps) => {\n      return !requiredProps.some(x => sentAttributes.indexOf(x) === -1);\n    };\n    this._getCredentialSubject = (schemaProperty, attributesMap) => {\n      const cs = {};\n      const sentPropes = Object.keys(attributesMap);\n      if (schemaProperty.properties) {\n        schemaProperty['propertiesParsed'] = JSON.parse(schemaProperty.properties);\n      }\n      const SchemaProps = Object.keys(schemaProperty['propertiesParsed']);\n      let props = [];\n      // Check for \"additionalProperties\" in schemaProperty\n      if (!schemaProperty.additionalProperties) {\n        if (sentPropes.length > SchemaProps.length || !this._checkIfAllRequiredPropsAreSent(SchemaProps, sentPropes)) throw new Error(`Only ${JSON.stringify(SchemaProps)} attributes are possible. additionalProperties is false in the schema`);\n        props = SchemaProps;\n      } else {\n        props = sentPropes;\n      }\n      // Check all required propes\n      const requiredPros = Object.values(schemaProperty.required);\n      if (!this._checkIfAllRequiredPropsAreSent(sentPropes, requiredPros)) throw new Error(`${JSON.stringify(requiredPros)} are required properties`);\n      // Attach the values of props\n      props.forEach(p => {\n        cs[p] = attributesMap[p];\n      });\n      return cs;\n    };\n    //\n    // TODO: https://www.w3.org/TR/vc-data-model/#data-schemas\n    // TODO: handle schemaUrl variable properly later.\n    this._getCredentialContext = (schemaId, schemaProperties) => {\n      const context = [];\n      let schemaUrl;\n      if (this.hsSchema && this.hsSchema.schemaRpc) {\n        schemaUrl = `${this.hsSchema.schemaRpc.schemaRestEp}/${schemaId}:`;\n      } else {\n        throw new Error('Error: HypersigSchema object may not be initialized');\n      }\n      context.push(constants_1.VC.CREDENTAIL_BASE_CONTEXT);\n      //context.push(VC.CREDENTAIL_SECURITY_SUITE);\n      context.push({\n        hs: schemaUrl\n      });\n      const props = Object.keys(schemaProperties);\n      props.forEach(x => {\n        const obj = {};\n        obj[x] = `hs:${x}`;\n        context.push(obj);\n      });\n      return context;\n    };\n    const {\n      namespace,\n      offlineSigner,\n      nodeRpcEndpoint,\n      nodeRestEndpoint\n    } = params;\n    this.namespace = namespace && namespace != '' ? namespace : '';\n    const nodeRPCEp = nodeRpcEndpoint ? nodeRpcEndpoint : 'MAIN';\n    const nodeRestEp = nodeRestEndpoint ? nodeRestEndpoint : '';\n    const offlineConstuctorParams = {\n      offlineSigner,\n      nodeRpcEndpoint: nodeRPCEp,\n      nodeRestEndpoint: nodeRestEp\n    };\n    this.credStatusRPC = new credRPC_1.CredentialRPC(offlineConstuctorParams);\n    this.hsDid = new did_1.default(offlineConstuctorParams);\n    this.hsSchema = new schema_1.default(offlineConstuctorParams);\n    this.context = [];\n    this.id = '';\n    this.type = [];\n    this.issuer = '';\n    this.issuanceDate = '';\n    this.expirationDate = '';\n    this.credentialSubject = {};\n    this.credentialSchema = {\n      id: '',\n      type: constants_1.VC.CREDENTAIL_SCHEMA_VALIDATOR_TYPE\n    };\n    this.credentialStatus = {\n      id: '',\n      type: constants_1.VC.CREDENTAIL_STATUS_TYPE\n    };\n    this.proof = {};\n  }\n  _sign(params) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const {\n        privateKeyMultibase: privateKeyMultibaseConverted\n      } = utils_1.default.convertEd25519verificationkey2020toStableLibKeysInto({\n        privKey: params.privateKeyMultibase\n      });\n      // TODO:  do proper checck of paramaters\n      const credentialStatus = JSON.parse(params.message);\n      const credentialBytes = (yield credential_1.CredentialStatus.encode(credentialStatus)).finish();\n      // const messageBytes = Buffer.from(params.message);\n      const signed = ed25519.sign(privateKeyMultibaseConverted, credentialBytes);\n      return Buffer.from(signed).toString('base64');\n    });\n  }\n  _dateNow(date) {\n    if (date) {\n      return new Date(date).toISOString().slice(0, -5) + 'Z';\n    } else {\n      return new Date(new Date().getTime() - 100000).toISOString().slice(0, -5) + 'Z';\n    }\n  }\n  _sha256Hash(message) {\n    const sha256 = crypto_1.default.createHash('sha256');\n    return sha256.update(message).digest('hex');\n  }\n  _getId() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const uuid = yield utils_1.default.getUUID();\n      let id;\n      if (this.namespace && this.namespace != '') {\n        id = `${constants_1.VC.SCHEME}:${constants_1.VC.METHOD}:${this.namespace}:${uuid}`;\n      } else {\n        id = `${constants_1.VC.SCHEME}:${constants_1.VC.METHOD}:${uuid}`;\n      }\n      return id;\n    });\n  }\n  /**\n   * Initialise the offlinesigner to interact with Hypersign blockchain\n   */\n  init() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.credStatusRPC) {\n        throw new Error('HID-SSI-SDK:: Error: HypersignVerifiableCredential class is not instantiated with Offlinesigner or have not been initilized');\n      }\n      yield this.credStatusRPC.init();\n    });\n  }\n  /**\n   * Generates a new credential document\n   * @params\n   *  - params.schemaId             : Hypersign schema id\n   *  - params.subjectDid           : DID of the subject, if not provided, will be taken from subjectDidDocSigned\n   *  - params.schemaContext        :\n   *  - params.type                 :\n   *  - params.issuerDid            :  DID of the issuer\n   *  - params.expirationDate       :  Date of the expiration for this credential\n   *  - params.fields               :  Schema fields values for this credential\n   * @returns {Promise<IVerifiableCredential>} Result a credential document\n   */\n  generate(params) {\n    return __awaiter(this, void 0, void 0, function* () {\n      let schemaDoc = {};\n      if (params.subjectDid && params.subjectDidDocSigned) {\n        throw new Error('HID-SSI-SDK:: Error: Both subjectDid and subjectDidDoc cannot be passed');\n      }\n      if (!this.credStatusRPC) {\n        throw new Error('HID-SSI-SDK:: Error: HypersignVerifiableCredential class is not instantiated with Offlinesigner or have not been initilized');\n      }\n      const issuerDid = params.issuerDid;\n      const subjectDid = params.subjectDid;\n      let resolvedsubjectDidDoc;\n      const {\n        didDocument: issuerDidDoc\n      } = yield this.hsDid.resolve({\n        did: issuerDid\n      });\n      //\n      if (params.subjectDid) {\n        resolvedsubjectDidDoc = yield this.hsDid.resolve({\n          did: params.subjectDid\n        });\n      } else if (params.subjectDidDocSigned) {\n        resolvedsubjectDidDoc = {};\n        resolvedsubjectDidDoc.didDocument = params.subjectDidDocSigned;\n      } else {\n        throw new Error('HID-SSI-SDK:: Error: Could not resolve the subjectDid or subjectDidDoc');\n      }\n      const {\n        didDocument: subjectDidDoc\n      } = resolvedsubjectDidDoc;\n      if (!issuerDidDoc) {\n        throw new Error('HID-SSI-SDK:: Error: Could not fetch issuer did doc, issuer did = ' + issuerDid);\n      }\n      if (!subjectDidDoc) {\n        throw new Error('HID-SSI-SDK:: Error: Could not fetch subject did doc, subject did = ' + subjectDid);\n      }\n      if (params && params.schemaContext && params.type) {\n        try {\n          const context = Array();\n          context.push(constants_1.VC.CREDENTAIL_BASE_CONTEXT);\n          params.schemaContext.forEach(x => {\n            context.push(x);\n          });\n          const issuerDid = params.issuerDid;\n          const subjectDid = params.subjectDid;\n          const expirationDate = params.expirationDate;\n          const credentialSubject = params.fields;\n          const vc = {};\n          vc['@context'] = context;\n          vc.id = yield this._getId();\n          vc.type = [];\n          vc.type.push('VerifiableCredential');\n          params.type.forEach(x => {\n            vc.type.push(x);\n          });\n          vc.issuer = issuerDid;\n          vc.issuanceDate = this._dateNow(new Date(new Date().getTime() - 100000).toISOString());\n          vc.expirationDate = this._dateNow(expirationDate);\n          vc.credentialSubject = credentialSubject;\n          vc.credentialSubject['id'] = subjectDid && subjectDid != undefined ? subjectDid : subjectDidDoc.id;\n          // TODO: confusion here is, what would be the status of this credential at the time of its creation?\n          // If this properpty is present , then checkStatus() must be passed at the time of verification of the credential\n          // Ref: https://github.com/digitalbazaar/vc-js/blob/7e14ef27bc688194635077d243d9025c0020448b/test/10-verify.spec.js#L188\n          vc.credentialStatus = {\n            id: this.credStatusRPC.credentialRestEP + '/' + vc.id,\n            type: this.credentialStatus.type\n          };\n          return vc;\n        } catch (error) {\n          throw new Error('HID-SSI-SDK:: Error: Could not create credential, error = ' + error);\n        }\n      } else if (!params.schemaId) {\n        throw new Error('HID-SSI-SDK:: Error: schemaId is required when schemaContext and type not passed');\n      }\n      try {\n        schemaDoc = yield this.hsSchema.resolve({\n          schemaId: params.schemaId\n        });\n      } catch (e) {\n        throw new Error('HID-SSI-SDK:: Error: Could not resolve the schema from schemaId = ' + params.schemaId);\n      }\n      // TODO: do proper check for date and time\n      //if(params.expirationDate < new Date()) throw  new Error(\"Expiration date can not be lesser than current date\")\n      const vc = {};\n      const schemaInternal = schemaDoc.schema;\n      const schemaProperties = JSON.parse(schemaInternal.properties);\n      // context\n      vc['@context'] = this._getCredentialContext(params.schemaId, schemaProperties);\n      /// TODO:  need to implement this properly\n      vc.id = yield this._getId();\n      // Type\n      vc.type = [];\n      vc.type.push('VerifiableCredential');\n      vc.type.push(schemaDoc.name);\n      vc.expirationDate = this._dateNow(params.expirationDate);\n      vc.issuanceDate = this._dateNow(); // TODO: need to remove this.\n      vc.issuer = issuerDid;\n      vc.credentialSubject = {};\n      vc.credentialSubject = Object.assign({}, this._getCredentialSubject(schemaDoc.schema, params.fields));\n      vc.credentialSubject['id'] = subjectDid && subjectDid != undefined ? subjectDid : subjectDidDoc.id;\n      vc.credentialSchema = {\n        id: schemaDoc.id,\n        type: this.credentialSchema.type\n      };\n      // TODO: confusion here is, what would be the status of this credential at the time of its creation?\n      // If this properpty is present , then checkStatus() must be passed at the time of verification of the credential\n      // Ref: https://github.com/digitalbazaar/vc-js/blob/7e14ef27bc688194635077d243d9025c0020448b/test/10-verify.spec.js#L188\n      vc.credentialStatus = {\n        id: this.credStatusRPC.credentialRestEP + '/' + vc.id,\n        type: this.credentialStatus.type\n      };\n      return vc;\n    });\n  }\n  /**\n   * Generates signed credentials document and registers its status on Hypersign blockchain\n   * @params\n   *  - params.credential             : Hypersign credentail document\n   *  - params.privateKeyMultibase    : P\n   *  - params.issuerDid              : DID of the issuer\n   *  - params.verificationMethodId   : Verifcation Method of Issuer\n   * @returns {Promise<{\n   * signedCredential: IVerifiableCredential;\n   * credentialStatus: CredentialStatus;\n   * credentialStatusProof: CredentialProof;\n   * credentialStatusRegistrationResult?: DeliverTxResponse;\n   * }>}\n   */\n  issue(params) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!params.verificationMethodId) {\n        throw new Error('HID-SSI-SDK:: Error: params.verificationMethodId is required to issue credential');\n      }\n      if (!params.credential) {\n        throw new Error('HID-SSI-SDK:: Error: params.credential is required to issue credential');\n      }\n      if (!params.privateKeyMultibase) {\n        throw new Error('HID-SSI-SDK:: Error: params.privateKeyMultibase is required to issue credential');\n      }\n      if (!params.issuerDid) {\n        throw new Error('HID-SSI-SDK:: Error: params.issuerDid is required to issue credential');\n      }\n      if (!this.credStatusRPC) {\n        throw new Error('HID-SSI-SDK:: Error: HypersignVerifiableCredential class is not instantiated with Offlinesigner or have not been initilized');\n      }\n      if (params.registerCredential == undefined) {\n        params.registerCredential = true;\n      }\n      const {\n        didDocument: signerDidDoc\n      } = yield this.hsDid.resolve({\n        did: params.issuerDid\n      });\n      if (signerDidDoc === null || signerDidDoc === undefined) throw new Error('HID-SSI-SDK:: Error: Could not resolve issuerDid = ' + params.issuerDid);\n      // TODO: take verification method from params\n      const publicKeyId = params.verificationMethodId; // TODO: bad idea -  should not hardcode it.\n      const publicKeyVerMethod = signerDidDoc['verificationMethod'].find(x => x.id == publicKeyId);\n      if (!publicKeyVerMethod) {\n        throw new Error('HID-SSI-SDK:: Error: Could not find verification method for id = ' + params.verificationMethodId);\n      }\n      const convertedKeyPair = utils_1.default.convertedStableLibKeysIntoEd25519verificationkey2020({\n        publicKey: publicKeyVerMethod.publicKeyMultibase\n      });\n      publicKeyVerMethod['publicKeyMultibase'] = convertedKeyPair.publicKeyMultibase;\n      const keyPair = yield ed25519_verification_key_2020_1.Ed25519VerificationKey2020.from(Object.assign({\n        privateKeyMultibase: params.privateKeyMultibase\n      }, publicKeyVerMethod));\n      const suite = new ed25519_signature_2020_1.Ed25519Signature2020({\n        verificationMethod: publicKeyId,\n        key: keyPair\n      });\n      /// Before we issue the credential the credential status has to be added\n      /// for that we will call RegisterCredentialStatus RPC\n      //  Let us generate credentialHash first\n      const credentialHash = this._sha256Hash(JSON.stringify(params.credential));\n      const credentialStatus = {\n        claim: {\n          id: params.credential.id,\n          currentStatus: constants_1.VC.CRED_STATUS_TYPES.LIVE,\n          statusReason: 'Credential is active'\n        },\n        issuer: params.credential.issuer,\n        issuanceDate: params.credential.issuanceDate,\n        expirationDate: params.credential.expirationDate,\n        credentialHash\n      };\n      const proofValue = yield this._sign({\n        message: JSON.stringify(credentialStatus),\n        privateKeyMultibase: params.privateKeyMultibase\n      });\n      // check params.issuer is a controller of params.credential.issuer\n      const {\n        didDocument: issuerDID\n      } = yield this.hsDid.resolve({\n        did: params.credential.issuer\n      });\n      if (issuerDID === null || issuerDID === undefined) throw new Error('Could not resolve issuerDid = ' + params.credential.issuer);\n      const credIssuerDidDoc = issuerDID;\n      const credIssuerController = credIssuerDidDoc.controller;\n      if (!credIssuerController.includes(params.issuerDid)) {\n        throw new Error(params.issuerDid + ' is not a controller of ' + params.credential.issuer);\n      }\n      // const issuerDidDoc: Did = issuerDID as Did;\n      // const issuerPublicKeyId = params.verificationMethodId;\n      // const issuerPublicKeyVerMethod: VerificationMethod = issuerDidDoc.verificationMethod.find(\n      //   (x) => x.id == issuerPublicKeyId\n      // ) as VerificationMethod;\n      const issuerPublicKeyVerMethod = publicKeyVerMethod;\n      const proof = {\n        type: constants_1.VC.VERIFICATION_METHOD_TYPE,\n        created: this._dateNow(),\n        updated: this._dateNow(),\n        verificationMethod: issuerPublicKeyVerMethod.id,\n        proofValue,\n        proofPurpose: constants_1.VC.PROOF_PURPOSE\n      };\n      /// RegisterCRedeRPC\n      const signedVC = yield vc_js_1.default.issue({\n        credential: params.credential,\n        suite,\n        documentLoader\n      });\n      let credentialStatusRegistrationResult;\n      if (params.registerCredential) {\n        credentialStatusRegistrationResult = yield this.credStatusRPC.registerCredentialStatus(credentialStatus, proof);\n        if (!credentialStatusRegistrationResult || credentialStatusRegistrationResult.code != 0) {\n          throw new Error('HID-SSI-SDK:: Error while issuing the credential error = ' + credentialStatusRegistrationResult.rawLog);\n        }\n        return {\n          signedCredential: signedVC,\n          credentialStatus,\n          credentialStatusProof: proof,\n          credentialStatusRegistrationResult\n        };\n      }\n      return {\n        signedCredential: signedVC,\n        credentialStatus,\n        credentialStatusProof: proof\n      };\n    });\n  }\n  // Ref: https://github.com/digitalbazaar/vc-js/blob/44ca660f62ad3569f338eaaaecb11a7b09949bd2/lib/vc.js#L251\n  /**\n   * Verfies signed/issued credential\n   * @params\n   *  - params.credential             : Signed Hypersign credentail document of type IVerifiableCredential\n   *  - params.issuerDid              : DID of the issuer\n   *  - params.verificationMethodId   : Verifcation Method of Issuer\n   * @returns {Promise<object>}\n   */\n  verify(params) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!params.credential) {\n        throw new Error('HID-SSI-SDK:: params.credential is required to verify credential');\n      }\n      if (!params.credential.proof) {\n        throw new Error('HID-SSI-SDK:: params.credential.proof is required to verify credential');\n      }\n      if (!params.verificationMethodId) {\n        throw new Error('HID-SSI-SDK:: Error: params.verificationMethodId is required to verify credential');\n      }\n      if (!params.issuerDid) {\n        throw new Error('HID-SSI-SDK:: Error: params.issuerDid is required to verify credential');\n      }\n      const {\n        didDocument: issuerDID\n      } = yield this.hsDid.resolve({\n        did: params.issuerDid\n      });\n      const issuerDidDoc = issuerDID;\n      const publicKeyId = params.verificationMethodId;\n      const publicKeyVerMethod = issuerDidDoc.verificationMethod.find(x => x.id == publicKeyId);\n      // TODO: Get rid of this hack later.\n      // Convert 45 byte publick key into 48\n      const {\n        publicKeyMultibase\n      } = utils_1.default.convertedStableLibKeysIntoEd25519verificationkey2020({\n        publicKey: publicKeyVerMethod.publicKeyMultibase\n      });\n      publicKeyVerMethod.publicKeyMultibase = publicKeyMultibase;\n      const assertionController = {\n        '@context': constants_1.DID.CONTROLLER_CONTEXT,\n        id: issuerDidDoc.id,\n        assertionMethod: issuerDidDoc.assertionMethod\n      };\n      const keyPair = yield ed25519_verification_key_2020_1.Ed25519VerificationKey2020.from(Object.assign({\n        privateKeyMultibase: ''\n      }, publicKeyVerMethod));\n      const suite = new ed25519_signature_2020_1.Ed25519Signature2020({\n        verificationMethod: publicKeyId,\n        key: keyPair\n      });\n      /* eslint-disable */\n      const that = this;\n      /* eslint-enable */\n      const result = yield vc_js_1.default.verifyCredential({\n        credential: params.credential,\n        controller: assertionController,\n        suite,\n        documentLoader,\n        checkStatus: function (options) {\n          return __awaiter(this, void 0, void 0, function* () {\n            return yield that.checkCredentialStatus({\n              credentialId: options.credential.id\n            });\n          });\n        }\n      });\n      return result;\n    });\n  }\n  /**\n   * Resolves credential status from Hypersign Blokchain\n   * @params\n   *  - params.credentialId           : Verifiable credential id\n   * @returns {Promise<CredentialStatus>}\n   */\n  resolveCredentialStatus(params) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!params || !params.credentialId) throw new Error('HID-SSI-SDK:: Error: params.credentialId is required to resolve credential status');\n      const credentialStatus = yield this.credStatusRPC.resolveCredentialStatus(params.credentialId);\n      return credentialStatus;\n    });\n  }\n  /**\n   * Update credential status in blockchain Hypersign Blokchain\n   * @params\n   *  - params.credentialStatus           : Status of the credential of type CredentialStatus\n   *  - params.issuerDid                  : DID of the issuer\n   *  - params.verificationMethodId       : verificationMethodId\n   *  - params.privateKeyMultibase        : privateKey of the issuer\n   *  - params.status                     : Status LIVE/REVOKE/SUSPENDED\n   *  - params.statusReason               : Reason for the status change\n   * @returns {Promise<DeliverTxResponse>}\n   */\n  updateCredentialStatus(params) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!params.verificationMethodId) {\n        throw new Error('HID-SSI-SDK:: Error: params.verificationMethodId is required to update credential status');\n      }\n      if (!params.credentialStatus) {\n        throw new Error('HID-SSI-SDK:: Error: params.credentialStatus is required to update credential status');\n      }\n      if (!params.privateKeyMultibase) {\n        throw new Error('HID-SSI-SDK:: Error: params.privateKeyMultibase is required to update credential status');\n      }\n      if (!params.issuerDid) {\n        throw new Error('HID-SSI-SDK:: Error: params.issuerDid is required to update credential status');\n      }\n      if (!params.status) {\n        throw new Error('HID-SSI-SDK:: Error: params.status is required to update credential status');\n      }\n      if (!this.credStatusRPC) {\n        throw new Error('HID-SSI-SDK:: Error: HypersignVerifiableCredential class is not instantiated with Offlinesigner or have not been initilized');\n      }\n      const {\n        didDocument: signerDidDoc\n      } = yield this.hsDid.resolve({\n        did: params.issuerDid\n      });\n      if (!signerDidDoc) throw new Error('Could not resolve issuerDid = ' + params.issuerDid);\n      // TODO: take verification method from params\n      const publicKeyId = params.verificationMethodId; // TODO: bad idea -  should not hardcode it.\n      const publicKeyVerMethod = signerDidDoc['verificationMethod'].find(x => x.id == publicKeyId);\n      const convertedKeyPair = utils_1.default.convertedStableLibKeysIntoEd25519verificationkey2020({\n        publicKey: publicKeyVerMethod.publicKeyMultibase\n      });\n      publicKeyVerMethod['publicKeyMultibase'] = convertedKeyPair.publicKeyMultibase;\n      const keyPair = yield ed25519_verification_key_2020_1.Ed25519VerificationKey2020.from(Object.assign({\n        privateKeyMultibase: params.privateKeyMultibase\n      }, publicKeyVerMethod));\n      const suite = new ed25519_signature_2020_1.Ed25519Signature2020({\n        verificationMethod: publicKeyId,\n        key: keyPair\n      });\n      /// Before we issue the credential the credential status has to be added\n      /// for that we will call RegisterCredentialStatus RPC\n      //  Let us generate credentialHash first\n      params.status = params.status.toUpperCase();\n      const claim = params.credentialStatus.claim;\n      const credentialStatus = {\n        claim: {\n          id: claim.id,\n          currentStatus: constants_1.VC.CRED_STATUS_TYPES[params.status],\n          statusReason: params.statusReason ? params.statusReason : constants_1.VC.CRED_STATUS_REASON_TYPES[params.status]\n        },\n        issuer: params.credentialStatus.issuer,\n        issuanceDate: params.credentialStatus.issuanceDate,\n        expirationDate: params.credentialStatus.expirationDate,\n        credentialHash: params.credentialStatus.credentialHash\n      };\n      const proofValue = yield this._sign({\n        message: JSON.stringify(credentialStatus),\n        privateKeyMultibase: params.privateKeyMultibase\n      });\n      const {\n        didDocument: issuerDID\n      } = yield this.hsDid.resolve({\n        did: params.credentialStatus.issuer\n      });\n      const issuerDidDoc = issuerDID;\n      const issuerDidDocController = issuerDidDoc.controller;\n      const verificationMethodController = params.verificationMethodId.split('#')[0];\n      if (!issuerDidDocController.includes(verificationMethodController)) {\n        throw new Error('HID-SSI-SDK:: Error: params.verificationMethodId does not belong to issuerDid');\n      }\n      const {\n        didDocument: controllerDidDoc\n      } = yield this.hsDid.resolve({\n        did: verificationMethodController\n      });\n      if (!controllerDidDoc) throw new Error('HID-SSI-SDK:: Error: params.verificationMethodId does not belong to issuerDid');\n      const didDocofController = controllerDidDoc;\n      const issuerPublicKeyId = params.verificationMethodId;\n      const issuerPublicKeyVerMethod = didDocofController.verificationMethod.find(x => x.id == issuerPublicKeyId);\n      const proof = {\n        type: constants_1.VC.VERIFICATION_METHOD_TYPE,\n        created: params.credentialStatus.issuanceDate,\n        updated: this._dateNow(),\n        verificationMethod: issuerPublicKeyVerMethod.id,\n        proofValue,\n        proofPurpose: constants_1.VC.PROOF_PURPOSE\n      };\n      /// RegisterCRedeRPC\n      // We use the same RPC (i.e. MsgRegisterCredentialStatus) for register and update of credential status on blockchain\n      const resp = yield this.credStatusRPC.registerCredentialStatus(credentialStatus, proof);\n      if (!resp || resp.code != 0) {\n        throw new Error('HID-SSI-SDK:: Error while revoking the credential error = ' + resp.rawLog);\n      }\n      return resp;\n    });\n  }\n  checkCredentialStatus(params) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!params || !params.credentialId) throw new Error('HID-SSI-SDK:: Error: params.credentialId is required to resolve credential status');\n      const {\n        credentialId\n      } = params;\n      const credentialStatus = yield this.credStatusRPC.resolveCredentialStatus(credentialId);\n      if (!credentialStatus) {\n        throw new Error('HID-SSI-SDK:: Error: while checking credential status of credentialID ' + credentialId);\n      }\n      const claim = credentialStatus.claim;\n      const {\n        currentStatus,\n        statusReason\n      } = claim;\n      /// TODO:  probably we should also verify the credential HASH by recalculating the hash of the crdential and\n      // matching with credentialHash property.\n      // const { credentialHash } = credentialStatus;\n      if (currentStatus != constants_1.VC.CRED_STATUS_TYPES.LIVE) {\n        console.log('WARN: Credential status is  not LIVE, currentStatus ' + currentStatus);\n        console.log('WARN: Status reason is ' + statusReason);\n        return {\n          verified: false\n        };\n      }\n      return {\n        verified: true\n      };\n    });\n  }\n  registerCredentialStatus(params) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const {\n        credentialStatus,\n        credentialStatusProof\n      } = params;\n      if (!credentialStatus || !credentialStatusProof) throw new Error('HID-SSI-SDK:: Error: credentialStatus and credentialStatusProof are required to register credential status');\n      if (!this.credStatusRPC) {\n        throw new Error('HID-SSI-SDK:: Error: HypersignVerifiableCredential class is not instantiated with Offlinesigner or have not been initilized');\n      }\n      const resp = yield this.credStatusRPC.registerCredentialStatus(credentialStatus, credentialStatusProof);\n      if (!resp || resp.code != 0) {\n        throw new Error('HID-SSI-SDK:: Error while issuing the credential error = ' + resp.rawLog);\n      }\n      return resp;\n    });\n  }\n  generateRegisterCredentialStatusTxnMessage(credentialStatus, proof) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!credentialStatus || !proof) throw new Error('HID-SSI-SDK:: Error: credentialStatus and proof are required to register credential status');\n      if (!this.credStatusRPC) {\n        throw new Error('HID-SSI-SDK:: Error: HypersignVerifiableCredential class is not instantiated with Offlinesigner or have not been initilized');\n      }\n      const txnMessage = yield this.credStatusRPC.generateCredentialStatusTxnMessage(credentialStatus, proof);\n      return txnMessage;\n    });\n  }\n  registerCredentialStatusTxnBulk(txnMessage) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!txnMessage) throw new Error('HID-SSI-SDK:: Error: txnMessage is required to register credential status');\n      if (!this.credStatusRPC) {\n        throw new Error('HID-SSI-SDK:: Error: HypersignVerifiableCredential class is not instantiated with Offlinesigner or have not been initilized');\n      }\n      const resp = yield this.credStatusRPC.registerCredentialStatusBulk(txnMessage);\n      if (!resp || resp.code != 0) {\n        throw new Error('HID-SSI-SDK:: Error while issuing the credential error = ' + resp.rawLog);\n      }\n      return resp;\n    });\n  }\n  /**\n   * Issue credentials document with EthereumEip712Signature2021\n      */\n  issueByClientSpec(params) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!params.verificationMethodId) {\n        throw new Error('HID-SSI-SDK:: Error: params.verificationMethodId is required to issue credential');\n      }\n      if (!params.issuerDid) {\n        throw new Error('HID-SSI-SDK:: Error: params.issuerDid is required to issue credential');\n      }\n      if (!params.credential) {\n        throw new Error('HID-SSI-SDK:: Error: params.credential is required to issue credential');\n      }\n      if (!this.credStatusRPC) {\n        throw new Error('HID-SSI-SDK:: Error: HypersignVerifiableCredential class is not instantiated with Offlinesigner or have not been initilized');\n      }\n      if (!params.web3Obj) {\n        throw new Error('HID-SSI-SDK:: Error: prams.web3Obj should be passed');\n      }\n      if (params.type == undefined) {\n        params.type = 'Document';\n      }\n      if (params.registerCredential == undefined) {\n        params.registerCredential = true;\n      }\n      const {\n        didDocument: signerDidDoc\n      } = yield this.hsDid.resolve({\n        did: params.issuerDid\n      });\n      if (signerDidDoc === null || signerDidDoc === undefined) throw new Error('HID-SSI-SDK:: Error: Could not resolve issuerDid = ' + params.issuerDid);\n      const publicKeyId = params.verificationMethodId;\n      const publicKeyVerMethod = signerDidDoc['verificationMethod'].find(x => x.id == publicKeyId);\n      if (!publicKeyVerMethod) {\n        throw new Error('HID-SSI-SDK:: Error: Could not find verification method for id = ' + params.verificationMethodId);\n      }\n      const EthereumEip712Signature2021obj = new ethereumeip712signature2021suite_1.EthereumEip712Signature2021({}, params.web3Obj);\n      const proof = yield EthereumEip712Signature2021obj.createProof({\n        document: params.credential,\n        purpose: new jsonld_signatures_1.purposes.AssertionProofPurpose(),\n        verificationMethod: params.verificationMethodId,\n        primaryType: params.type,\n        date: new Date().toISOString(),\n        domain: params.domain ? {\n          name: params.domain\n        } : undefined,\n        documentLoader\n      });\n      params.credential.proof = proof;\n      const signedVC = params.credential;\n      const {\n        didDocument: issuerDID\n      } = yield this.hsDid.resolve({\n        did: params.credential.issuer\n      });\n      if (issuerDID === null || issuerDID === undefined) throw new Error('Could not resolve issuerDid = ' + params.credential.issuer);\n      const credIssuerDidDoc = issuerDID;\n      const credIssuerController = credIssuerDidDoc.controller;\n      if (!credIssuerController.includes(params.issuerDid)) {\n        throw new Error(params.issuerDid + ' is not a controller of ' + params.credential.issuer);\n      }\n      if (params.registerCredential) {\n        // register credential status\n        return new Error('HID-SSI-SDK:: Error: registerCredential is not implemented');\n      }\n      return {\n        signedCredential: signedVC\n      };\n    });\n  }\n  // verify credentila issued by client spec\n  verifyByClientSpec(params) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!params.credential) {\n        throw new Error('HID-SSI-SDK:: params.credential is required to verify credential');\n      }\n      if (!params.credential.proof) {\n        throw new Error('HID-SSI-SDK:: params.credential.proof is required to verify credential');\n      }\n      if (!params.verificationMethodId) {\n        throw new Error('HID-SSI-SDK:: Error: params.verificationMethodId is required to verify credential');\n      }\n      if (!params.issuerDid) {\n        throw new Error('HID-SSI-SDK:: Error: params.issuerDid is required to verify credential');\n      }\n      if (!params.web3Obj) {\n        throw new Error('HID-SSI-SDK:: Error: prams.web3Obj should be passed');\n      }\n      const {\n        didDocument\n      } = yield this.hsDid.resolve({\n        did: params.issuerDid\n      });\n      if (didDocument === null || didDocument === undefined) throw new Error('HID-SSI-SDK:: Error: Could not resolve issuerDid = ' + params.issuerDid);\n      const EthereumEip712Signature2021obj = new ethereumeip712signature2021suite_1.EthereumEip712Signature2021({}, params.web3Obj);\n      const {\n        proof\n      } = params.credential;\n      const verificationResult = yield EthereumEip712Signature2021obj.verifyProof({\n        proof: proof,\n        document: params.credential,\n        types: proof.eip712.types,\n        domain: proof.eip712.domain,\n        purpose: new jsonld_signatures_1.purposes.AssertionProofPurpose(),\n        documentLoader\n      });\n      return verificationResult;\n    });\n  }\n}\nexports.default = HypersignVerifiableCredential;","map":{"version":3,"names":["require","__awaiter","thisArg","_arguments","P","generator","adopt","value","resolve","Promise","reject","fulfilled","step","next","e","rejected","result","done","then","apply","__importDefault","mod","__esModule","Object","defineProperty","exports","jsonld_signatures_1","vc_js_1","utils_1","schema_1","did_1","ed25519_verification_key_2020_1","ed25519_signature_2020_1","ed25519","credRPC_1","constants_1","credential_1","crypto_1","v1_1","ethereumeip712signature2021suite_1","jsonld_signatures_2","documentLoader","extendContextLoader","default","HypersignVerifiableCredential","constructor","params","_checkIfAllRequiredPropsAreSent","sentAttributes","requiredProps","some","x","indexOf","_getCredentialSubject","schemaProperty","attributesMap","cs","sentPropes","keys","properties","JSON","parse","SchemaProps","props","additionalProperties","length","Error","stringify","requiredPros","values","required","forEach","p","_getCredentialContext","schemaId","schemaProperties","context","schemaUrl","hsSchema","schemaRpc","schemaRestEp","push","VC","CREDENTAIL_BASE_CONTEXT","hs","obj","namespace","offlineSigner","nodeRpcEndpoint","nodeRestEndpoint","nodeRPCEp","nodeRestEp","offlineConstuctorParams","credStatusRPC","CredentialRPC","hsDid","id","type","issuer","issuanceDate","expirationDate","credentialSubject","credentialSchema","CREDENTAIL_SCHEMA_VALIDATOR_TYPE","credentialStatus","CREDENTAIL_STATUS_TYPE","proof","_sign","privateKeyMultibase","privateKeyMultibaseConverted","convertEd25519verificationkey2020toStableLibKeysInto","privKey","message","credentialBytes","CredentialStatus","encode","finish","signed","sign","Buffer","from","toString","_dateNow","date","Date","toISOString","slice","getTime","_sha256Hash","sha256","createHash","update","digest","_getId","uuid","getUUID","SCHEME","METHOD","init","generate","schemaDoc","subjectDid","subjectDidDocSigned","issuerDid","resolvedsubjectDidDoc","didDocument","issuerDidDoc","did","subjectDidDoc","schemaContext","Array","fields","vc","undefined","credentialRestEP","error","schemaInternal","schema","name","assign","issue","verificationMethodId","credential","registerCredential","signerDidDoc","publicKeyId","publicKeyVerMethod","find","convertedKeyPair","convertedStableLibKeysIntoEd25519verificationkey2020","publicKey","publicKeyMultibase","keyPair","Ed25519VerificationKey2020","suite","Ed25519Signature2020","verificationMethod","key","credentialHash","claim","currentStatus","CRED_STATUS_TYPES","LIVE","statusReason","proofValue","issuerDID","credIssuerDidDoc","credIssuerController","controller","includes","issuerPublicKeyVerMethod","VERIFICATION_METHOD_TYPE","created","updated","proofPurpose","PROOF_PURPOSE","signedVC","credentialStatusRegistrationResult","registerCredentialStatus","code","rawLog","signedCredential","credentialStatusProof","verify","assertionController","DID","CONTROLLER_CONTEXT","assertionMethod","that","verifyCredential","checkStatus","options","checkCredentialStatus","credentialId","resolveCredentialStatus","updateCredentialStatus","status","toUpperCase","CRED_STATUS_REASON_TYPES","issuerDidDocController","verificationMethodController","split","controllerDidDoc","didDocofController","issuerPublicKeyId","resp","console","log","verified","generateRegisterCredentialStatusTxnMessage","txnMessage","generateCredentialStatusTxnMessage","registerCredentialStatusTxnBulk","registerCredentialStatusBulk","issueByClientSpec","web3Obj","EthereumEip712Signature2021obj","EthereumEip712Signature2021","createProof","document","purpose","purposes","AssertionProofPurpose","primaryType","domain","verifyByClientSpec","verificationResult","verifyProof","types","eip712"],"sources":["/home/pratap/hid-ssi-js-sdk/build/src/credential/vc.js"],"sourcesContent":["\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Copyright (c) 2023, Hypermine Pvt. Ltd.\n * All rights reserved.\n * Author: Hypermine Core Team\n */\nconst jsonld_signatures_1 = require(\"jsonld-signatures\");\nconst vc_js_1 = __importDefault(require(\"vc-js\"));\nconst utils_1 = __importDefault(require(\"../utils\"));\nconst schema_1 = __importDefault(require(\"../schema/schema\"));\nconst did_1 = __importDefault(require(\"../did/did\"));\nconst ed25519_verification_key_2020_1 = require(\"@digitalbazaar/ed25519-verification-key-2020\");\nconst ed25519_signature_2020_1 = require(\"@digitalbazaar/ed25519-signature-2020\");\nconst ed25519 = require('@stablelib/ed25519');\nconst credRPC_1 = require(\"./credRPC\");\nconst constants_1 = require(\"../constants\");\nconst credential_1 = require(\"../../libs/generated/ssi/credential\");\nconst crypto_1 = __importDefault(require(\"crypto\"));\nconst v1_1 = __importDefault(require(\"../../libs/w3cache/v1\"));\nconst ethereumeip712signature2021suite_1 = require(\"ethereumeip712signature2021suite\");\nconst jsonld_signatures_2 = require(\"jsonld-signatures\");\nconst documentLoader = (0, jsonld_signatures_2.extendContextLoader)(v1_1.default);\nclass HypersignVerifiableCredential {\n    constructor(params = {}) {\n        this._checkIfAllRequiredPropsAreSent = (sentAttributes, requiredProps) => {\n            return !requiredProps.some((x) => sentAttributes.indexOf(x) === -1);\n        };\n        this._getCredentialSubject = (schemaProperty, attributesMap) => {\n            const cs = {};\n            const sentPropes = Object.keys(attributesMap);\n            if (schemaProperty.properties) {\n                schemaProperty['propertiesParsed'] = JSON.parse(schemaProperty.properties);\n            }\n            const SchemaProps = Object.keys(schemaProperty['propertiesParsed']);\n            let props = [];\n            // Check for \"additionalProperties\" in schemaProperty\n            if (!schemaProperty.additionalProperties) {\n                if (sentPropes.length > SchemaProps.length || !this._checkIfAllRequiredPropsAreSent(SchemaProps, sentPropes))\n                    throw new Error(`Only ${JSON.stringify(SchemaProps)} attributes are possible. additionalProperties is false in the schema`);\n                props = SchemaProps;\n            }\n            else {\n                props = sentPropes;\n            }\n            // Check all required propes\n            const requiredPros = Object.values(schemaProperty.required);\n            if (!this._checkIfAllRequiredPropsAreSent(sentPropes, requiredPros))\n                throw new Error(`${JSON.stringify(requiredPros)} are required properties`);\n            // Attach the values of props\n            props.forEach((p) => {\n                cs[p] = attributesMap[p];\n            });\n            return cs;\n        };\n        //\n        // TODO: https://www.w3.org/TR/vc-data-model/#data-schemas\n        // TODO: handle schemaUrl variable properly later.\n        this._getCredentialContext = (schemaId, schemaProperties) => {\n            const context = [];\n            let schemaUrl;\n            if (this.hsSchema && this.hsSchema.schemaRpc) {\n                schemaUrl = `${this.hsSchema.schemaRpc.schemaRestEp}/${schemaId}:`;\n            }\n            else {\n                throw new Error('Error: HypersigSchema object may not be initialized');\n            }\n            context.push(constants_1.VC.CREDENTAIL_BASE_CONTEXT);\n            //context.push(VC.CREDENTAIL_SECURITY_SUITE);\n            context.push({\n                hs: schemaUrl,\n            });\n            const props = Object.keys(schemaProperties);\n            props.forEach((x) => {\n                const obj = {};\n                obj[x] = `hs:${x}`;\n                context.push(obj);\n            });\n            return context;\n        };\n        const { namespace, offlineSigner, nodeRpcEndpoint, nodeRestEndpoint } = params;\n        this.namespace = namespace && namespace != '' ? namespace : '';\n        const nodeRPCEp = nodeRpcEndpoint ? nodeRpcEndpoint : 'MAIN';\n        const nodeRestEp = nodeRestEndpoint ? nodeRestEndpoint : '';\n        const offlineConstuctorParams = { offlineSigner, nodeRpcEndpoint: nodeRPCEp, nodeRestEndpoint: nodeRestEp };\n        this.credStatusRPC = new credRPC_1.CredentialRPC(offlineConstuctorParams);\n        this.hsDid = new did_1.default(offlineConstuctorParams);\n        this.hsSchema = new schema_1.default(offlineConstuctorParams);\n        this.context = [];\n        this.id = '';\n        this.type = [];\n        this.issuer = '';\n        this.issuanceDate = '';\n        this.expirationDate = '';\n        this.credentialSubject = {};\n        this.credentialSchema = {\n            id: '',\n            type: constants_1.VC.CREDENTAIL_SCHEMA_VALIDATOR_TYPE,\n        };\n        this.credentialStatus = {\n            id: '',\n            type: constants_1.VC.CREDENTAIL_STATUS_TYPE,\n        };\n        this.proof = {};\n    }\n    _sign(params) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const { privateKeyMultibase: privateKeyMultibaseConverted } = utils_1.default.convertEd25519verificationkey2020toStableLibKeysInto({\n                privKey: params.privateKeyMultibase,\n            });\n            // TODO:  do proper checck of paramaters\n            const credentialStatus = JSON.parse(params.message);\n            const credentialBytes = (yield credential_1.CredentialStatus.encode(credentialStatus)).finish();\n            // const messageBytes = Buffer.from(params.message);\n            const signed = ed25519.sign(privateKeyMultibaseConverted, credentialBytes);\n            return Buffer.from(signed).toString('base64');\n        });\n    }\n    _dateNow(date) {\n        if (date) {\n            return new Date(date).toISOString().slice(0, -5) + 'Z';\n        }\n        else {\n            return new Date(new Date().getTime() - 100000).toISOString().slice(0, -5) + 'Z';\n        }\n    }\n    _sha256Hash(message) {\n        const sha256 = crypto_1.default.createHash('sha256');\n        return sha256.update(message).digest('hex');\n    }\n    _getId() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const uuid = yield utils_1.default.getUUID();\n            let id;\n            if (this.namespace && this.namespace != '') {\n                id = `${constants_1.VC.SCHEME}:${constants_1.VC.METHOD}:${this.namespace}:${uuid}`;\n            }\n            else {\n                id = `${constants_1.VC.SCHEME}:${constants_1.VC.METHOD}:${uuid}`;\n            }\n            return id;\n        });\n    }\n    /**\n     * Initialise the offlinesigner to interact with Hypersign blockchain\n     */\n    init() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!this.credStatusRPC) {\n                throw new Error('HID-SSI-SDK:: Error: HypersignVerifiableCredential class is not instantiated with Offlinesigner or have not been initilized');\n            }\n            yield this.credStatusRPC.init();\n        });\n    }\n    /**\n     * Generates a new credential document\n     * @params\n     *  - params.schemaId             : Hypersign schema id\n     *  - params.subjectDid           : DID of the subject, if not provided, will be taken from subjectDidDocSigned\n     *  - params.schemaContext        :\n     *  - params.type                 :\n     *  - params.issuerDid            :  DID of the issuer\n     *  - params.expirationDate       :  Date of the expiration for this credential\n     *  - params.fields               :  Schema fields values for this credential\n     * @returns {Promise<IVerifiableCredential>} Result a credential document\n     */\n    generate(params) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let schemaDoc = {};\n            if (params.subjectDid && params.subjectDidDocSigned) {\n                throw new Error('HID-SSI-SDK:: Error: Both subjectDid and subjectDidDoc cannot be passed');\n            }\n            if (!this.credStatusRPC) {\n                throw new Error('HID-SSI-SDK:: Error: HypersignVerifiableCredential class is not instantiated with Offlinesigner or have not been initilized');\n            }\n            const issuerDid = params.issuerDid;\n            const subjectDid = params.subjectDid;\n            let resolvedsubjectDidDoc;\n            const { didDocument: issuerDidDoc } = yield this.hsDid.resolve({ did: issuerDid });\n            //\n            if (params.subjectDid) {\n                resolvedsubjectDidDoc = yield this.hsDid.resolve({ did: params.subjectDid });\n            }\n            else if (params.subjectDidDocSigned) {\n                resolvedsubjectDidDoc = {};\n                resolvedsubjectDidDoc.didDocument = params.subjectDidDocSigned;\n            }\n            else {\n                throw new Error('HID-SSI-SDK:: Error: Could not resolve the subjectDid or subjectDidDoc');\n            }\n            const { didDocument: subjectDidDoc } = resolvedsubjectDidDoc;\n            if (!issuerDidDoc) {\n                throw new Error('HID-SSI-SDK:: Error: Could not fetch issuer did doc, issuer did = ' + issuerDid);\n            }\n            if (!subjectDidDoc) {\n                throw new Error('HID-SSI-SDK:: Error: Could not fetch subject did doc, subject did = ' + subjectDid);\n            }\n            if (params && params.schemaContext && params.type) {\n                try {\n                    const context = Array();\n                    context.push(constants_1.VC.CREDENTAIL_BASE_CONTEXT);\n                    params.schemaContext.forEach((x) => {\n                        context.push(x);\n                    });\n                    const issuerDid = params.issuerDid;\n                    const subjectDid = params.subjectDid;\n                    const expirationDate = params.expirationDate;\n                    const credentialSubject = params.fields;\n                    const vc = {};\n                    vc['@context'] = context;\n                    vc.id = yield this._getId();\n                    vc.type = [];\n                    vc.type.push('VerifiableCredential');\n                    params.type.forEach((x) => {\n                        vc.type.push(x);\n                    });\n                    vc.issuer = issuerDid;\n                    vc.issuanceDate = this._dateNow(new Date(new Date().getTime() - 100000).toISOString());\n                    vc.expirationDate = this._dateNow(expirationDate);\n                    vc.credentialSubject = credentialSubject;\n                    vc.credentialSubject['id'] = subjectDid && subjectDid != undefined ? subjectDid : subjectDidDoc.id;\n                    // TODO: confusion here is, what would be the status of this credential at the time of its creation?\n                    // If this properpty is present , then checkStatus() must be passed at the time of verification of the credential\n                    // Ref: https://github.com/digitalbazaar/vc-js/blob/7e14ef27bc688194635077d243d9025c0020448b/test/10-verify.spec.js#L188\n                    vc.credentialStatus = {\n                        id: this.credStatusRPC.credentialRestEP + '/' + vc.id,\n                        type: this.credentialStatus.type,\n                    };\n                    return vc;\n                }\n                catch (error) {\n                    throw new Error('HID-SSI-SDK:: Error: Could not create credential, error = ' + error);\n                }\n            }\n            else if (!params.schemaId) {\n                throw new Error('HID-SSI-SDK:: Error: schemaId is required when schemaContext and type not passed');\n            }\n            try {\n                schemaDoc = yield this.hsSchema.resolve({ schemaId: params.schemaId });\n            }\n            catch (e) {\n                throw new Error('HID-SSI-SDK:: Error: Could not resolve the schema from schemaId = ' + params.schemaId);\n            }\n            // TODO: do proper check for date and time\n            //if(params.expirationDate < new Date()) throw  new Error(\"Expiration date can not be lesser than current date\")\n            const vc = {};\n            const schemaInternal = schemaDoc.schema;\n            const schemaProperties = JSON.parse(schemaInternal.properties);\n            // context\n            vc['@context'] = this._getCredentialContext(params.schemaId, schemaProperties);\n            /// TODO:  need to implement this properly\n            vc.id = yield this._getId();\n            // Type\n            vc.type = [];\n            vc.type.push('VerifiableCredential');\n            vc.type.push(schemaDoc.name);\n            vc.expirationDate = this._dateNow(params.expirationDate);\n            vc.issuanceDate = this._dateNow(); // TODO: need to remove this.\n            vc.issuer = issuerDid;\n            vc.credentialSubject = {};\n            vc.credentialSubject = Object.assign({}, this._getCredentialSubject(schemaDoc.schema, params.fields));\n            vc.credentialSubject['id'] = subjectDid && subjectDid != undefined ? subjectDid : subjectDidDoc.id;\n            vc.credentialSchema = {\n                id: schemaDoc.id,\n                type: this.credentialSchema.type,\n            };\n            // TODO: confusion here is, what would be the status of this credential at the time of its creation?\n            // If this properpty is present , then checkStatus() must be passed at the time of verification of the credential\n            // Ref: https://github.com/digitalbazaar/vc-js/blob/7e14ef27bc688194635077d243d9025c0020448b/test/10-verify.spec.js#L188\n            vc.credentialStatus = {\n                id: this.credStatusRPC.credentialRestEP + '/' + vc.id,\n                type: this.credentialStatus.type,\n            };\n            return vc;\n        });\n    }\n    /**\n     * Generates signed credentials document and registers its status on Hypersign blockchain\n     * @params\n     *  - params.credential             : Hypersign credentail document\n     *  - params.privateKeyMultibase    : P\n     *  - params.issuerDid              : DID of the issuer\n     *  - params.verificationMethodId   : Verifcation Method of Issuer\n     * @returns {Promise<{\n     * signedCredential: IVerifiableCredential;\n     * credentialStatus: CredentialStatus;\n     * credentialStatusProof: CredentialProof;\n     * credentialStatusRegistrationResult?: DeliverTxResponse;\n     * }>}\n     */\n    issue(params) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!params.verificationMethodId) {\n                throw new Error('HID-SSI-SDK:: Error: params.verificationMethodId is required to issue credential');\n            }\n            if (!params.credential) {\n                throw new Error('HID-SSI-SDK:: Error: params.credential is required to issue credential');\n            }\n            if (!params.privateKeyMultibase) {\n                throw new Error('HID-SSI-SDK:: Error: params.privateKeyMultibase is required to issue credential');\n            }\n            if (!params.issuerDid) {\n                throw new Error('HID-SSI-SDK:: Error: params.issuerDid is required to issue credential');\n            }\n            if (!this.credStatusRPC) {\n                throw new Error('HID-SSI-SDK:: Error: HypersignVerifiableCredential class is not instantiated with Offlinesigner or have not been initilized');\n            }\n            if (params.registerCredential == undefined) {\n                params.registerCredential = true;\n            }\n            const { didDocument: signerDidDoc } = yield this.hsDid.resolve({ did: params.issuerDid });\n            if (signerDidDoc === null || signerDidDoc === undefined)\n                throw new Error('HID-SSI-SDK:: Error: Could not resolve issuerDid = ' + params.issuerDid);\n            // TODO: take verification method from params\n            const publicKeyId = params.verificationMethodId; // TODO: bad idea -  should not hardcode it.\n            const publicKeyVerMethod = signerDidDoc['verificationMethod'].find((x) => x.id == publicKeyId);\n            if (!publicKeyVerMethod) {\n                throw new Error('HID-SSI-SDK:: Error: Could not find verification method for id = ' + params.verificationMethodId);\n            }\n            const convertedKeyPair = utils_1.default.convertedStableLibKeysIntoEd25519verificationkey2020({\n                publicKey: publicKeyVerMethod.publicKeyMultibase,\n            });\n            publicKeyVerMethod['publicKeyMultibase'] = convertedKeyPair.publicKeyMultibase;\n            const keyPair = yield ed25519_verification_key_2020_1.Ed25519VerificationKey2020.from(Object.assign({ privateKeyMultibase: params.privateKeyMultibase }, publicKeyVerMethod));\n            const suite = new ed25519_signature_2020_1.Ed25519Signature2020({\n                verificationMethod: publicKeyId,\n                key: keyPair,\n            });\n            /// Before we issue the credential the credential status has to be added\n            /// for that we will call RegisterCredentialStatus RPC\n            //  Let us generate credentialHash first\n            const credentialHash = this._sha256Hash(JSON.stringify(params.credential));\n            const credentialStatus = {\n                claim: {\n                    id: params.credential.id,\n                    currentStatus: constants_1.VC.CRED_STATUS_TYPES.LIVE,\n                    statusReason: 'Credential is active',\n                },\n                issuer: params.credential.issuer,\n                issuanceDate: params.credential.issuanceDate,\n                expirationDate: params.credential.expirationDate,\n                credentialHash,\n            };\n            const proofValue = yield this._sign({\n                message: JSON.stringify(credentialStatus),\n                privateKeyMultibase: params.privateKeyMultibase,\n            });\n            // check params.issuer is a controller of params.credential.issuer\n            const { didDocument: issuerDID } = yield this.hsDid.resolve({ did: params.credential.issuer });\n            if (issuerDID === null || issuerDID === undefined)\n                throw new Error('Could not resolve issuerDid = ' + params.credential.issuer);\n            const credIssuerDidDoc = issuerDID;\n            const credIssuerController = credIssuerDidDoc.controller;\n            if (!credIssuerController.includes(params.issuerDid)) {\n                throw new Error(params.issuerDid + ' is not a controller of ' + params.credential.issuer);\n            }\n            // const issuerDidDoc: Did = issuerDID as Did;\n            // const issuerPublicKeyId = params.verificationMethodId;\n            // const issuerPublicKeyVerMethod: VerificationMethod = issuerDidDoc.verificationMethod.find(\n            //   (x) => x.id == issuerPublicKeyId\n            // ) as VerificationMethod;\n            const issuerPublicKeyVerMethod = publicKeyVerMethod;\n            const proof = {\n                type: constants_1.VC.VERIFICATION_METHOD_TYPE,\n                created: this._dateNow(),\n                updated: this._dateNow(),\n                verificationMethod: issuerPublicKeyVerMethod.id,\n                proofValue,\n                proofPurpose: constants_1.VC.PROOF_PURPOSE,\n            };\n            /// RegisterCRedeRPC\n            const signedVC = yield vc_js_1.default.issue({\n                credential: params.credential,\n                suite,\n                documentLoader,\n            });\n            let credentialStatusRegistrationResult;\n            if (params.registerCredential) {\n                credentialStatusRegistrationResult = yield this.credStatusRPC.registerCredentialStatus(credentialStatus, proof);\n                if (!credentialStatusRegistrationResult || credentialStatusRegistrationResult.code != 0) {\n                    throw new Error('HID-SSI-SDK:: Error while issuing the credential error = ' + credentialStatusRegistrationResult.rawLog);\n                }\n                return {\n                    signedCredential: signedVC,\n                    credentialStatus,\n                    credentialStatusProof: proof,\n                    credentialStatusRegistrationResult,\n                };\n            }\n            return { signedCredential: signedVC, credentialStatus, credentialStatusProof: proof };\n        });\n    }\n    // Ref: https://github.com/digitalbazaar/vc-js/blob/44ca660f62ad3569f338eaaaecb11a7b09949bd2/lib/vc.js#L251\n    /**\n     * Verfies signed/issued credential\n     * @params\n     *  - params.credential             : Signed Hypersign credentail document of type IVerifiableCredential\n     *  - params.issuerDid              : DID of the issuer\n     *  - params.verificationMethodId   : Verifcation Method of Issuer\n     * @returns {Promise<object>}\n     */\n    verify(params) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!params.credential) {\n                throw new Error('HID-SSI-SDK:: params.credential is required to verify credential');\n            }\n            if (!params.credential.proof) {\n                throw new Error('HID-SSI-SDK:: params.credential.proof is required to verify credential');\n            }\n            if (!params.verificationMethodId) {\n                throw new Error('HID-SSI-SDK:: Error: params.verificationMethodId is required to verify credential');\n            }\n            if (!params.issuerDid) {\n                throw new Error('HID-SSI-SDK:: Error: params.issuerDid is required to verify credential');\n            }\n            const { didDocument: issuerDID } = yield this.hsDid.resolve({ did: params.issuerDid });\n            const issuerDidDoc = issuerDID;\n            const publicKeyId = params.verificationMethodId;\n            const publicKeyVerMethod = issuerDidDoc.verificationMethod.find((x) => x.id == publicKeyId);\n            // TODO: Get rid of this hack later.\n            // Convert 45 byte publick key into 48\n            const { publicKeyMultibase } = utils_1.default.convertedStableLibKeysIntoEd25519verificationkey2020({\n                publicKey: publicKeyVerMethod.publicKeyMultibase,\n            });\n            publicKeyVerMethod.publicKeyMultibase = publicKeyMultibase;\n            const assertionController = {\n                '@context': constants_1.DID.CONTROLLER_CONTEXT,\n                id: issuerDidDoc.id,\n                assertionMethod: issuerDidDoc.assertionMethod,\n            };\n            const keyPair = yield ed25519_verification_key_2020_1.Ed25519VerificationKey2020.from(Object.assign({ privateKeyMultibase: '' }, publicKeyVerMethod));\n            const suite = new ed25519_signature_2020_1.Ed25519Signature2020({\n                verificationMethod: publicKeyId,\n                key: keyPair,\n            });\n            /* eslint-disable */\n            const that = this;\n            /* eslint-enable */\n            const result = yield vc_js_1.default.verifyCredential({\n                credential: params.credential,\n                controller: assertionController,\n                suite,\n                documentLoader,\n                checkStatus: function (options) {\n                    return __awaiter(this, void 0, void 0, function* () {\n                        return yield that.checkCredentialStatus({ credentialId: options.credential.id });\n                    });\n                },\n            });\n            return result;\n        });\n    }\n    /**\n     * Resolves credential status from Hypersign Blokchain\n     * @params\n     *  - params.credentialId           : Verifiable credential id\n     * @returns {Promise<CredentialStatus>}\n     */\n    resolveCredentialStatus(params) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!params || !params.credentialId)\n                throw new Error('HID-SSI-SDK:: Error: params.credentialId is required to resolve credential status');\n            const credentialStatus = yield this.credStatusRPC.resolveCredentialStatus(params.credentialId);\n            return credentialStatus;\n        });\n    }\n    /**\n     * Update credential status in blockchain Hypersign Blokchain\n     * @params\n     *  - params.credentialStatus           : Status of the credential of type CredentialStatus\n     *  - params.issuerDid                  : DID of the issuer\n     *  - params.verificationMethodId       : verificationMethodId\n     *  - params.privateKeyMultibase        : privateKey of the issuer\n     *  - params.status                     : Status LIVE/REVOKE/SUSPENDED\n     *  - params.statusReason               : Reason for the status change\n     * @returns {Promise<DeliverTxResponse>}\n     */\n    updateCredentialStatus(params) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!params.verificationMethodId) {\n                throw new Error('HID-SSI-SDK:: Error: params.verificationMethodId is required to update credential status');\n            }\n            if (!params.credentialStatus) {\n                throw new Error('HID-SSI-SDK:: Error: params.credentialStatus is required to update credential status');\n            }\n            if (!params.privateKeyMultibase) {\n                throw new Error('HID-SSI-SDK:: Error: params.privateKeyMultibase is required to update credential status');\n            }\n            if (!params.issuerDid) {\n                throw new Error('HID-SSI-SDK:: Error: params.issuerDid is required to update credential status');\n            }\n            if (!params.status) {\n                throw new Error('HID-SSI-SDK:: Error: params.status is required to update credential status');\n            }\n            if (!this.credStatusRPC) {\n                throw new Error('HID-SSI-SDK:: Error: HypersignVerifiableCredential class is not instantiated with Offlinesigner or have not been initilized');\n            }\n            const { didDocument: signerDidDoc } = yield this.hsDid.resolve({ did: params.issuerDid });\n            if (!signerDidDoc)\n                throw new Error('Could not resolve issuerDid = ' + params.issuerDid);\n            // TODO: take verification method from params\n            const publicKeyId = params.verificationMethodId; // TODO: bad idea -  should not hardcode it.\n            const publicKeyVerMethod = signerDidDoc['verificationMethod'].find((x) => x.id == publicKeyId);\n            const convertedKeyPair = utils_1.default.convertedStableLibKeysIntoEd25519verificationkey2020({\n                publicKey: publicKeyVerMethod.publicKeyMultibase,\n            });\n            publicKeyVerMethod['publicKeyMultibase'] = convertedKeyPair.publicKeyMultibase;\n            const keyPair = yield ed25519_verification_key_2020_1.Ed25519VerificationKey2020.from(Object.assign({ privateKeyMultibase: params.privateKeyMultibase }, publicKeyVerMethod));\n            const suite = new ed25519_signature_2020_1.Ed25519Signature2020({\n                verificationMethod: publicKeyId,\n                key: keyPair,\n            });\n            /// Before we issue the credential the credential status has to be added\n            /// for that we will call RegisterCredentialStatus RPC\n            //  Let us generate credentialHash first\n            params.status = params.status.toUpperCase();\n            const claim = params.credentialStatus.claim;\n            const credentialStatus = {\n                claim: {\n                    id: claim.id,\n                    currentStatus: constants_1.VC.CRED_STATUS_TYPES[params.status],\n                    statusReason: params.statusReason ? params.statusReason : constants_1.VC.CRED_STATUS_REASON_TYPES[params.status],\n                },\n                issuer: params.credentialStatus.issuer,\n                issuanceDate: params.credentialStatus.issuanceDate,\n                expirationDate: params.credentialStatus.expirationDate,\n                credentialHash: params.credentialStatus.credentialHash,\n            };\n            const proofValue = yield this._sign({\n                message: JSON.stringify(credentialStatus),\n                privateKeyMultibase: params.privateKeyMultibase,\n            });\n            const { didDocument: issuerDID } = yield this.hsDid.resolve({ did: params.credentialStatus.issuer });\n            const issuerDidDoc = issuerDID;\n            const issuerDidDocController = issuerDidDoc.controller;\n            const verificationMethodController = params.verificationMethodId.split('#')[0];\n            if (!issuerDidDocController.includes(verificationMethodController)) {\n                throw new Error('HID-SSI-SDK:: Error: params.verificationMethodId does not belong to issuerDid');\n            }\n            const { didDocument: controllerDidDoc } = yield this.hsDid.resolve({ did: verificationMethodController });\n            if (!controllerDidDoc)\n                throw new Error('HID-SSI-SDK:: Error: params.verificationMethodId does not belong to issuerDid');\n            const didDocofController = controllerDidDoc;\n            const issuerPublicKeyId = params.verificationMethodId;\n            const issuerPublicKeyVerMethod = didDocofController.verificationMethod.find((x) => x.id == issuerPublicKeyId);\n            const proof = {\n                type: constants_1.VC.VERIFICATION_METHOD_TYPE,\n                created: params.credentialStatus.issuanceDate,\n                updated: this._dateNow(),\n                verificationMethod: issuerPublicKeyVerMethod.id,\n                proofValue,\n                proofPurpose: constants_1.VC.PROOF_PURPOSE,\n            };\n            /// RegisterCRedeRPC\n            // We use the same RPC (i.e. MsgRegisterCredentialStatus) for register and update of credential status on blockchain\n            const resp = yield this.credStatusRPC.registerCredentialStatus(credentialStatus, proof);\n            if (!resp || resp.code != 0) {\n                throw new Error('HID-SSI-SDK:: Error while revoking the credential error = ' + resp.rawLog);\n            }\n            return resp;\n        });\n    }\n    checkCredentialStatus(params) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!params || !params.credentialId)\n                throw new Error('HID-SSI-SDK:: Error: params.credentialId is required to resolve credential status');\n            const { credentialId } = params;\n            const credentialStatus = yield this.credStatusRPC.resolveCredentialStatus(credentialId);\n            if (!credentialStatus) {\n                throw new Error('HID-SSI-SDK:: Error: while checking credential status of credentialID ' + credentialId);\n            }\n            const claim = credentialStatus.claim;\n            const { currentStatus, statusReason } = claim;\n            /// TODO:  probably we should also verify the credential HASH by recalculating the hash of the crdential and\n            // matching with credentialHash property.\n            // const { credentialHash } = credentialStatus;\n            if (currentStatus != constants_1.VC.CRED_STATUS_TYPES.LIVE) {\n                console.log('WARN: Credential status is  not LIVE, currentStatus ' + currentStatus);\n                console.log('WARN: Status reason is ' + statusReason);\n                return { verified: false };\n            }\n            return { verified: true };\n        });\n    }\n    registerCredentialStatus(params) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const { credentialStatus, credentialStatusProof } = params;\n            if (!credentialStatus || !credentialStatusProof)\n                throw new Error('HID-SSI-SDK:: Error: credentialStatus and credentialStatusProof are required to register credential status');\n            if (!this.credStatusRPC) {\n                throw new Error('HID-SSI-SDK:: Error: HypersignVerifiableCredential class is not instantiated with Offlinesigner or have not been initilized');\n            }\n            const resp = yield this.credStatusRPC.registerCredentialStatus(credentialStatus, credentialStatusProof);\n            if (!resp || resp.code != 0) {\n                throw new Error('HID-SSI-SDK:: Error while issuing the credential error = ' + resp.rawLog);\n            }\n            return resp;\n        });\n    }\n    generateRegisterCredentialStatusTxnMessage(credentialStatus, proof) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!credentialStatus || !proof)\n                throw new Error('HID-SSI-SDK:: Error: credentialStatus and proof are required to register credential status');\n            if (!this.credStatusRPC) {\n                throw new Error('HID-SSI-SDK:: Error: HypersignVerifiableCredential class is not instantiated with Offlinesigner or have not been initilized');\n            }\n            const txnMessage = yield this.credStatusRPC.generateCredentialStatusTxnMessage(credentialStatus, proof);\n            return txnMessage;\n        });\n    }\n    registerCredentialStatusTxnBulk(txnMessage) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!txnMessage)\n                throw new Error('HID-SSI-SDK:: Error: txnMessage is required to register credential status');\n            if (!this.credStatusRPC) {\n                throw new Error('HID-SSI-SDK:: Error: HypersignVerifiableCredential class is not instantiated with Offlinesigner or have not been initilized');\n            }\n            const resp = yield this.credStatusRPC.registerCredentialStatusBulk(txnMessage);\n            if (!resp || resp.code != 0) {\n                throw new Error('HID-SSI-SDK:: Error while issuing the credential error = ' + resp.rawLog);\n            }\n            return resp;\n        });\n    }\n    /**\n     * Issue credentials document with EthereumEip712Signature2021\n   \n    */\n    issueByClientSpec(params) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!params.verificationMethodId) {\n                throw new Error('HID-SSI-SDK:: Error: params.verificationMethodId is required to issue credential');\n            }\n            if (!params.issuerDid) {\n                throw new Error('HID-SSI-SDK:: Error: params.issuerDid is required to issue credential');\n            }\n            if (!params.credential) {\n                throw new Error('HID-SSI-SDK:: Error: params.credential is required to issue credential');\n            }\n            if (!this.credStatusRPC) {\n                throw new Error('HID-SSI-SDK:: Error: HypersignVerifiableCredential class is not instantiated with Offlinesigner or have not been initilized');\n            }\n            if (!params.web3Obj) {\n                throw new Error('HID-SSI-SDK:: Error: prams.web3Obj should be passed');\n            }\n            if (params.type == undefined) {\n                params.type = 'Document';\n            }\n            if (params.registerCredential == undefined) {\n                params.registerCredential = true;\n            }\n            const { didDocument: signerDidDoc } = yield this.hsDid.resolve({ did: params.issuerDid });\n            if (signerDidDoc === null || signerDidDoc === undefined)\n                throw new Error('HID-SSI-SDK:: Error: Could not resolve issuerDid = ' + params.issuerDid);\n            const publicKeyId = params.verificationMethodId;\n            const publicKeyVerMethod = signerDidDoc['verificationMethod'].find((x) => x.id == publicKeyId);\n            if (!publicKeyVerMethod) {\n                throw new Error('HID-SSI-SDK:: Error: Could not find verification method for id = ' + params.verificationMethodId);\n            }\n            const EthereumEip712Signature2021obj = new ethereumeip712signature2021suite_1.EthereumEip712Signature2021({}, params.web3Obj);\n            const proof = yield EthereumEip712Signature2021obj.createProof({\n                document: params.credential,\n                purpose: new jsonld_signatures_1.purposes.AssertionProofPurpose(),\n                verificationMethod: params.verificationMethodId,\n                primaryType: params.type,\n                date: new Date().toISOString(),\n                domain: params.domain ? { name: params.domain } : undefined,\n                documentLoader,\n            });\n            params.credential.proof = proof;\n            const signedVC = params.credential;\n            const { didDocument: issuerDID } = yield this.hsDid.resolve({ did: params.credential.issuer });\n            if (issuerDID === null || issuerDID === undefined)\n                throw new Error('Could not resolve issuerDid = ' + params.credential.issuer);\n            const credIssuerDidDoc = issuerDID;\n            const credIssuerController = credIssuerDidDoc.controller;\n            if (!credIssuerController.includes(params.issuerDid)) {\n                throw new Error(params.issuerDid + ' is not a controller of ' + params.credential.issuer);\n            }\n            if (params.registerCredential) {\n                // register credential status\n                return new Error('HID-SSI-SDK:: Error: registerCredential is not implemented');\n            }\n            return { signedCredential: signedVC };\n        });\n    }\n    // verify credentila issued by client spec\n    verifyByClientSpec(params) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!params.credential) {\n                throw new Error('HID-SSI-SDK:: params.credential is required to verify credential');\n            }\n            if (!params.credential.proof) {\n                throw new Error('HID-SSI-SDK:: params.credential.proof is required to verify credential');\n            }\n            if (!params.verificationMethodId) {\n                throw new Error('HID-SSI-SDK:: Error: params.verificationMethodId is required to verify credential');\n            }\n            if (!params.issuerDid) {\n                throw new Error('HID-SSI-SDK:: Error: params.issuerDid is required to verify credential');\n            }\n            if (!params.web3Obj) {\n                throw new Error('HID-SSI-SDK:: Error: prams.web3Obj should be passed');\n            }\n            const { didDocument } = yield this.hsDid.resolve({ did: params.issuerDid });\n            if (didDocument === null || didDocument === undefined)\n                throw new Error('HID-SSI-SDK:: Error: Could not resolve issuerDid = ' + params.issuerDid);\n            const EthereumEip712Signature2021obj = new ethereumeip712signature2021suite_1.EthereumEip712Signature2021({}, params.web3Obj);\n            const { proof } = params.credential;\n            const verificationResult = yield EthereumEip712Signature2021obj.verifyProof({\n                proof: proof,\n                document: params.credential,\n                types: proof.eip712.types,\n                domain: proof.eip712.domain,\n                purpose: new jsonld_signatures_1.purposes.AssertionProofPurpose(),\n                documentLoader,\n            });\n            return verificationResult;\n        });\n    }\n}\nexports.default = HypersignVerifiableCredential;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}