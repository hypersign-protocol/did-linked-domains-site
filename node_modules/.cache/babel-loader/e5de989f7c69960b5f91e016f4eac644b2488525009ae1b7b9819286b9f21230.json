{"ast":null,"code":"/*!\n * Copyright (c) 2018 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n\nconst constants = require('../constants');\nconst jsonld = require('jsonld');\nconst ProofPurpose = require('./ProofPurpose');\n\n// DID documents can be specially optimized\nconst DID_CONTEXT_V1 = 'https://www.w3.org/ns/did/v1';\n// verification relationship terms that are known to appear in DID documents\nconst DID_VR_TERMS = ['assertionMethod', 'authentication', 'capabilityInvocation', 'capabilityDelegation', 'keyAgreement', 'verificationMethod'];\nmodule.exports = class ControllerProofPurpose extends ProofPurpose {\n  /**\n   * Creates a proof purpose that will validate whether or not the verification\n   * method in a proof was authorized by its declared controller for the\n   * proof's purpose.\n   *\n   * @param term {string} the `proofPurpose` term, as defined in the\n   *    SECURITY_CONTEXT_URL `@context` or a URI if not defined in such.\n   * @param [controller] {object} the description of the controller, if it\n   *   is not to be dereferenced via a `documentLoader`.\n   * @param [date] {string or Date or integer} the expected date for\n   *   the creation of the proof.\n   * @param [maxTimestampDelta] {integer} a maximum number of seconds that\n   *   the date on the signature can deviate from, defaults to `Infinity`.\n   */\n  constructor({\n    term,\n    controller,\n    date,\n    maxTimestampDelta = Infinity\n  } = {}) {\n    super({\n      term,\n      date,\n      maxTimestampDelta\n    });\n    if (controller !== undefined) {\n      if (typeof controller !== 'object') {\n        throw new TypeError('\"controller\" must be an object.');\n      }\n      this.controller = controller;\n    }\n    this._termDefinedByDIDContext = DID_VR_TERMS.includes(term);\n  }\n\n  /**\n   * Validates the purpose of a proof. This method is called during\n   * proof verification, after the proof value has been checked against the\n   * given verification method (e.g. in the case of a digital signature, the\n   * signature has been cryptographically verified against the public key).\n   *\n   * @param proof\n   * @param verificationMethod\n   * @param documentLoader\n   * @param expansionMap\n   *\n   * @throws {Error} If verification method not authorized by controller\n   * @throws {Error} If proof's created timestamp is out of range\n   *\n   * @returns {Promise<{valid: boolean, error: Error}>}\n   */\n  async validate(proof, {\n    verificationMethod,\n    documentLoader,\n    expansionMap\n  }) {\n    try {\n      const result = await super.validate(proof, {\n        verificationMethod,\n        documentLoader,\n        expansionMap\n      });\n      if (!result.valid) {\n        throw result.error;\n      }\n      const {\n        id: verificationId\n      } = verificationMethod;\n      const {\n        term,\n        _termDefinedByDIDContext\n      } = this;\n\n      // if no `controller` specified, use verification method's\n      if (this.controller) {\n        result.controller = this.controller;\n      } else {\n        const {\n          controller\n        } = verificationMethod;\n        let controllerId;\n        if (controller) {\n          if (typeof controller === 'object') {\n            controllerId = controller.id;\n          } else if (typeof controller !== 'string') {\n            throw new TypeError('\"controller\" must be a string representing a URL.');\n          } else {\n            controllerId = controller;\n          }\n        }\n\n        // apply optimization to controller documents that are DID documents;\n        // if `term` is one of those defined by the DID context\n        let {\n          document\n        } = await documentLoader(controllerId);\n        const mustFrame = !(_termDefinedByDIDContext && document['@context'] === DID_CONTEXT_V1 || Array.isArray(document['@context']) && document['@context'][0] === DID_CONTEXT_V1);\n        if (mustFrame) {\n          // Note: `expansionMap` is intentionally not passed; we can safely\n          // drop properties here and must allow for it\n          document = await jsonld.frame(document, {\n            '@context': constants.SECURITY_CONTEXT_URL,\n            id: controllerId,\n            // this term must be in the JSON-LD controller document or\n            // verification will fail\n            [term]: {\n              '@embed': '@never',\n              id: verificationId\n            }\n          }, {\n            documentLoader,\n            compactToRelative: false\n          });\n        }\n        result.controller = document;\n      }\n      const verificationMethods = jsonld.getValues(result.controller, term);\n      result.valid = verificationMethods.some(vm => vm === verificationId || typeof vm === 'object' && vm.id === verificationId);\n      if (!result.valid) {\n        throw new Error(`Verification method \"${verificationMethod.id}\" not authorized ` + `by controller for proof purpose \"${this.term}\".`);\n      }\n      return result;\n    } catch (error) {\n      return {\n        valid: false,\n        error\n      };\n    }\n  }\n};","map":{"version":3,"names":["constants","require","jsonld","ProofPurpose","DID_CONTEXT_V1","DID_VR_TERMS","module","exports","ControllerProofPurpose","constructor","term","controller","date","maxTimestampDelta","Infinity","undefined","TypeError","_termDefinedByDIDContext","includes","validate","proof","verificationMethod","documentLoader","expansionMap","result","valid","error","id","verificationId","controllerId","document","mustFrame","Array","isArray","frame","SECURITY_CONTEXT_URL","compactToRelative","verificationMethods","getValues","some","vm","Error"],"sources":["/home/pratap/hid-ssi-js-sdk/node_modules/jsonld-signatures/lib/purposes/ControllerProofPurpose.js"],"sourcesContent":["/*!\n * Copyright (c) 2018 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n\nconst constants = require('../constants');\nconst jsonld = require('jsonld');\nconst ProofPurpose = require('./ProofPurpose');\n\n// DID documents can be specially optimized\nconst DID_CONTEXT_V1 = 'https://www.w3.org/ns/did/v1';\n// verification relationship terms that are known to appear in DID documents\nconst DID_VR_TERMS = [\n  'assertionMethod',\n  'authentication',\n  'capabilityInvocation',\n  'capabilityDelegation',\n  'keyAgreement',\n  'verificationMethod'\n];\n\nmodule.exports = class ControllerProofPurpose extends ProofPurpose {\n  /**\n   * Creates a proof purpose that will validate whether or not the verification\n   * method in a proof was authorized by its declared controller for the\n   * proof's purpose.\n   *\n   * @param term {string} the `proofPurpose` term, as defined in the\n   *    SECURITY_CONTEXT_URL `@context` or a URI if not defined in such.\n   * @param [controller] {object} the description of the controller, if it\n   *   is not to be dereferenced via a `documentLoader`.\n   * @param [date] {string or Date or integer} the expected date for\n   *   the creation of the proof.\n   * @param [maxTimestampDelta] {integer} a maximum number of seconds that\n   *   the date on the signature can deviate from, defaults to `Infinity`.\n   */\n  constructor({term, controller, date, maxTimestampDelta = Infinity} = {}) {\n    super({term, date, maxTimestampDelta});\n    if(controller !== undefined) {\n      if(typeof controller !== 'object') {\n        throw new TypeError('\"controller\" must be an object.');\n      }\n      this.controller = controller;\n    }\n    this._termDefinedByDIDContext = DID_VR_TERMS.includes(term);\n  }\n\n  /**\n   * Validates the purpose of a proof. This method is called during\n   * proof verification, after the proof value has been checked against the\n   * given verification method (e.g. in the case of a digital signature, the\n   * signature has been cryptographically verified against the public key).\n   *\n   * @param proof\n   * @param verificationMethod\n   * @param documentLoader\n   * @param expansionMap\n   *\n   * @throws {Error} If verification method not authorized by controller\n   * @throws {Error} If proof's created timestamp is out of range\n   *\n   * @returns {Promise<{valid: boolean, error: Error}>}\n   */\n  async validate(proof, {verificationMethod, documentLoader, expansionMap}) {\n    try {\n      const result = await super.validate(\n        proof, {verificationMethod, documentLoader, expansionMap});\n      if(!result.valid) {\n        throw result.error;\n      }\n\n      const {id: verificationId} = verificationMethod;\n      const {term, _termDefinedByDIDContext} = this;\n\n      // if no `controller` specified, use verification method's\n      if(this.controller) {\n        result.controller = this.controller;\n      } else {\n        const {controller} = verificationMethod;\n        let controllerId;\n        if(controller) {\n          if(typeof controller === 'object') {\n            controllerId = controller.id;\n          } else if(typeof controller !== 'string') {\n            throw new TypeError(\n              '\"controller\" must be a string representing a URL.');\n          } else {\n            controllerId = controller;\n          }\n        }\n\n        // apply optimization to controller documents that are DID documents;\n        // if `term` is one of those defined by the DID context\n        let {document} = await documentLoader(controllerId);\n        const mustFrame = !(_termDefinedByDIDContext &&\n          document['@context'] === DID_CONTEXT_V1 ||\n          (Array.isArray(document['@context']) &&\n          document['@context'][0] === DID_CONTEXT_V1));\n        if(mustFrame) {\n          // Note: `expansionMap` is intentionally not passed; we can safely\n          // drop properties here and must allow for it\n          document = await jsonld.frame(document, {\n            '@context': constants.SECURITY_CONTEXT_URL,\n            id: controllerId,\n            // this term must be in the JSON-LD controller document or\n            // verification will fail\n            [term]: {\n              '@embed': '@never',\n              id: verificationId\n            }\n          }, {documentLoader, compactToRelative: false});\n        }\n        result.controller = document;\n      }\n\n      const verificationMethods = jsonld.getValues(result.controller, term);\n      result.valid = verificationMethods.some(vm =>\n        vm === verificationId ||\n        (typeof vm === 'object' && vm.id === verificationId));\n      if(!result.valid) {\n        throw new Error(\n          `Verification method \"${verificationMethod.id}\" not authorized ` +\n          `by controller for proof purpose \"${this.term}\".`);\n      }\n      return result;\n    } catch(error) {\n      return {valid: false, error};\n    }\n  }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}