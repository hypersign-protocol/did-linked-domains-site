{"ast":null,"code":"\"use strict\";\n\nrequire(\"core-js/modules/es.typed-array.to-reversed.js\");\nrequire(\"core-js/modules/es.typed-array.to-sorted.js\");\nrequire(\"core-js/modules/es.typed-array.with.js\");\nrequire(\"core-js/modules/es.array.push.js\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Schema = exports.SchemaProof = exports.SchemaProperty = exports.SchemaDocument = exports.protobufPackage = void 0;\n/* eslint-disable */\nconst minimal_1 = require(\"protobufjs/minimal\");\nexports.protobufPackage = \"hypersignprotocol.hidnode.ssi\";\nconst baseSchemaDocument = {\n  type: \"\",\n  modelVersion: \"\",\n  id: \"\",\n  name: \"\",\n  author: \"\",\n  authored: \"\"\n};\nexports.SchemaDocument = {\n  encode(message, writer = minimal_1.Writer.create()) {\n    if (message.type !== \"\") {\n      writer.uint32(10).string(message.type);\n    }\n    if (message.modelVersion !== \"\") {\n      writer.uint32(18).string(message.modelVersion);\n    }\n    if (message.id !== \"\") {\n      writer.uint32(26).string(message.id);\n    }\n    if (message.name !== \"\") {\n      writer.uint32(34).string(message.name);\n    }\n    if (message.author !== \"\") {\n      writer.uint32(42).string(message.author);\n    }\n    if (message.authored !== \"\") {\n      writer.uint32(50).string(message.authored);\n    }\n    if (message.schema !== undefined) {\n      exports.SchemaProperty.encode(message.schema, writer.uint32(58).fork()).ldelim();\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof Uint8Array ? new minimal_1.Reader(input) : input;\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseSchemaDocument);\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.type = reader.string();\n          break;\n        case 2:\n          message.modelVersion = reader.string();\n          break;\n        case 3:\n          message.id = reader.string();\n          break;\n        case 4:\n          message.name = reader.string();\n          break;\n        case 5:\n          message.author = reader.string();\n          break;\n        case 6:\n          message.authored = reader.string();\n          break;\n        case 7:\n          message.schema = exports.SchemaProperty.decode(reader, reader.uint32());\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    const message = Object.assign({}, baseSchemaDocument);\n    if (object.type !== undefined && object.type !== null) {\n      message.type = String(object.type);\n    } else {\n      message.type = \"\";\n    }\n    if (object.modelVersion !== undefined && object.modelVersion !== null) {\n      message.modelVersion = String(object.modelVersion);\n    } else {\n      message.modelVersion = \"\";\n    }\n    if (object.id !== undefined && object.id !== null) {\n      message.id = String(object.id);\n    } else {\n      message.id = \"\";\n    }\n    if (object.name !== undefined && object.name !== null) {\n      message.name = String(object.name);\n    } else {\n      message.name = \"\";\n    }\n    if (object.author !== undefined && object.author !== null) {\n      message.author = String(object.author);\n    } else {\n      message.author = \"\";\n    }\n    if (object.authored !== undefined && object.authored !== null) {\n      message.authored = String(object.authored);\n    } else {\n      message.authored = \"\";\n    }\n    if (object.schema !== undefined && object.schema !== null) {\n      message.schema = exports.SchemaProperty.fromJSON(object.schema);\n    } else {\n      message.schema = undefined;\n    }\n    return message;\n  },\n  toJSON(message) {\n    const obj = {};\n    message.type !== undefined && (obj.type = message.type);\n    message.modelVersion !== undefined && (obj.modelVersion = message.modelVersion);\n    message.id !== undefined && (obj.id = message.id);\n    message.name !== undefined && (obj.name = message.name);\n    message.author !== undefined && (obj.author = message.author);\n    message.authored !== undefined && (obj.authored = message.authored);\n    message.schema !== undefined && (obj.schema = message.schema ? exports.SchemaProperty.toJSON(message.schema) : undefined);\n    return obj;\n  },\n  fromPartial(object) {\n    const message = Object.assign({}, baseSchemaDocument);\n    if (object.type !== undefined && object.type !== null) {\n      message.type = object.type;\n    } else {\n      message.type = \"\";\n    }\n    if (object.modelVersion !== undefined && object.modelVersion !== null) {\n      message.modelVersion = object.modelVersion;\n    } else {\n      message.modelVersion = \"\";\n    }\n    if (object.id !== undefined && object.id !== null) {\n      message.id = object.id;\n    } else {\n      message.id = \"\";\n    }\n    if (object.name !== undefined && object.name !== null) {\n      message.name = object.name;\n    } else {\n      message.name = \"\";\n    }\n    if (object.author !== undefined && object.author !== null) {\n      message.author = object.author;\n    } else {\n      message.author = \"\";\n    }\n    if (object.authored !== undefined && object.authored !== null) {\n      message.authored = object.authored;\n    } else {\n      message.authored = \"\";\n    }\n    if (object.schema !== undefined && object.schema !== null) {\n      message.schema = exports.SchemaProperty.fromPartial(object.schema);\n    } else {\n      message.schema = undefined;\n    }\n    return message;\n  }\n};\nconst baseSchemaProperty = {\n  schema: \"\",\n  description: \"\",\n  type: \"\",\n  properties: \"\",\n  required: \"\",\n  additionalProperties: false\n};\nexports.SchemaProperty = {\n  encode(message, writer = minimal_1.Writer.create()) {\n    if (message.schema !== \"\") {\n      writer.uint32(10).string(message.schema);\n    }\n    if (message.description !== \"\") {\n      writer.uint32(18).string(message.description);\n    }\n    if (message.type !== \"\") {\n      writer.uint32(26).string(message.type);\n    }\n    if (message.properties !== \"\") {\n      writer.uint32(34).string(message.properties);\n    }\n    for (const v of message.required) {\n      writer.uint32(42).string(v);\n    }\n    if (message.additionalProperties === true) {\n      writer.uint32(48).bool(message.additionalProperties);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof Uint8Array ? new minimal_1.Reader(input) : input;\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseSchemaProperty);\n    message.required = [];\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.schema = reader.string();\n          break;\n        case 2:\n          message.description = reader.string();\n          break;\n        case 3:\n          message.type = reader.string();\n          break;\n        case 4:\n          message.properties = reader.string();\n          break;\n        case 5:\n          message.required.push(reader.string());\n          break;\n        case 6:\n          message.additionalProperties = reader.bool();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    const message = Object.assign({}, baseSchemaProperty);\n    message.required = [];\n    if (object.schema !== undefined && object.schema !== null) {\n      message.schema = String(object.schema);\n    } else {\n      message.schema = \"\";\n    }\n    if (object.description !== undefined && object.description !== null) {\n      message.description = String(object.description);\n    } else {\n      message.description = \"\";\n    }\n    if (object.type !== undefined && object.type !== null) {\n      message.type = String(object.type);\n    } else {\n      message.type = \"\";\n    }\n    if (object.properties !== undefined && object.properties !== null) {\n      message.properties = String(object.properties);\n    } else {\n      message.properties = \"\";\n    }\n    if (object.required !== undefined && object.required !== null) {\n      for (const e of object.required) {\n        message.required.push(String(e));\n      }\n    }\n    if (object.additionalProperties !== undefined && object.additionalProperties !== null) {\n      message.additionalProperties = Boolean(object.additionalProperties);\n    } else {\n      message.additionalProperties = false;\n    }\n    return message;\n  },\n  toJSON(message) {\n    const obj = {};\n    message.schema !== undefined && (obj.schema = message.schema);\n    message.description !== undefined && (obj.description = message.description);\n    message.type !== undefined && (obj.type = message.type);\n    message.properties !== undefined && (obj.properties = message.properties);\n    if (message.required) {\n      obj.required = message.required.map(e => e);\n    } else {\n      obj.required = [];\n    }\n    message.additionalProperties !== undefined && (obj.additionalProperties = message.additionalProperties);\n    return obj;\n  },\n  fromPartial(object) {\n    const message = Object.assign({}, baseSchemaProperty);\n    message.required = [];\n    if (object.schema !== undefined && object.schema !== null) {\n      message.schema = object.schema;\n    } else {\n      message.schema = \"\";\n    }\n    if (object.description !== undefined && object.description !== null) {\n      message.description = object.description;\n    } else {\n      message.description = \"\";\n    }\n    if (object.type !== undefined && object.type !== null) {\n      message.type = object.type;\n    } else {\n      message.type = \"\";\n    }\n    if (object.properties !== undefined && object.properties !== null) {\n      message.properties = object.properties;\n    } else {\n      message.properties = \"\";\n    }\n    if (object.required !== undefined && object.required !== null) {\n      for (const e of object.required) {\n        message.required.push(e);\n      }\n    }\n    if (object.additionalProperties !== undefined && object.additionalProperties !== null) {\n      message.additionalProperties = object.additionalProperties;\n    } else {\n      message.additionalProperties = false;\n    }\n    return message;\n  }\n};\nconst baseSchemaProof = {\n  type: \"\",\n  created: \"\",\n  verificationMethod: \"\",\n  proofPurpose: \"\",\n  proofValue: \"\"\n};\nexports.SchemaProof = {\n  encode(message, writer = minimal_1.Writer.create()) {\n    if (message.type !== \"\") {\n      writer.uint32(10).string(message.type);\n    }\n    if (message.created !== \"\") {\n      writer.uint32(18).string(message.created);\n    }\n    if (message.verificationMethod !== \"\") {\n      writer.uint32(34).string(message.verificationMethod);\n    }\n    if (message.proofPurpose !== \"\") {\n      writer.uint32(42).string(message.proofPurpose);\n    }\n    if (message.proofValue !== \"\") {\n      writer.uint32(50).string(message.proofValue);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof Uint8Array ? new minimal_1.Reader(input) : input;\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseSchemaProof);\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.type = reader.string();\n          break;\n        case 2:\n          message.created = reader.string();\n          break;\n        case 4:\n          message.verificationMethod = reader.string();\n          break;\n        case 5:\n          message.proofPurpose = reader.string();\n          break;\n        case 6:\n          message.proofValue = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    const message = Object.assign({}, baseSchemaProof);\n    if (object.type !== undefined && object.type !== null) {\n      message.type = String(object.type);\n    } else {\n      message.type = \"\";\n    }\n    if (object.created !== undefined && object.created !== null) {\n      message.created = String(object.created);\n    } else {\n      message.created = \"\";\n    }\n    if (object.verificationMethod !== undefined && object.verificationMethod !== null) {\n      message.verificationMethod = String(object.verificationMethod);\n    } else {\n      message.verificationMethod = \"\";\n    }\n    if (object.proofPurpose !== undefined && object.proofPurpose !== null) {\n      message.proofPurpose = String(object.proofPurpose);\n    } else {\n      message.proofPurpose = \"\";\n    }\n    if (object.proofValue !== undefined && object.proofValue !== null) {\n      message.proofValue = String(object.proofValue);\n    } else {\n      message.proofValue = \"\";\n    }\n    return message;\n  },\n  toJSON(message) {\n    const obj = {};\n    message.type !== undefined && (obj.type = message.type);\n    message.created !== undefined && (obj.created = message.created);\n    message.verificationMethod !== undefined && (obj.verificationMethod = message.verificationMethod);\n    message.proofPurpose !== undefined && (obj.proofPurpose = message.proofPurpose);\n    message.proofValue !== undefined && (obj.proofValue = message.proofValue);\n    return obj;\n  },\n  fromPartial(object) {\n    const message = Object.assign({}, baseSchemaProof);\n    if (object.type !== undefined && object.type !== null) {\n      message.type = object.type;\n    } else {\n      message.type = \"\";\n    }\n    if (object.created !== undefined && object.created !== null) {\n      message.created = object.created;\n    } else {\n      message.created = \"\";\n    }\n    if (object.verificationMethod !== undefined && object.verificationMethod !== null) {\n      message.verificationMethod = object.verificationMethod;\n    } else {\n      message.verificationMethod = \"\";\n    }\n    if (object.proofPurpose !== undefined && object.proofPurpose !== null) {\n      message.proofPurpose = object.proofPurpose;\n    } else {\n      message.proofPurpose = \"\";\n    }\n    if (object.proofValue !== undefined && object.proofValue !== null) {\n      message.proofValue = object.proofValue;\n    } else {\n      message.proofValue = \"\";\n    }\n    return message;\n  }\n};\nconst baseSchema = {\n  type: \"\",\n  modelVersion: \"\",\n  id: \"\",\n  name: \"\",\n  author: \"\",\n  authored: \"\"\n};\nexports.Schema = {\n  encode(message, writer = minimal_1.Writer.create()) {\n    if (message.type !== \"\") {\n      writer.uint32(10).string(message.type);\n    }\n    if (message.modelVersion !== \"\") {\n      writer.uint32(18).string(message.modelVersion);\n    }\n    if (message.id !== \"\") {\n      writer.uint32(26).string(message.id);\n    }\n    if (message.name !== \"\") {\n      writer.uint32(34).string(message.name);\n    }\n    if (message.author !== \"\") {\n      writer.uint32(42).string(message.author);\n    }\n    if (message.authored !== \"\") {\n      writer.uint32(50).string(message.authored);\n    }\n    if (message.schema !== undefined) {\n      exports.SchemaProperty.encode(message.schema, writer.uint32(58).fork()).ldelim();\n    }\n    if (message.proof !== undefined) {\n      exports.SchemaProof.encode(message.proof, writer.uint32(66).fork()).ldelim();\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof Uint8Array ? new minimal_1.Reader(input) : input;\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseSchema);\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.type = reader.string();\n          break;\n        case 2:\n          message.modelVersion = reader.string();\n          break;\n        case 3:\n          message.id = reader.string();\n          break;\n        case 4:\n          message.name = reader.string();\n          break;\n        case 5:\n          message.author = reader.string();\n          break;\n        case 6:\n          message.authored = reader.string();\n          break;\n        case 7:\n          message.schema = exports.SchemaProperty.decode(reader, reader.uint32());\n          break;\n        case 8:\n          message.proof = exports.SchemaProof.decode(reader, reader.uint32());\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    const message = Object.assign({}, baseSchema);\n    if (object.type !== undefined && object.type !== null) {\n      message.type = String(object.type);\n    } else {\n      message.type = \"\";\n    }\n    if (object.modelVersion !== undefined && object.modelVersion !== null) {\n      message.modelVersion = String(object.modelVersion);\n    } else {\n      message.modelVersion = \"\";\n    }\n    if (object.id !== undefined && object.id !== null) {\n      message.id = String(object.id);\n    } else {\n      message.id = \"\";\n    }\n    if (object.name !== undefined && object.name !== null) {\n      message.name = String(object.name);\n    } else {\n      message.name = \"\";\n    }\n    if (object.author !== undefined && object.author !== null) {\n      message.author = String(object.author);\n    } else {\n      message.author = \"\";\n    }\n    if (object.authored !== undefined && object.authored !== null) {\n      message.authored = String(object.authored);\n    } else {\n      message.authored = \"\";\n    }\n    if (object.schema !== undefined && object.schema !== null) {\n      message.schema = exports.SchemaProperty.fromJSON(object.schema);\n    } else {\n      message.schema = undefined;\n    }\n    if (object.proof !== undefined && object.proof !== null) {\n      message.proof = exports.SchemaProof.fromJSON(object.proof);\n    } else {\n      message.proof = undefined;\n    }\n    return message;\n  },\n  toJSON(message) {\n    const obj = {};\n    message.type !== undefined && (obj.type = message.type);\n    message.modelVersion !== undefined && (obj.modelVersion = message.modelVersion);\n    message.id !== undefined && (obj.id = message.id);\n    message.name !== undefined && (obj.name = message.name);\n    message.author !== undefined && (obj.author = message.author);\n    message.authored !== undefined && (obj.authored = message.authored);\n    message.schema !== undefined && (obj.schema = message.schema ? exports.SchemaProperty.toJSON(message.schema) : undefined);\n    message.proof !== undefined && (obj.proof = message.proof ? exports.SchemaProof.toJSON(message.proof) : undefined);\n    return obj;\n  },\n  fromPartial(object) {\n    const message = Object.assign({}, baseSchema);\n    if (object.type !== undefined && object.type !== null) {\n      message.type = object.type;\n    } else {\n      message.type = \"\";\n    }\n    if (object.modelVersion !== undefined && object.modelVersion !== null) {\n      message.modelVersion = object.modelVersion;\n    } else {\n      message.modelVersion = \"\";\n    }\n    if (object.id !== undefined && object.id !== null) {\n      message.id = object.id;\n    } else {\n      message.id = \"\";\n    }\n    if (object.name !== undefined && object.name !== null) {\n      message.name = object.name;\n    } else {\n      message.name = \"\";\n    }\n    if (object.author !== undefined && object.author !== null) {\n      message.author = object.author;\n    } else {\n      message.author = \"\";\n    }\n    if (object.authored !== undefined && object.authored !== null) {\n      message.authored = object.authored;\n    } else {\n      message.authored = \"\";\n    }\n    if (object.schema !== undefined && object.schema !== null) {\n      message.schema = exports.SchemaProperty.fromPartial(object.schema);\n    } else {\n      message.schema = undefined;\n    }\n    if (object.proof !== undefined && object.proof !== null) {\n      message.proof = exports.SchemaProof.fromPartial(object.proof);\n    } else {\n      message.proof = undefined;\n    }\n    return message;\n  }\n};","map":{"version":3,"names":["require","Object","defineProperty","exports","value","Schema","SchemaProof","SchemaProperty","SchemaDocument","protobufPackage","minimal_1","baseSchemaDocument","type","modelVersion","id","name","author","authored","encode","message","writer","Writer","create","uint32","string","schema","undefined","fork","ldelim","decode","input","length","reader","Uint8Array","Reader","end","len","pos","assign","tag","skipType","fromJSON","object","String","toJSON","obj","fromPartial","baseSchemaProperty","description","properties","required","additionalProperties","v","bool","push","e","Boolean","map","baseSchemaProof","created","verificationMethod","proofPurpose","proofValue","baseSchema","proof"],"sources":["/home/pratap/hid-ssi-js-sdk/build/libs/generated/ssi/schema.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Schema = exports.SchemaProof = exports.SchemaProperty = exports.SchemaDocument = exports.protobufPackage = void 0;\n/* eslint-disable */\nconst minimal_1 = require(\"protobufjs/minimal\");\nexports.protobufPackage = \"hypersignprotocol.hidnode.ssi\";\nconst baseSchemaDocument = {\n    type: \"\",\n    modelVersion: \"\",\n    id: \"\",\n    name: \"\",\n    author: \"\",\n    authored: \"\",\n};\nexports.SchemaDocument = {\n    encode(message, writer = minimal_1.Writer.create()) {\n        if (message.type !== \"\") {\n            writer.uint32(10).string(message.type);\n        }\n        if (message.modelVersion !== \"\") {\n            writer.uint32(18).string(message.modelVersion);\n        }\n        if (message.id !== \"\") {\n            writer.uint32(26).string(message.id);\n        }\n        if (message.name !== \"\") {\n            writer.uint32(34).string(message.name);\n        }\n        if (message.author !== \"\") {\n            writer.uint32(42).string(message.author);\n        }\n        if (message.authored !== \"\") {\n            writer.uint32(50).string(message.authored);\n        }\n        if (message.schema !== undefined) {\n            exports.SchemaProperty.encode(message.schema, writer.uint32(58).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof Uint8Array ? new minimal_1.Reader(input) : input;\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = Object.assign({}, baseSchemaDocument);\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.type = reader.string();\n                    break;\n                case 2:\n                    message.modelVersion = reader.string();\n                    break;\n                case 3:\n                    message.id = reader.string();\n                    break;\n                case 4:\n                    message.name = reader.string();\n                    break;\n                case 5:\n                    message.author = reader.string();\n                    break;\n                case 6:\n                    message.authored = reader.string();\n                    break;\n                case 7:\n                    message.schema = exports.SchemaProperty.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        const message = Object.assign({}, baseSchemaDocument);\n        if (object.type !== undefined && object.type !== null) {\n            message.type = String(object.type);\n        }\n        else {\n            message.type = \"\";\n        }\n        if (object.modelVersion !== undefined && object.modelVersion !== null) {\n            message.modelVersion = String(object.modelVersion);\n        }\n        else {\n            message.modelVersion = \"\";\n        }\n        if (object.id !== undefined && object.id !== null) {\n            message.id = String(object.id);\n        }\n        else {\n            message.id = \"\";\n        }\n        if (object.name !== undefined && object.name !== null) {\n            message.name = String(object.name);\n        }\n        else {\n            message.name = \"\";\n        }\n        if (object.author !== undefined && object.author !== null) {\n            message.author = String(object.author);\n        }\n        else {\n            message.author = \"\";\n        }\n        if (object.authored !== undefined && object.authored !== null) {\n            message.authored = String(object.authored);\n        }\n        else {\n            message.authored = \"\";\n        }\n        if (object.schema !== undefined && object.schema !== null) {\n            message.schema = exports.SchemaProperty.fromJSON(object.schema);\n        }\n        else {\n            message.schema = undefined;\n        }\n        return message;\n    },\n    toJSON(message) {\n        const obj = {};\n        message.type !== undefined && (obj.type = message.type);\n        message.modelVersion !== undefined &&\n            (obj.modelVersion = message.modelVersion);\n        message.id !== undefined && (obj.id = message.id);\n        message.name !== undefined && (obj.name = message.name);\n        message.author !== undefined && (obj.author = message.author);\n        message.authored !== undefined && (obj.authored = message.authored);\n        message.schema !== undefined &&\n            (obj.schema = message.schema\n                ? exports.SchemaProperty.toJSON(message.schema)\n                : undefined);\n        return obj;\n    },\n    fromPartial(object) {\n        const message = Object.assign({}, baseSchemaDocument);\n        if (object.type !== undefined && object.type !== null) {\n            message.type = object.type;\n        }\n        else {\n            message.type = \"\";\n        }\n        if (object.modelVersion !== undefined && object.modelVersion !== null) {\n            message.modelVersion = object.modelVersion;\n        }\n        else {\n            message.modelVersion = \"\";\n        }\n        if (object.id !== undefined && object.id !== null) {\n            message.id = object.id;\n        }\n        else {\n            message.id = \"\";\n        }\n        if (object.name !== undefined && object.name !== null) {\n            message.name = object.name;\n        }\n        else {\n            message.name = \"\";\n        }\n        if (object.author !== undefined && object.author !== null) {\n            message.author = object.author;\n        }\n        else {\n            message.author = \"\";\n        }\n        if (object.authored !== undefined && object.authored !== null) {\n            message.authored = object.authored;\n        }\n        else {\n            message.authored = \"\";\n        }\n        if (object.schema !== undefined && object.schema !== null) {\n            message.schema = exports.SchemaProperty.fromPartial(object.schema);\n        }\n        else {\n            message.schema = undefined;\n        }\n        return message;\n    },\n};\nconst baseSchemaProperty = {\n    schema: \"\",\n    description: \"\",\n    type: \"\",\n    properties: \"\",\n    required: \"\",\n    additionalProperties: false,\n};\nexports.SchemaProperty = {\n    encode(message, writer = minimal_1.Writer.create()) {\n        if (message.schema !== \"\") {\n            writer.uint32(10).string(message.schema);\n        }\n        if (message.description !== \"\") {\n            writer.uint32(18).string(message.description);\n        }\n        if (message.type !== \"\") {\n            writer.uint32(26).string(message.type);\n        }\n        if (message.properties !== \"\") {\n            writer.uint32(34).string(message.properties);\n        }\n        for (const v of message.required) {\n            writer.uint32(42).string(v);\n        }\n        if (message.additionalProperties === true) {\n            writer.uint32(48).bool(message.additionalProperties);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof Uint8Array ? new minimal_1.Reader(input) : input;\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = Object.assign({}, baseSchemaProperty);\n        message.required = [];\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.schema = reader.string();\n                    break;\n                case 2:\n                    message.description = reader.string();\n                    break;\n                case 3:\n                    message.type = reader.string();\n                    break;\n                case 4:\n                    message.properties = reader.string();\n                    break;\n                case 5:\n                    message.required.push(reader.string());\n                    break;\n                case 6:\n                    message.additionalProperties = reader.bool();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        const message = Object.assign({}, baseSchemaProperty);\n        message.required = [];\n        if (object.schema !== undefined && object.schema !== null) {\n            message.schema = String(object.schema);\n        }\n        else {\n            message.schema = \"\";\n        }\n        if (object.description !== undefined && object.description !== null) {\n            message.description = String(object.description);\n        }\n        else {\n            message.description = \"\";\n        }\n        if (object.type !== undefined && object.type !== null) {\n            message.type = String(object.type);\n        }\n        else {\n            message.type = \"\";\n        }\n        if (object.properties !== undefined && object.properties !== null) {\n            message.properties = String(object.properties);\n        }\n        else {\n            message.properties = \"\";\n        }\n        if (object.required !== undefined && object.required !== null) {\n            for (const e of object.required) {\n                message.required.push(String(e));\n            }\n        }\n        if (object.additionalProperties !== undefined &&\n            object.additionalProperties !== null) {\n            message.additionalProperties = Boolean(object.additionalProperties);\n        }\n        else {\n            message.additionalProperties = false;\n        }\n        return message;\n    },\n    toJSON(message) {\n        const obj = {};\n        message.schema !== undefined && (obj.schema = message.schema);\n        message.description !== undefined &&\n            (obj.description = message.description);\n        message.type !== undefined && (obj.type = message.type);\n        message.properties !== undefined && (obj.properties = message.properties);\n        if (message.required) {\n            obj.required = message.required.map((e) => e);\n        }\n        else {\n            obj.required = [];\n        }\n        message.additionalProperties !== undefined &&\n            (obj.additionalProperties = message.additionalProperties);\n        return obj;\n    },\n    fromPartial(object) {\n        const message = Object.assign({}, baseSchemaProperty);\n        message.required = [];\n        if (object.schema !== undefined && object.schema !== null) {\n            message.schema = object.schema;\n        }\n        else {\n            message.schema = \"\";\n        }\n        if (object.description !== undefined && object.description !== null) {\n            message.description = object.description;\n        }\n        else {\n            message.description = \"\";\n        }\n        if (object.type !== undefined && object.type !== null) {\n            message.type = object.type;\n        }\n        else {\n            message.type = \"\";\n        }\n        if (object.properties !== undefined && object.properties !== null) {\n            message.properties = object.properties;\n        }\n        else {\n            message.properties = \"\";\n        }\n        if (object.required !== undefined && object.required !== null) {\n            for (const e of object.required) {\n                message.required.push(e);\n            }\n        }\n        if (object.additionalProperties !== undefined &&\n            object.additionalProperties !== null) {\n            message.additionalProperties = object.additionalProperties;\n        }\n        else {\n            message.additionalProperties = false;\n        }\n        return message;\n    },\n};\nconst baseSchemaProof = {\n    type: \"\",\n    created: \"\",\n    verificationMethod: \"\",\n    proofPurpose: \"\",\n    proofValue: \"\",\n};\nexports.SchemaProof = {\n    encode(message, writer = minimal_1.Writer.create()) {\n        if (message.type !== \"\") {\n            writer.uint32(10).string(message.type);\n        }\n        if (message.created !== \"\") {\n            writer.uint32(18).string(message.created);\n        }\n        if (message.verificationMethod !== \"\") {\n            writer.uint32(34).string(message.verificationMethod);\n        }\n        if (message.proofPurpose !== \"\") {\n            writer.uint32(42).string(message.proofPurpose);\n        }\n        if (message.proofValue !== \"\") {\n            writer.uint32(50).string(message.proofValue);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof Uint8Array ? new minimal_1.Reader(input) : input;\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = Object.assign({}, baseSchemaProof);\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.type = reader.string();\n                    break;\n                case 2:\n                    message.created = reader.string();\n                    break;\n                case 4:\n                    message.verificationMethod = reader.string();\n                    break;\n                case 5:\n                    message.proofPurpose = reader.string();\n                    break;\n                case 6:\n                    message.proofValue = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        const message = Object.assign({}, baseSchemaProof);\n        if (object.type !== undefined && object.type !== null) {\n            message.type = String(object.type);\n        }\n        else {\n            message.type = \"\";\n        }\n        if (object.created !== undefined && object.created !== null) {\n            message.created = String(object.created);\n        }\n        else {\n            message.created = \"\";\n        }\n        if (object.verificationMethod !== undefined &&\n            object.verificationMethod !== null) {\n            message.verificationMethod = String(object.verificationMethod);\n        }\n        else {\n            message.verificationMethod = \"\";\n        }\n        if (object.proofPurpose !== undefined && object.proofPurpose !== null) {\n            message.proofPurpose = String(object.proofPurpose);\n        }\n        else {\n            message.proofPurpose = \"\";\n        }\n        if (object.proofValue !== undefined && object.proofValue !== null) {\n            message.proofValue = String(object.proofValue);\n        }\n        else {\n            message.proofValue = \"\";\n        }\n        return message;\n    },\n    toJSON(message) {\n        const obj = {};\n        message.type !== undefined && (obj.type = message.type);\n        message.created !== undefined && (obj.created = message.created);\n        message.verificationMethod !== undefined &&\n            (obj.verificationMethod = message.verificationMethod);\n        message.proofPurpose !== undefined &&\n            (obj.proofPurpose = message.proofPurpose);\n        message.proofValue !== undefined && (obj.proofValue = message.proofValue);\n        return obj;\n    },\n    fromPartial(object) {\n        const message = Object.assign({}, baseSchemaProof);\n        if (object.type !== undefined && object.type !== null) {\n            message.type = object.type;\n        }\n        else {\n            message.type = \"\";\n        }\n        if (object.created !== undefined && object.created !== null) {\n            message.created = object.created;\n        }\n        else {\n            message.created = \"\";\n        }\n        if (object.verificationMethod !== undefined &&\n            object.verificationMethod !== null) {\n            message.verificationMethod = object.verificationMethod;\n        }\n        else {\n            message.verificationMethod = \"\";\n        }\n        if (object.proofPurpose !== undefined && object.proofPurpose !== null) {\n            message.proofPurpose = object.proofPurpose;\n        }\n        else {\n            message.proofPurpose = \"\";\n        }\n        if (object.proofValue !== undefined && object.proofValue !== null) {\n            message.proofValue = object.proofValue;\n        }\n        else {\n            message.proofValue = \"\";\n        }\n        return message;\n    },\n};\nconst baseSchema = {\n    type: \"\",\n    modelVersion: \"\",\n    id: \"\",\n    name: \"\",\n    author: \"\",\n    authored: \"\",\n};\nexports.Schema = {\n    encode(message, writer = minimal_1.Writer.create()) {\n        if (message.type !== \"\") {\n            writer.uint32(10).string(message.type);\n        }\n        if (message.modelVersion !== \"\") {\n            writer.uint32(18).string(message.modelVersion);\n        }\n        if (message.id !== \"\") {\n            writer.uint32(26).string(message.id);\n        }\n        if (message.name !== \"\") {\n            writer.uint32(34).string(message.name);\n        }\n        if (message.author !== \"\") {\n            writer.uint32(42).string(message.author);\n        }\n        if (message.authored !== \"\") {\n            writer.uint32(50).string(message.authored);\n        }\n        if (message.schema !== undefined) {\n            exports.SchemaProperty.encode(message.schema, writer.uint32(58).fork()).ldelim();\n        }\n        if (message.proof !== undefined) {\n            exports.SchemaProof.encode(message.proof, writer.uint32(66).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof Uint8Array ? new minimal_1.Reader(input) : input;\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = Object.assign({}, baseSchema);\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.type = reader.string();\n                    break;\n                case 2:\n                    message.modelVersion = reader.string();\n                    break;\n                case 3:\n                    message.id = reader.string();\n                    break;\n                case 4:\n                    message.name = reader.string();\n                    break;\n                case 5:\n                    message.author = reader.string();\n                    break;\n                case 6:\n                    message.authored = reader.string();\n                    break;\n                case 7:\n                    message.schema = exports.SchemaProperty.decode(reader, reader.uint32());\n                    break;\n                case 8:\n                    message.proof = exports.SchemaProof.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        const message = Object.assign({}, baseSchema);\n        if (object.type !== undefined && object.type !== null) {\n            message.type = String(object.type);\n        }\n        else {\n            message.type = \"\";\n        }\n        if (object.modelVersion !== undefined && object.modelVersion !== null) {\n            message.modelVersion = String(object.modelVersion);\n        }\n        else {\n            message.modelVersion = \"\";\n        }\n        if (object.id !== undefined && object.id !== null) {\n            message.id = String(object.id);\n        }\n        else {\n            message.id = \"\";\n        }\n        if (object.name !== undefined && object.name !== null) {\n            message.name = String(object.name);\n        }\n        else {\n            message.name = \"\";\n        }\n        if (object.author !== undefined && object.author !== null) {\n            message.author = String(object.author);\n        }\n        else {\n            message.author = \"\";\n        }\n        if (object.authored !== undefined && object.authored !== null) {\n            message.authored = String(object.authored);\n        }\n        else {\n            message.authored = \"\";\n        }\n        if (object.schema !== undefined && object.schema !== null) {\n            message.schema = exports.SchemaProperty.fromJSON(object.schema);\n        }\n        else {\n            message.schema = undefined;\n        }\n        if (object.proof !== undefined && object.proof !== null) {\n            message.proof = exports.SchemaProof.fromJSON(object.proof);\n        }\n        else {\n            message.proof = undefined;\n        }\n        return message;\n    },\n    toJSON(message) {\n        const obj = {};\n        message.type !== undefined && (obj.type = message.type);\n        message.modelVersion !== undefined &&\n            (obj.modelVersion = message.modelVersion);\n        message.id !== undefined && (obj.id = message.id);\n        message.name !== undefined && (obj.name = message.name);\n        message.author !== undefined && (obj.author = message.author);\n        message.authored !== undefined && (obj.authored = message.authored);\n        message.schema !== undefined &&\n            (obj.schema = message.schema\n                ? exports.SchemaProperty.toJSON(message.schema)\n                : undefined);\n        message.proof !== undefined &&\n            (obj.proof = message.proof\n                ? exports.SchemaProof.toJSON(message.proof)\n                : undefined);\n        return obj;\n    },\n    fromPartial(object) {\n        const message = Object.assign({}, baseSchema);\n        if (object.type !== undefined && object.type !== null) {\n            message.type = object.type;\n        }\n        else {\n            message.type = \"\";\n        }\n        if (object.modelVersion !== undefined && object.modelVersion !== null) {\n            message.modelVersion = object.modelVersion;\n        }\n        else {\n            message.modelVersion = \"\";\n        }\n        if (object.id !== undefined && object.id !== null) {\n            message.id = object.id;\n        }\n        else {\n            message.id = \"\";\n        }\n        if (object.name !== undefined && object.name !== null) {\n            message.name = object.name;\n        }\n        else {\n            message.name = \"\";\n        }\n        if (object.author !== undefined && object.author !== null) {\n            message.author = object.author;\n        }\n        else {\n            message.author = \"\";\n        }\n        if (object.authored !== undefined && object.authored !== null) {\n            message.authored = object.authored;\n        }\n        else {\n            message.authored = \"\";\n        }\n        if (object.schema !== undefined && object.schema !== null) {\n            message.schema = exports.SchemaProperty.fromPartial(object.schema);\n        }\n        else {\n            message.schema = undefined;\n        }\n        if (object.proof !== undefined && object.proof !== null) {\n            message.proof = exports.SchemaProof.fromPartial(object.proof);\n        }\n        else {\n            message.proof = undefined;\n        }\n        return message;\n    },\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}