{"ast":null,"code":"\"use strict\";\n\nvar _classPrivateMethodInitSpec = require(\"/home/pratap/domain-linkege/node_modules/@babel/runtime/helpers/classPrivateMethodInitSpec.js\").default;\nvar _classPrivateFieldInitSpec = require(\"/home/pratap/domain-linkege/node_modules/@babel/runtime/helpers/classPrivateFieldInitSpec.js\").default;\nvar _defineProperty = require(\"/home/pratap/domain-linkege/node_modules/@babel/runtime/helpers/defineProperty.js\").default;\nvar _classPrivateMethodGet = require(\"/home/pratap/domain-linkege/node_modules/@babel/runtime/helpers/classPrivateMethodGet.js\").default;\nvar _classPrivateFieldSet = require(\"/home/pratap/domain-linkege/node_modules/@babel/runtime/helpers/classPrivateFieldSet.js\").default;\nvar _classPrivateFieldGet = require(\"/home/pratap/domain-linkege/node_modules/@babel/runtime/helpers/classPrivateFieldGet.js\").default;\nrequire(\"core-js/modules/es.typed-array.to-reversed.js\");\nrequire(\"core-js/modules/es.typed-array.to-sorted.js\");\nrequire(\"core-js/modules/es.typed-array.with.js\");\nrequire(\"core-js/modules/es.array.push.js\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.verifyTypedData = exports.TypedDataEncoder = void 0;\n//import { TypedDataDomain, TypedDataField } from \"@ethersproject/providerabstract-signer\";\nconst index_js_1 = require(\"../address/index.js\");\nconst index_js_2 = require(\"../crypto/index.js\");\nconst index_js_3 = require(\"../transaction/index.js\");\nconst index_js_4 = require(\"../utils/index.js\");\nconst id_js_1 = require(\"./id.js\");\nconst padding = new Uint8Array(32);\npadding.fill(0);\nconst BN__1 = BigInt(-1);\nconst BN_0 = BigInt(0);\nconst BN_1 = BigInt(1);\nconst BN_MAX_UINT256 = BigInt(\"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\");\n;\n;\nfunction hexPadRight(value) {\n  const bytes = (0, index_js_4.getBytes)(value);\n  const padOffset = bytes.length % 32;\n  if (padOffset) {\n    return (0, index_js_4.concat)([bytes, padding.slice(padOffset)]);\n  }\n  return (0, index_js_4.hexlify)(bytes);\n}\nconst hexTrue = (0, index_js_4.toBeHex)(BN_1, 32);\nconst hexFalse = (0, index_js_4.toBeHex)(BN_0, 32);\nconst domainFieldTypes = {\n  name: \"string\",\n  version: \"string\",\n  chainId: \"uint256\",\n  verifyingContract: \"address\",\n  salt: \"bytes32\"\n};\nconst domainFieldNames = [\"name\", \"version\", \"chainId\", \"verifyingContract\", \"salt\"];\nfunction checkString(key) {\n  return function (value) {\n    (0, index_js_4.assertArgument)(typeof value === \"string\", `invalid domain value for ${JSON.stringify(key)}`, `domain.${key}`, value);\n    return value;\n  };\n}\nconst domainChecks = {\n  name: checkString(\"name\"),\n  version: checkString(\"version\"),\n  chainId: function (_value) {\n    const value = (0, index_js_4.getBigInt)(_value, \"domain.chainId\");\n    (0, index_js_4.assertArgument)(value >= 0, \"invalid chain ID\", \"domain.chainId\", _value);\n    if (Number.isSafeInteger(value)) {\n      return Number(value);\n    }\n    return (0, index_js_4.toQuantity)(value);\n  },\n  verifyingContract: function (value) {\n    try {\n      return (0, index_js_1.getAddress)(value).toLowerCase();\n    } catch (error) {}\n    (0, index_js_4.assertArgument)(false, `invalid domain value \"verifyingContract\"`, \"domain.verifyingContract\", value);\n  },\n  salt: function (value) {\n    const bytes = (0, index_js_4.getBytes)(value, \"domain.salt\");\n    (0, index_js_4.assertArgument)(bytes.length === 32, `invalid domain value \"salt\"`, \"domain.salt\", value);\n    return (0, index_js_4.hexlify)(bytes);\n  }\n};\nfunction getBaseEncoder(type) {\n  // intXX and uintXX\n  {\n    const match = type.match(/^(u?)int(\\d*)$/);\n    if (match) {\n      const signed = match[1] === \"\";\n      const width = parseInt(match[2] || \"256\");\n      (0, index_js_4.assertArgument)(width % 8 === 0 && width !== 0 && width <= 256 && (match[2] == null || match[2] === String(width)), \"invalid numeric width\", \"type\", type);\n      const boundsUpper = (0, index_js_4.mask)(BN_MAX_UINT256, signed ? width - 1 : width);\n      const boundsLower = signed ? (boundsUpper + BN_1) * BN__1 : BN_0;\n      return function (_value) {\n        const value = (0, index_js_4.getBigInt)(_value, \"value\");\n        (0, index_js_4.assertArgument)(value >= boundsLower && value <= boundsUpper, `value out-of-bounds for ${type}`, \"value\", value);\n        return (0, index_js_4.toBeHex)(signed ? (0, index_js_4.toTwos)(value, 256) : value, 32);\n      };\n    }\n  }\n  // bytesXX\n  {\n    const match = type.match(/^bytes(\\d+)$/);\n    if (match) {\n      const width = parseInt(match[1]);\n      (0, index_js_4.assertArgument)(width !== 0 && width <= 32 && match[1] === String(width), \"invalid bytes width\", \"type\", type);\n      return function (value) {\n        const bytes = (0, index_js_4.getBytes)(value);\n        (0, index_js_4.assertArgument)(bytes.length === width, `invalid length for ${type}`, \"value\", value);\n        return hexPadRight(value);\n      };\n    }\n  }\n  switch (type) {\n    case \"address\":\n      return function (value) {\n        return (0, index_js_4.zeroPadValue)((0, index_js_1.getAddress)(value), 32);\n      };\n    case \"bool\":\n      return function (value) {\n        return !value ? hexFalse : hexTrue;\n      };\n    case \"bytes\":\n      return function (value) {\n        return (0, index_js_2.keccak256)(value);\n      };\n    case \"string\":\n      return function (value) {\n        return (0, id_js_1.id)(value);\n      };\n  }\n  return null;\n}\nfunction encodeType(name, fields) {\n  return `${name}(${fields.map(({\n    name,\n    type\n  }) => type + \" \" + name).join(\",\")})`;\n}\n/**\n *  A **TypedDataEncode** prepares and encodes [[link-eip-712]] payloads\n *  for signed typed data.\n *\n *  This is useful for those that wish to compute various components of a\n *  typed data hash, primary types, or sub-components, but generally the\n *  higher level [[Signer-signTypedData]] is more useful.\n */\nvar _types = /*#__PURE__*/new WeakMap();\nvar _fullTypes = /*#__PURE__*/new WeakMap();\nvar _encoderCache = /*#__PURE__*/new WeakMap();\nvar _getEncoder = /*#__PURE__*/new WeakSet();\nclass TypedDataEncoder {\n  /**\n   *  The types.\n   */\n  get types() {\n    return JSON.parse(_classPrivateFieldGet(this, _types));\n  }\n  /**\n   *  Create a new **TypedDataEncoder** for %%types%%.\n   *\n   *  This performs all necessary checking that types are valid and\n   *  do not violate the [[link-eip-712]] structural constraints as\n   *  well as computes the [[primaryType]].\n   */\n  constructor(types) {\n    _classPrivateMethodInitSpec(this, _getEncoder);\n    /**\n     *  The primary type for the structured [[types]].\n     *\n     *  This is derived automatically from the [[types]], since no\n     *  recursion is possible, once the DAG for the types is consturcted\n     *  internally, the primary type must be the only remaining type with\n     *  no parent nodes.\n     */\n    _defineProperty(this, \"primaryType\", void 0);\n    _classPrivateFieldInitSpec(this, _types, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _fullTypes, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _encoderCache, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldSet(this, _types, JSON.stringify(types));\n    _classPrivateFieldSet(this, _fullTypes, new Map());\n    _classPrivateFieldSet(this, _encoderCache, new Map());\n    // Link struct types to their direct child structs\n    const links = new Map();\n    // Link structs to structs which contain them as a child\n    const parents = new Map();\n    // Link all subtypes within a given struct\n    const subtypes = new Map();\n    Object.keys(types).forEach(type => {\n      links.set(type, new Set());\n      parents.set(type, []);\n      subtypes.set(type, new Set());\n    });\n    for (const name in types) {\n      const uniqueNames = new Set();\n      for (const field of types[name]) {\n        // Check each field has a unique name\n        (0, index_js_4.assertArgument)(!uniqueNames.has(field.name), `duplicate variable name ${JSON.stringify(field.name)} in ${JSON.stringify(name)}`, \"types\", types);\n        uniqueNames.add(field.name);\n        // Get the base type (drop any array specifiers)\n        const baseType = field.type.match(/^([^\\x5b]*)(\\x5b|$)/)[1] || null;\n        (0, index_js_4.assertArgument)(baseType !== name, `circular type reference to ${JSON.stringify(baseType)}`, \"types\", types);\n        // Is this a base encoding type?\n        const encoder = getBaseEncoder(baseType);\n        if (encoder) {\n          continue;\n        }\n        (0, index_js_4.assertArgument)(parents.has(baseType), `unknown type ${JSON.stringify(baseType)}`, \"types\", types);\n        // Add linkage\n        parents.get(baseType).push(name);\n        links.get(name).add(baseType);\n      }\n    }\n    // Deduce the primary type\n    const primaryTypes = Array.from(parents.keys()).filter(n => parents.get(n).length === 0);\n    (0, index_js_4.assertArgument)(primaryTypes.length !== 0, \"missing primary type\", \"types\", types);\n    (0, index_js_4.assertArgument)(primaryTypes.length === 1, `ambiguous primary types or unused types: ${primaryTypes.map(t => JSON.stringify(t)).join(\", \")}`, \"types\", types);\n    (0, index_js_4.defineProperties)(this, {\n      primaryType: primaryTypes[0]\n    });\n    // Check for circular type references\n    function checkCircular(type, found) {\n      (0, index_js_4.assertArgument)(!found.has(type), `circular type reference to ${JSON.stringify(type)}`, \"types\", types);\n      found.add(type);\n      for (const child of links.get(type)) {\n        if (!parents.has(child)) {\n          continue;\n        }\n        // Recursively check children\n        checkCircular(child, found);\n        // Mark all ancestors as having this decendant\n        for (const subtype of found) {\n          subtypes.get(subtype).add(child);\n        }\n      }\n      found.delete(type);\n    }\n    checkCircular(this.primaryType, new Set());\n    // Compute each fully describe type\n    for (const [name, set] of subtypes) {\n      const st = Array.from(set);\n      st.sort();\n      _classPrivateFieldGet(this, _fullTypes).set(name, encodeType(name, types[name]) + st.map(t => encodeType(t, types[t])).join(\"\"));\n    }\n  }\n  /**\n   *  Returnthe encoder for the specific %%type%%.\n   */\n  getEncoder(type) {\n    let encoder = _classPrivateFieldGet(this, _encoderCache).get(type);\n    if (!encoder) {\n      encoder = _classPrivateMethodGet(this, _getEncoder, _getEncoder2).call(this, type);\n      _classPrivateFieldGet(this, _encoderCache).set(type, encoder);\n    }\n    return encoder;\n  }\n  /**\n   *  Return the full type for %%name%%.\n   */\n  encodeType(name) {\n    const result = _classPrivateFieldGet(this, _fullTypes).get(name);\n    (0, index_js_4.assertArgument)(result, `unknown type: ${JSON.stringify(name)}`, \"name\", name);\n    return result;\n  }\n  /**\n   *  Return the encoded %%value%% for the %%type%%.\n   */\n  encodeData(type, value) {\n    return this.getEncoder(type)(value);\n  }\n  /**\n   *  Returns the hash of %%value%% for the type of %%name%%.\n   */\n  hashStruct(name, value) {\n    return (0, index_js_2.keccak256)(this.encodeData(name, value));\n  }\n  /**\n   *  Return the fulled encoded %%value%% for the [[types]].\n   */\n  encode(value) {\n    return this.encodeData(this.primaryType, value);\n  }\n  /**\n   *  Return the hash of the fully encoded %%value%% for the [[types]].\n   */\n  hash(value) {\n    return this.hashStruct(this.primaryType, value);\n  }\n  /**\n   *  @_ignore:\n   */\n  _visit(type, value, callback) {\n    // Basic encoder type (address, bool, uint256, etc)\n    {\n      const encoder = getBaseEncoder(type);\n      if (encoder) {\n        return callback(type, value);\n      }\n    }\n    // Array\n    const match = type.match(/^(.*)(\\x5b(\\d*)\\x5d)$/);\n    if (match) {\n      (0, index_js_4.assertArgument)(!match[3] || parseInt(match[3]) === value.length, `array length mismatch; expected length ${parseInt(match[3])}`, \"value\", value);\n      return value.map(v => this._visit(match[1], v, callback));\n    }\n    // Struct\n    const fields = this.types[type];\n    if (fields) {\n      return fields.reduce((accum, {\n        name,\n        type\n      }) => {\n        accum[name] = this._visit(type, value[name], callback);\n        return accum;\n      }, {});\n    }\n    (0, index_js_4.assertArgument)(false, `unknown type: ${type}`, \"type\", type);\n  }\n  /**\n   *  Call %%calback%% for each value in %%value%%, passing the type and\n   *  component within %%value%%.\n   *\n   *  This is useful for replacing addresses or other transformation that\n   *  may be desired on each component, based on its type.\n   */\n  visit(value, callback) {\n    return this._visit(this.primaryType, value, callback);\n  }\n  /**\n   *  Create a new **TypedDataEncoder** for %%types%%.\n   */\n  static from(types) {\n    return new TypedDataEncoder(types);\n  }\n  /**\n   *  Return the primary type for %%types%%.\n   */\n  static getPrimaryType(types) {\n    return TypedDataEncoder.from(types).primaryType;\n  }\n  /**\n   *  Return the hashed struct for %%value%% using %%types%% and %%name%%.\n   */\n  static hashStruct(name, types, value) {\n    return TypedDataEncoder.from(types).hashStruct(name, value);\n  }\n  /**\n   *  Return the domain hash for %%domain%%.\n   */\n  static hashDomain(domain) {\n    const domainFields = [];\n    for (const name in domain) {\n      if (domain[name] == null) {\n        continue;\n      }\n      const type = domainFieldTypes[name];\n      (0, index_js_4.assertArgument)(type, `invalid typed-data domain key: ${JSON.stringify(name)}`, \"domain\", domain);\n      domainFields.push({\n        name,\n        type\n      });\n    }\n    domainFields.sort((a, b) => {\n      return domainFieldNames.indexOf(a.name) - domainFieldNames.indexOf(b.name);\n    });\n    return TypedDataEncoder.hashStruct(\"EIP712Domain\", {\n      EIP712Domain: domainFields\n    }, domain);\n  }\n  /**\n   *  Return the fully encoded [[link-eip-712]] %%value%% for %%types%% with %%domain%%.\n   */\n  static encode(domain, types, value) {\n    return (0, index_js_4.concat)([\"0x1901\", TypedDataEncoder.hashDomain(domain), TypedDataEncoder.from(types).hash(value)]);\n  }\n  /**\n   *  Return the hash of the fully encoded [[link-eip-712]] %%value%% for %%types%% with %%domain%%.\n   */\n  static hash(domain, types, value) {\n    return (0, index_js_2.keccak256)(TypedDataEncoder.encode(domain, types, value));\n  }\n  // Replaces all address types with ENS names with their looked up address\n  /**\n   * Resolves to the value from resolving all addresses in %%value%% for\n   * %%types%% and the %%domain%%.\n   */\n  static async resolveNames(domain, types, value, resolveName) {\n    // Make a copy to isolate it from the object passed in\n    domain = Object.assign({}, domain);\n    // Allow passing null to ignore value\n    for (const key in domain) {\n      if (domain[key] == null) {\n        delete domain[key];\n      }\n    }\n    // Look up all ENS names\n    const ensCache = {};\n    // Do we need to look up the domain's verifyingContract?\n    if (domain.verifyingContract && !(0, index_js_4.isHexString)(domain.verifyingContract, 20)) {\n      ensCache[domain.verifyingContract] = \"0x\";\n    }\n    // We are going to use the encoder to visit all the base values\n    const encoder = TypedDataEncoder.from(types);\n    // Get a list of all the addresses\n    encoder.visit(value, (type, value) => {\n      if (type === \"address\" && !(0, index_js_4.isHexString)(value, 20)) {\n        ensCache[value] = \"0x\";\n      }\n      return value;\n    });\n    // Lookup each name\n    for (const name in ensCache) {\n      ensCache[name] = await resolveName(name);\n    }\n    // Replace the domain verifyingContract if needed\n    if (domain.verifyingContract && ensCache[domain.verifyingContract]) {\n      domain.verifyingContract = ensCache[domain.verifyingContract];\n    }\n    // Replace all ENS names with their address\n    value = encoder.visit(value, (type, value) => {\n      if (type === \"address\" && ensCache[value]) {\n        return ensCache[value];\n      }\n      return value;\n    });\n    return {\n      domain,\n      value\n    };\n  }\n  /**\n   *  Returns the JSON-encoded payload expected by nodes which implement\n   *  the JSON-RPC [[link-eip-712]] method.\n   */\n  static getPayload(domain, types, value) {\n    // Validate the domain fields\n    TypedDataEncoder.hashDomain(domain);\n    // Derive the EIP712Domain Struct reference type\n    const domainValues = {};\n    const domainTypes = [];\n    domainFieldNames.forEach(name => {\n      const value = domain[name];\n      if (value == null) {\n        return;\n      }\n      domainValues[name] = domainChecks[name](value);\n      domainTypes.push({\n        name,\n        type: domainFieldTypes[name]\n      });\n    });\n    const encoder = TypedDataEncoder.from(types);\n    const typesWithDomain = Object.assign({}, types);\n    (0, index_js_4.assertArgument)(typesWithDomain.EIP712Domain == null, \"types must not contain EIP712Domain type\", \"types.EIP712Domain\", types);\n    typesWithDomain.EIP712Domain = domainTypes;\n    // Validate the data structures and types\n    encoder.encode(value);\n    return {\n      types: typesWithDomain,\n      domain: domainValues,\n      primaryType: encoder.primaryType,\n      message: encoder.visit(value, (type, value) => {\n        // bytes\n        if (type.match(/^bytes(\\d*)/)) {\n          return (0, index_js_4.hexlify)((0, index_js_4.getBytes)(value));\n        }\n        // uint or int\n        if (type.match(/^u?int/)) {\n          return (0, index_js_4.getBigInt)(value).toString();\n        }\n        switch (type) {\n          case \"address\":\n            return value.toLowerCase();\n          case \"bool\":\n            return !!value;\n          case \"string\":\n            (0, index_js_4.assertArgument)(typeof value === \"string\", \"invalid string\", \"value\", value);\n            return value;\n        }\n        (0, index_js_4.assertArgument)(false, \"unsupported type\", \"type\", type);\n      })\n    };\n  }\n}\nfunction _getEncoder2(type) {\n  // Basic encoder type (address, bool, uint256, etc)\n  {\n    const encoder = getBaseEncoder(type);\n    if (encoder) {\n      return encoder;\n    }\n  }\n  // Array\n  const match = type.match(/^(.*)(\\x5b(\\d*)\\x5d)$/);\n  if (match) {\n    const subtype = match[1];\n    const subEncoder = this.getEncoder(subtype);\n    return value => {\n      (0, index_js_4.assertArgument)(!match[3] || parseInt(match[3]) === value.length, `array length mismatch; expected length ${parseInt(match[3])}`, \"value\", value);\n      let result = value.map(subEncoder);\n      if (_classPrivateFieldGet(this, _fullTypes).has(subtype)) {\n        result = result.map(index_js_2.keccak256);\n      }\n      return (0, index_js_2.keccak256)((0, index_js_4.concat)(result));\n    };\n  }\n  // Struct\n  const fields = this.types[type];\n  if (fields) {\n    const encodedType = (0, id_js_1.id)(_classPrivateFieldGet(this, _fullTypes).get(type));\n    return value => {\n      const values = fields.map(({\n        name,\n        type\n      }) => {\n        const result = this.getEncoder(type)(value[name]);\n        if (_classPrivateFieldGet(this, _fullTypes).has(type)) {\n          return (0, index_js_2.keccak256)(result);\n        }\n        return result;\n      });\n      values.unshift(encodedType);\n      return (0, index_js_4.concat)(values);\n    };\n  }\n  (0, index_js_4.assertArgument)(false, `unknown type: ${type}`, \"type\", type);\n}\nexports.TypedDataEncoder = TypedDataEncoder;\n/**\n *  Compute the address used to sign the typed data for the %%signature%%.\n */\nfunction verifyTypedData(domain, types, value, signature) {\n  return (0, index_js_3.recoverAddress)(TypedDataEncoder.hash(domain, types, value), signature);\n}\nexports.verifyTypedData = verifyTypedData;","map":{"version":3,"names":["index_js_1","require","index_js_2","index_js_3","index_js_4","id_js_1","padding","Uint8Array","fill","BN__1","BigInt","BN_0","BN_1","BN_MAX_UINT256","hexPadRight","value","bytes","getBytes","padOffset","length","concat","slice","hexlify","hexTrue","toBeHex","hexFalse","domainFieldTypes","name","version","chainId","verifyingContract","salt","domainFieldNames","checkString","key","assertArgument","JSON","stringify","domainChecks","_value","getBigInt","Number","isSafeInteger","toQuantity","getAddress","toLowerCase","error","getBaseEncoder","type","match","signed","width","parseInt","String","boundsUpper","mask","boundsLower","toTwos","zeroPadValue","keccak256","id","encodeType","fields","map","join","_types","WeakMap","_fullTypes","_encoderCache","_getEncoder","WeakSet","TypedDataEncoder","types","parse","_classPrivateFieldGet","constructor","_classPrivateMethodInitSpec","_defineProperty","_classPrivateFieldInitSpec","writable","_classPrivateFieldSet","Map","links","parents","subtypes","Object","keys","forEach","set","Set","uniqueNames","field","has","add","baseType","encoder","get","push","primaryTypes","Array","from","filter","n","t","defineProperties","primaryType","checkCircular","found","child","subtype","delete","st","sort","getEncoder","_classPrivateMethodGet","_getEncoder2","call","result","encodeData","hashStruct","encode","hash","_visit","callback","v","reduce","accum","visit","getPrimaryType","hashDomain","domain","domainFields","a","b","indexOf","EIP712Domain","resolveNames","resolveName","assign","ensCache","isHexString","getPayload","domainValues","domainTypes","typesWithDomain","message","toString","subEncoder","encodedType","values","unshift","exports","verifyTypedData","signature","recoverAddress"],"sources":["../../src.ts/hash/typed-data.ts"],"sourcesContent":[null],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}