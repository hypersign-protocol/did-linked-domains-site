{"ast":null,"code":"import \"core-js/modules/web.url-search-params.delete.js\";\nimport \"core-js/modules/web.url-search-params.has.js\";\nimport \"core-js/modules/web.url-search-params.size.js\";\n/**\n * A JavaScript implementation of Verifiable Credentials.\n *\n * @author Dave Longley\n * @author David I. Lehn\n *\n * @license BSD 3-Clause License\n * Copyright (c) 2017-2023 Digital Bazaar, Inc.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * Redistributions of source code must retain the above copyright notice,\n * this list of conditions and the following disclaimer.\n *\n * Redistributions in binary form must reproduce the above copyright\n * notice, this list of conditions and the following disclaimer in the\n * documentation and/or other materials provided with the distribution.\n *\n * Neither the name of the Digital Bazaar, Inc. nor the names of its\n * contributors may be used to endorse or promote products derived from\n * this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS\n * IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED\n * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A\n * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED\n * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\nimport { documentLoader as _documentLoader } from './documentLoader.js';\nimport { CredentialIssuancePurpose } from './CredentialIssuancePurpose.js';\nimport jsigs from 'jsonld-signatures';\nimport jsonld from 'jsonld';\nexport const defaultDocumentLoader = jsigs.extendContextLoader(_documentLoader);\nimport * as credentialsContext from 'credentials-context';\nconst {\n  AuthenticationProofPurpose\n} = jsigs.purposes;\nconst {\n  constants: {\n    CREDENTIALS_CONTEXT_V1_URL\n  }\n} = credentialsContext;\nexport { CredentialIssuancePurpose };\n\n// Z and T can be lowercase\n// RFC3339 regex\nexport const dateRegex = new RegExp('^(\\\\d{4})-(0[1-9]|1[0-2])-' + '(0[1-9]|[12][0-9]|3[01])T([01][0-9]|2[0-3]):' + '([0-5][0-9]):([0-5][0-9]|60)' + '(\\\\.[0-9]+)?(Z|(\\\\+|-)([01][0-9]|2[0-3]):' + '([0-5][0-9]))$', 'i');\n\n/**\n * @typedef {object} LinkedDataSignature\n */\n\n/**\n * @typedef {object} Presentation\n */\n\n/**\n * @typedef {object} ProofPurpose\n */\n\n/**\n * @typedef {object} VerifiableCredential\n */\n\n/**\n * @typedef {object} VerifiablePresentation\n */\n\n/**\n * @typedef {object} VerifyPresentationResult\n * @property {boolean} verified - True if verified, false if not.\n * @property {object} presentationResult\n * @property {Array} credentialResults\n * @property {object} error\n */\n\n/**\n * @typedef {object} VerifyCredentialResult\n * @property {boolean} verified - True if verified, false if not.\n * @property {object} statusResult\n * @property {Array} results\n * @property {object} error\n */\n\n/**\n * Issues a verifiable credential (by taking a base credential document,\n * and adding a digital signature to it).\n *\n * @param {object} [options={}] - The options to use.\n *\n * @param {object} options.credential - Base credential document.\n * @param {LinkedDataSignature} options.suite - Signature suite (with private\n *   key material), passed in to sign().\n *\n * @param {ProofPurpose} [options.purpose] - A ProofPurpose. If not specified,\n *   a default purpose will be created.\n *\n * Other optional params passed to `sign()`:\n * @param {object} [options.documentLoader] - A document loader.\n * @param {string|Date} [options.now] - A string representing date time in\n *   ISO 8601 format or an instance of Date. Defaults to current date time.\n *\n * @throws {Error} If missing required properties.\n *\n * @returns {Promise<VerifiableCredential>} Resolves on completion.\n */\nexport async function issue({\n  credential,\n  suite,\n  purpose = new CredentialIssuancePurpose(),\n  documentLoader = defaultDocumentLoader,\n  now\n} = {}) {\n  // check to make sure the `suite` has required params\n  // Note: verificationMethod defaults to publicKey.id, in suite constructor\n  if (!suite) {\n    throw new TypeError('\"suite\" parameter is required for issuing.');\n  }\n  if (!suite.verificationMethod) {\n    throw new TypeError('\"suite.verificationMethod\" property is required.');\n  }\n  if (!credential) {\n    throw new TypeError('\"credential\" parameter is required for issuing.');\n  }\n\n  // Set the issuance date to now(), if missing\n  if (!credential.issuanceDate) {\n    const now = new Date().toJSON();\n    credential.issuanceDate = `${now.substr(0, now.length - 5)}Z`;\n  }\n\n  // run common credential checks\n  _checkCredential({\n    credential,\n    now\n  });\n  return jsigs.sign(credential, {\n    purpose,\n    documentLoader,\n    suite\n  });\n}\n\n/**\n * Verifies a verifiable presentation:\n *   - Checks that the presentation is well-formed\n *   - Checks the proofs (for example, checks digital signatures against the\n *     provided public keys).\n *\n * @param {object} [options={}] - The options to use.\n *\n * @param {VerifiablePresentation} options.presentation - Verifiable\n *   presentation, signed or unsigned, that may contain within it a\n *   verifiable credential.\n *\n * @param {LinkedDataSignature|LinkedDataSignature[]} options.suite - One or\n *   more signature suites that are supported by the caller's use case. This is\n *   an explicit design decision -- the calling code must specify which\n *   signature types (ed25519, RSA, etc) are allowed.\n *   Although it is expected that the secure resolution/fetching of the public\n *   key material (to verify against) is to be handled by the documentLoader,\n *   the suite param can optionally include the key directly.\n *\n * @param {boolean} [options.unsignedPresentation=false] - By default, this\n *   function assumes that a presentation is signed (and will return an error if\n *   a `proof` section is missing). Set this to `true` if you're using an\n *   unsigned presentation.\n *\n * Either pass in a proof purpose,\n * @param {AuthenticationProofPurpose} [options.presentationPurpose] - Optional\n *   proof purpose (a default one will be created if not passed in).\n *\n * or a default purpose will be created with params:\n * @param {string} [options.challenge] - Required if purpose is not passed in.\n * @param {string} [options.controller] - A controller.\n * @param {string} [options.domain] - A domain.\n *\n * @param {Function} [options.documentLoader] - A document loader.\n * @param {Function} [options.checkStatus] - Optional function for checking\n *   credential status if `credentialStatus` is present on the credential.\n * @param {string|Date} [options.now] - A string representing date time in\n *   ISO 8601 format or an instance of Date. Defaults to current date time.\n *\n * @returns {Promise<VerifyPresentationResult>} The verification result.\n */\nexport async function verify(options = {}) {\n  const {\n    presentation\n  } = options;\n  try {\n    if (!presentation) {\n      throw new TypeError('A \"presentation\" property is required for verifying.');\n    }\n    return _verifyPresentation(options);\n  } catch (error) {\n    return {\n      verified: false,\n      results: [{\n        presentation,\n        verified: false,\n        error\n      }],\n      error\n    };\n  }\n}\n\n/**\n * Verifies a verifiable credential:\n *   - Checks that the credential is well-formed\n *   - Checks the proofs (for example, checks digital signatures against the\n *     provided public keys).\n *\n * @param {object} [options={}] - The options.\n *\n * @param {object} options.credential - Verifiable credential.\n *\n * @param {LinkedDataSignature|LinkedDataSignature[]} options.suite - One or\n *   more signature suites that are supported by the caller's use case. This is\n *   an explicit design decision -- the calling code must specify which\n *   signature types (ed25519, RSA, etc) are allowed.\n *   Although it is expected that the secure resolution/fetching of the public\n *   key material (to verify against) is to be handled by the documentLoader,\n *   the suite param can optionally include the key directly.\n *\n * @param {CredentialIssuancePurpose} [options.purpose] - Optional\n *   proof purpose (a default one will be created if not passed in).\n * @param {Function} [options.documentLoader] - A document loader.\n * @param {Function} [options.checkStatus] - Optional function for checking\n *   credential status if `credentialStatus` is present on the credential.\n * @param {string|Date} [options.now] - A string representing date time in\n *   ISO 8601 format or an instance of Date. Defaults to current date time.\n *\n * @returns {Promise<VerifyCredentialResult>} The verification result.\n */\nexport async function verifyCredential(options = {}) {\n  const {\n    credential\n  } = options;\n  try {\n    if (!credential) {\n      throw new TypeError('A \"credential\" property is required for verifying.');\n    }\n    return await _verifyCredential(options);\n  } catch (error) {\n    return {\n      verified: false,\n      results: [{\n        credential,\n        verified: false,\n        error\n      }],\n      error\n    };\n  }\n}\n\n/**\n * Verifies a verifiable credential.\n *\n * @private\n * @param {object} [options={}] - The options.\n *\n * @param {object} options.credential - Verifiable credential.\n * @param {LinkedDataSignature|LinkedDataSignature[]} options.suite - See the\n *   definition in the `verify()` docstring, for this param.\n * @param {string|Date} [options.now] - A string representing date time in\n *   ISO 8601 format or an instance of Date. Defaults to current date time.\n *\n * @throws {Error} If required parameters are missing (in `_checkCredential`).\n *\n * @param {CredentialIssuancePurpose} [options.purpose] - A purpose.\n * @param {Function} [options.documentLoader] - A document loader.\n * @param {Function} [options.checkStatus] - Optional function for checking\n *   credential status if `credentialStatus` is present on the credential.\n *\n * @returns {Promise<VerifyCredentialResult>} The verification result.\n */\nasync function _verifyCredential(options = {}) {\n  const {\n    credential,\n    checkStatus,\n    now\n  } = options;\n\n  // run common credential checks\n  _checkCredential({\n    credential,\n    now\n  });\n\n  // if credential status is provided, a `checkStatus` function must be given\n  if (credential.credentialStatus && typeof options.checkStatus !== 'function') {\n    throw new TypeError('A \"checkStatus\" function must be given to verify credentials with ' + '\"credentialStatus\".');\n  }\n  const documentLoader = options.documentLoader || defaultDocumentLoader;\n  const {\n    controller\n  } = options;\n  const purpose = options.purpose || new CredentialIssuancePurpose({\n    controller\n  });\n  const result = await jsigs.verify(credential, {\n    ...options,\n    purpose,\n    documentLoader\n  });\n\n  // if verification has already failed, skip status check\n  if (!result.verified) {\n    return result;\n  }\n  if (credential.credentialStatus) {\n    result.statusResult = await checkStatus(options);\n    if (!result.statusResult.verified) {\n      result.verified = false;\n    }\n  }\n  return result;\n}\n\n/**\n * Creates an unsigned presentation from a given verifiable credential.\n *\n * @param {object} options - Options to use.\n * @param {object|Array<object>} [options.verifiableCredential] - One or more\n *   verifiable credential.\n * @param {string} [options.id] - Optional VP id.\n * @param {string} [options.holder] - Optional presentation holder url.\n * @param {string|Date} [options.now] - A string representing date time in\n *   ISO 8601 format or an instance of Date. Defaults to current date time.\n *\n * @throws {TypeError} If verifiableCredential param is missing.\n * @throws {Error} If the credential (or the presentation params) are missing\n *   required properties.\n *\n * @returns {Presentation} The credential wrapped inside of a\n *   VerifiablePresentation.\n */\nexport function createPresentation({\n  verifiableCredential,\n  id,\n  holder,\n  now\n} = {}) {\n  const presentation = {\n    '@context': [CREDENTIALS_CONTEXT_V1_URL],\n    type: ['VerifiablePresentation']\n  };\n  if (verifiableCredential) {\n    const credentials = [].concat(verifiableCredential);\n    // ensure all credentials are valid\n    for (const credential of credentials) {\n      _checkCredential({\n        credential,\n        now\n      });\n    }\n    presentation.verifiableCredential = credentials;\n  }\n  if (id) {\n    presentation.id = id;\n  }\n  if (holder) {\n    presentation.holder = holder;\n  }\n  _checkPresentation(presentation);\n  return presentation;\n}\n\n/**\n * Signs a given presentation.\n *\n * @param {object} [options={}] - Options to use.\n *\n * Required:\n * @param {Presentation} options.presentation - A presentation.\n * @param {LinkedDataSignature} options.suite - passed in to sign()\n *\n * Either pass in a ProofPurpose, or a default one will be created with params:\n * @param {ProofPurpose} [options.purpose] - A ProofPurpose. If not specified,\n *   a default purpose will be created with the domain and challenge options.\n *\n * @param {string} [options.domain] - A domain.\n * @param {string} options.challenge - A required challenge.\n *\n * @param {Function} [options.documentLoader] - A document loader.\n *\n * @returns {Promise<{VerifiablePresentation}>} A VerifiablePresentation with\n *   a proof.\n */\nexport async function signPresentation(options = {}) {\n  const {\n    presentation,\n    domain,\n    challenge\n  } = options;\n  const purpose = options.purpose || new AuthenticationProofPurpose({\n    domain,\n    challenge\n  });\n  const documentLoader = options.documentLoader || defaultDocumentLoader;\n  return jsigs.sign(presentation, {\n    ...options,\n    purpose,\n    documentLoader\n  });\n}\n\n/**\n * Verifies that the VerifiablePresentation is well formed, and checks the\n * proof signature if it's present. Also verifies all the VerifiableCredentials\n * that are present in the presentation, if any.\n *\n * @param {object} [options={}] - The options.\n * @param {VerifiablePresentation} options.presentation - A\n *   VerifiablePresentation.\n *\n * @param {LinkedDataSignature|LinkedDataSignature[]} options.suite - See the\n *   definition in the `verify()` docstring, for this param.\n *\n * @param {boolean} [options.unsignedPresentation=false] - By default, this\n *   function assumes that a presentation is signed (and will return an error if\n *   a `proof` section is missing). Set this to `true` if you're using an\n *   unsigned presentation.\n *\n * Either pass in a proof purpose,\n * @param {AuthenticationProofPurpose} [options.presentationPurpose] - A\n *   ProofPurpose. If not specified, a default purpose will be created with\n *   the challenge, controller, and domain options.\n *\n * @param {string} [options.challenge] - A challenge. Required if purpose is\n *   not passed in.\n * @param {string} [options.controller] - A controller. Required if purpose is\n *   not passed in.\n * @param {string} [options.domain] - A domain. Required if purpose is not\n *   passed in.\n *\n * @param {Function} [options.documentLoader] - A document loader.\n * @param {Function} [options.checkStatus] - Optional function for checking\n *   credential status if `credentialStatus` is present on the credential.\n * @param {string|Date} [options.now] - A string representing date time in\n *   ISO 8601 format or an instance of Date. Defaults to current date time.\n *\n * @throws {Error} If presentation is missing required params.\n *\n * @returns {Promise<VerifyPresentationResult>} The verification result.\n */\nasync function _verifyPresentation(options = {}) {\n  const {\n    presentation,\n    unsignedPresentation\n  } = options;\n  _checkPresentation(presentation);\n  const documentLoader = options.documentLoader || defaultDocumentLoader;\n\n  // FIXME: verify presentation first, then each individual credential\n  // only if that proof is verified\n\n  // if verifiableCredentials are present, verify them, individually\n  let credentialResults;\n  let verified = true;\n  const credentials = jsonld.getValues(presentation, 'verifiableCredential');\n  if (credentials.length > 0) {\n    // verify every credential in `verifiableCredential`\n    credentialResults = await Promise.all(credentials.map(credential => {\n      return verifyCredential({\n        ...options,\n        credential,\n        documentLoader\n      });\n    }));\n    for (const [i, credentialResult] of credentialResults.entries()) {\n      credentialResult.credentialId = credentials[i].id;\n    }\n    const allCredentialsVerified = credentialResults.every(r => r.verified);\n    if (!allCredentialsVerified) {\n      verified = false;\n    }\n  }\n  if (unsignedPresentation) {\n    // No need to verify the proof section of this presentation\n    return {\n      verified,\n      results: [presentation],\n      credentialResults\n    };\n  }\n  const {\n    controller,\n    domain,\n    challenge\n  } = options;\n  if (!options.presentationPurpose && !challenge) {\n    throw new Error('A \"challenge\" param is required for AuthenticationProofPurpose.');\n  }\n  const purpose = options.presentationPurpose || new AuthenticationProofPurpose({\n    controller,\n    domain,\n    challenge\n  });\n  const presentationResult = await jsigs.verify(presentation, {\n    ...options,\n    purpose,\n    documentLoader\n  });\n  return {\n    presentationResult,\n    verified: verified && presentationResult.verified,\n    credentialResults,\n    error: presentationResult.error\n  };\n}\n\n/**\n * @param {string|object} obj - Either an object with an id property\n *   or a string that is an id.\n * @returns {string|undefined} Either an id or undefined.\n * @private\n *\n */\nfunction _getId(obj) {\n  if (typeof obj === 'string') {\n    return obj;\n  }\n  if (!('id' in obj)) {\n    return;\n  }\n  return obj.id;\n}\n\n// export for testing\n/**\n * @param {object} presentation - An object that could be a presentation.\n *\n * @throws {Error}\n * @private\n */\nexport function _checkPresentation(presentation) {\n  // normalize to an array to allow the common case of context being a string\n  const context = Array.isArray(presentation['@context']) ? presentation['@context'] : [presentation['@context']];\n\n  // ensure first context is 'https://www.w3.org/2018/credentials/v1'\n  if (context[0] !== CREDENTIALS_CONTEXT_V1_URL) {\n    throw new Error(`\"${CREDENTIALS_CONTEXT_V1_URL}\" needs to be first in the ` + 'list of contexts.');\n  }\n  const types = jsonld.getValues(presentation, 'type');\n\n  // check type presence\n  if (!types.includes('VerifiablePresentation')) {\n    throw new Error('\"type\" must include \"VerifiablePresentation\".');\n  }\n}\n\n// export for testing\n/**\n * @param {object} options - The options.\n * @param {object} options.credential - An object that could be a\n *   VerifiableCredential.\n * @param {string|Date} [options.now] - A string representing date time in\n *   ISO 8601 format or an instance of Date. Defaults to current date time.\n *\n * @throws {Error}\n * @private\n */\nexport function _checkCredential({\n  credential,\n  now = new Date()\n}) {\n  if (typeof now === 'string') {\n    now = new Date(now);\n  }\n  // ensure first context is 'https://www.w3.org/2018/credentials/v1'\n  if (credential['@context'][0] !== CREDENTIALS_CONTEXT_V1_URL) {\n    throw new Error(`\"${CREDENTIALS_CONTEXT_V1_URL}\" needs to be first in the ` + 'list of contexts.');\n  }\n\n  // check type presence and cardinality\n  if (!credential.type) {\n    throw new Error('\"type\" property is required.');\n  }\n  if (!jsonld.getValues(credential, 'type').includes('VerifiableCredential')) {\n    throw new Error('\"type\" must include `VerifiableCredential`.');\n  }\n  if (!credential.credentialSubject) {\n    throw new Error('\"credentialSubject\" property is required.');\n  }\n\n  // If credentialSubject.id is present and is not a URI, reject it\n  if (credential.credentialSubject.id) {\n    _validateUriId({\n      id: credential.credentialSubject.id,\n      propertyName: 'credentialSubject.id'\n    });\n  }\n  if (!credential.issuer) {\n    throw new Error('\"issuer\" property is required.');\n  }\n\n  // check issuanceDate cardinality\n  if (jsonld.getValues(credential, 'issuanceDate').length > 1) {\n    throw new Error('\"issuanceDate\" property can only have one value.');\n  }\n\n  // check issued is a date\n  if (!credential.issuanceDate) {\n    throw new Error('\"issuanceDate\" property is required.');\n  }\n  if ('issuanceDate' in credential) {\n    let {\n      issuanceDate\n    } = credential;\n    if (!dateRegex.test(issuanceDate)) {\n      throw new Error(`\"issuanceDate\" must be a valid date: ${issuanceDate}`);\n    }\n    // check if `now` is before `issuanceDate`\n    issuanceDate = new Date(issuanceDate);\n    if (now < issuanceDate) {\n      throw new Error(`The current date time (${now.toISOString()}) is before the ` + `\"issuanceDate\" (${issuanceDate.toISOString()}).`);\n    }\n  }\n\n  // check issuer cardinality\n  if (jsonld.getValues(credential, 'issuer').length > 1) {\n    throw new Error('\"issuer\" property can only have one value.');\n  }\n\n  // check issuer is a URL\n  if ('issuer' in credential) {\n    const issuer = _getId(credential.issuer);\n    if (!issuer) {\n      throw new Error(`\"issuer\" id is required.`);\n    }\n    _validateUriId({\n      id: issuer,\n      propertyName: 'issuer'\n    });\n  }\n  if ('credentialStatus' in credential) {\n    if (!credential.credentialStatus.id) {\n      throw new Error('\"credentialStatus\" must include an id.');\n    }\n    if (!credential.credentialStatus.type) {\n      throw new Error('\"credentialStatus\" must include a type.');\n    }\n  }\n\n  // check evidences are URLs\n  jsonld.getValues(credential, 'evidence').forEach(evidence => {\n    const evidenceId = _getId(evidence);\n    if (evidenceId) {\n      _validateUriId({\n        id: evidenceId,\n        propertyName: 'evidence'\n      });\n    }\n  });\n  if ('expirationDate' in credential) {\n    const {\n      expirationDate\n    } = credential;\n    // check if `expirationDate` property is a date\n    if (!dateRegex.test(expirationDate)) {\n      throw new Error(`\"expirationDate\" must be a valid date: ${expirationDate}`);\n    }\n    // check if `now` is after `expirationDate`\n    if (now > new Date(expirationDate)) {\n      throw new Error('Credential has expired.');\n    }\n  }\n}\nfunction _validateUriId({\n  id,\n  propertyName\n}) {\n  let parsed;\n  try {\n    parsed = new URL(id);\n  } catch (e) {\n    const error = new TypeError(`\"${propertyName}\" must be a URI: \"${id}\".`);\n    error.cause = e;\n    throw error;\n  }\n  if (!parsed.protocol) {\n    throw new TypeError(`\"${propertyName}\" must be a URI: \"${id}\".`);\n  }\n}","map":{"version":3,"names":["documentLoader","_documentLoader","CredentialIssuancePurpose","jsigs","jsonld","defaultDocumentLoader","extendContextLoader","credentialsContext","AuthenticationProofPurpose","purposes","constants","CREDENTIALS_CONTEXT_V1_URL","dateRegex","RegExp","issue","credential","suite","purpose","now","TypeError","verificationMethod","issuanceDate","Date","toJSON","substr","length","_checkCredential","sign","verify","options","presentation","_verifyPresentation","error","verified","results","verifyCredential","_verifyCredential","checkStatus","credentialStatus","controller","result","statusResult","createPresentation","verifiableCredential","id","holder","type","credentials","concat","_checkPresentation","signPresentation","domain","challenge","unsignedPresentation","credentialResults","getValues","Promise","all","map","i","credentialResult","entries","credentialId","allCredentialsVerified","every","r","presentationPurpose","Error","presentationResult","_getId","obj","context","Array","isArray","types","includes","credentialSubject","_validateUriId","propertyName","issuer","test","toISOString","forEach","evidence","evidenceId","expirationDate","parsed","URL","e","cause","protocol"],"sources":["/home/pratap/domain-linkege/node_modules/@digitalbazaar/vc/lib/index.js"],"sourcesContent":["/**\n * A JavaScript implementation of Verifiable Credentials.\n *\n * @author Dave Longley\n * @author David I. Lehn\n *\n * @license BSD 3-Clause License\n * Copyright (c) 2017-2023 Digital Bazaar, Inc.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * Redistributions of source code must retain the above copyright notice,\n * this list of conditions and the following disclaimer.\n *\n * Redistributions in binary form must reproduce the above copyright\n * notice, this list of conditions and the following disclaimer in the\n * documentation and/or other materials provided with the distribution.\n *\n * Neither the name of the Digital Bazaar, Inc. nor the names of its\n * contributors may be used to endorse or promote products derived from\n * this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS\n * IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED\n * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A\n * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED\n * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\nimport {documentLoader as _documentLoader} from './documentLoader.js';\nimport {CredentialIssuancePurpose} from './CredentialIssuancePurpose.js';\nimport jsigs from 'jsonld-signatures';\nimport jsonld from 'jsonld';\nexport const defaultDocumentLoader =\n  jsigs.extendContextLoader(_documentLoader);\nimport * as credentialsContext from 'credentials-context';\n\nconst {AuthenticationProofPurpose} = jsigs.purposes;\nconst {constants: {CREDENTIALS_CONTEXT_V1_URL}} = credentialsContext;\n\nexport {CredentialIssuancePurpose};\n\n// Z and T can be lowercase\n// RFC3339 regex\nexport const dateRegex = new RegExp('^(\\\\d{4})-(0[1-9]|1[0-2])-' +\n    '(0[1-9]|[12][0-9]|3[01])T([01][0-9]|2[0-3]):' +\n    '([0-5][0-9]):([0-5][0-9]|60)' +\n    '(\\\\.[0-9]+)?(Z|(\\\\+|-)([01][0-9]|2[0-3]):' +\n    '([0-5][0-9]))$', 'i');\n\n/**\n * @typedef {object} LinkedDataSignature\n */\n\n/**\n * @typedef {object} Presentation\n */\n\n/**\n * @typedef {object} ProofPurpose\n */\n\n/**\n * @typedef {object} VerifiableCredential\n */\n\n/**\n * @typedef {object} VerifiablePresentation\n */\n\n/**\n * @typedef {object} VerifyPresentationResult\n * @property {boolean} verified - True if verified, false if not.\n * @property {object} presentationResult\n * @property {Array} credentialResults\n * @property {object} error\n */\n\n/**\n * @typedef {object} VerifyCredentialResult\n * @property {boolean} verified - True if verified, false if not.\n * @property {object} statusResult\n * @property {Array} results\n * @property {object} error\n */\n\n/**\n * Issues a verifiable credential (by taking a base credential document,\n * and adding a digital signature to it).\n *\n * @param {object} [options={}] - The options to use.\n *\n * @param {object} options.credential - Base credential document.\n * @param {LinkedDataSignature} options.suite - Signature suite (with private\n *   key material), passed in to sign().\n *\n * @param {ProofPurpose} [options.purpose] - A ProofPurpose. If not specified,\n *   a default purpose will be created.\n *\n * Other optional params passed to `sign()`:\n * @param {object} [options.documentLoader] - A document loader.\n * @param {string|Date} [options.now] - A string representing date time in\n *   ISO 8601 format or an instance of Date. Defaults to current date time.\n *\n * @throws {Error} If missing required properties.\n *\n * @returns {Promise<VerifiableCredential>} Resolves on completion.\n */\nexport async function issue({\n  credential, suite,\n  purpose = new CredentialIssuancePurpose(),\n  documentLoader = defaultDocumentLoader,\n  now\n} = {}) {\n  // check to make sure the `suite` has required params\n  // Note: verificationMethod defaults to publicKey.id, in suite constructor\n  if(!suite) {\n    throw new TypeError('\"suite\" parameter is required for issuing.');\n  }\n  if(!suite.verificationMethod) {\n    throw new TypeError('\"suite.verificationMethod\" property is required.');\n  }\n\n  if(!credential) {\n    throw new TypeError('\"credential\" parameter is required for issuing.');\n  }\n\n  // Set the issuance date to now(), if missing\n  if(!credential.issuanceDate) {\n    const now = (new Date()).toJSON();\n    credential.issuanceDate = `${now.substr(0, now.length - 5)}Z`;\n  }\n\n  // run common credential checks\n  _checkCredential({credential, now});\n\n  return jsigs.sign(credential, {purpose, documentLoader, suite});\n}\n\n/**\n * Verifies a verifiable presentation:\n *   - Checks that the presentation is well-formed\n *   - Checks the proofs (for example, checks digital signatures against the\n *     provided public keys).\n *\n * @param {object} [options={}] - The options to use.\n *\n * @param {VerifiablePresentation} options.presentation - Verifiable\n *   presentation, signed or unsigned, that may contain within it a\n *   verifiable credential.\n *\n * @param {LinkedDataSignature|LinkedDataSignature[]} options.suite - One or\n *   more signature suites that are supported by the caller's use case. This is\n *   an explicit design decision -- the calling code must specify which\n *   signature types (ed25519, RSA, etc) are allowed.\n *   Although it is expected that the secure resolution/fetching of the public\n *   key material (to verify against) is to be handled by the documentLoader,\n *   the suite param can optionally include the key directly.\n *\n * @param {boolean} [options.unsignedPresentation=false] - By default, this\n *   function assumes that a presentation is signed (and will return an error if\n *   a `proof` section is missing). Set this to `true` if you're using an\n *   unsigned presentation.\n *\n * Either pass in a proof purpose,\n * @param {AuthenticationProofPurpose} [options.presentationPurpose] - Optional\n *   proof purpose (a default one will be created if not passed in).\n *\n * or a default purpose will be created with params:\n * @param {string} [options.challenge] - Required if purpose is not passed in.\n * @param {string} [options.controller] - A controller.\n * @param {string} [options.domain] - A domain.\n *\n * @param {Function} [options.documentLoader] - A document loader.\n * @param {Function} [options.checkStatus] - Optional function for checking\n *   credential status if `credentialStatus` is present on the credential.\n * @param {string|Date} [options.now] - A string representing date time in\n *   ISO 8601 format or an instance of Date. Defaults to current date time.\n *\n * @returns {Promise<VerifyPresentationResult>} The verification result.\n */\nexport async function verify(options = {}) {\n  const {presentation} = options;\n  try {\n    if(!presentation) {\n      throw new TypeError(\n        'A \"presentation\" property is required for verifying.');\n    }\n    return _verifyPresentation(options);\n  } catch(error) {\n    return {\n      verified: false,\n      results: [{presentation, verified: false, error}],\n      error\n    };\n  }\n}\n\n/**\n * Verifies a verifiable credential:\n *   - Checks that the credential is well-formed\n *   - Checks the proofs (for example, checks digital signatures against the\n *     provided public keys).\n *\n * @param {object} [options={}] - The options.\n *\n * @param {object} options.credential - Verifiable credential.\n *\n * @param {LinkedDataSignature|LinkedDataSignature[]} options.suite - One or\n *   more signature suites that are supported by the caller's use case. This is\n *   an explicit design decision -- the calling code must specify which\n *   signature types (ed25519, RSA, etc) are allowed.\n *   Although it is expected that the secure resolution/fetching of the public\n *   key material (to verify against) is to be handled by the documentLoader,\n *   the suite param can optionally include the key directly.\n *\n * @param {CredentialIssuancePurpose} [options.purpose] - Optional\n *   proof purpose (a default one will be created if not passed in).\n * @param {Function} [options.documentLoader] - A document loader.\n * @param {Function} [options.checkStatus] - Optional function for checking\n *   credential status if `credentialStatus` is present on the credential.\n * @param {string|Date} [options.now] - A string representing date time in\n *   ISO 8601 format or an instance of Date. Defaults to current date time.\n *\n * @returns {Promise<VerifyCredentialResult>} The verification result.\n */\nexport async function verifyCredential(options = {}) {\n  const {credential} = options;\n  try {\n    if(!credential) {\n      throw new TypeError(\n        'A \"credential\" property is required for verifying.');\n    }\n    return await _verifyCredential(options);\n  } catch(error) {\n    return {\n      verified: false,\n      results: [{credential, verified: false, error}],\n      error\n    };\n  }\n}\n\n/**\n * Verifies a verifiable credential.\n *\n * @private\n * @param {object} [options={}] - The options.\n *\n * @param {object} options.credential - Verifiable credential.\n * @param {LinkedDataSignature|LinkedDataSignature[]} options.suite - See the\n *   definition in the `verify()` docstring, for this param.\n * @param {string|Date} [options.now] - A string representing date time in\n *   ISO 8601 format or an instance of Date. Defaults to current date time.\n *\n * @throws {Error} If required parameters are missing (in `_checkCredential`).\n *\n * @param {CredentialIssuancePurpose} [options.purpose] - A purpose.\n * @param {Function} [options.documentLoader] - A document loader.\n * @param {Function} [options.checkStatus] - Optional function for checking\n *   credential status if `credentialStatus` is present on the credential.\n *\n * @returns {Promise<VerifyCredentialResult>} The verification result.\n */\nasync function _verifyCredential(options = {}) {\n  const {credential, checkStatus, now} = options;\n\n  // run common credential checks\n  _checkCredential({credential, now});\n\n  // if credential status is provided, a `checkStatus` function must be given\n  if(credential.credentialStatus && typeof options.checkStatus !== 'function') {\n    throw new TypeError(\n      'A \"checkStatus\" function must be given to verify credentials with ' +\n      '\"credentialStatus\".');\n  }\n\n  const documentLoader = options.documentLoader || defaultDocumentLoader;\n\n  const {controller} = options;\n  const purpose = options.purpose || new CredentialIssuancePurpose({\n    controller\n  });\n\n  const result = await jsigs.verify(\n    credential, {...options, purpose, documentLoader});\n\n  // if verification has already failed, skip status check\n  if(!result.verified) {\n    return result;\n  }\n\n  if(credential.credentialStatus) {\n    result.statusResult = await checkStatus(options);\n    if(!result.statusResult.verified) {\n      result.verified = false;\n    }\n  }\n\n  return result;\n}\n\n/**\n * Creates an unsigned presentation from a given verifiable credential.\n *\n * @param {object} options - Options to use.\n * @param {object|Array<object>} [options.verifiableCredential] - One or more\n *   verifiable credential.\n * @param {string} [options.id] - Optional VP id.\n * @param {string} [options.holder] - Optional presentation holder url.\n * @param {string|Date} [options.now] - A string representing date time in\n *   ISO 8601 format or an instance of Date. Defaults to current date time.\n *\n * @throws {TypeError} If verifiableCredential param is missing.\n * @throws {Error} If the credential (or the presentation params) are missing\n *   required properties.\n *\n * @returns {Presentation} The credential wrapped inside of a\n *   VerifiablePresentation.\n */\nexport function createPresentation({\n  verifiableCredential, id, holder, now\n} = {}) {\n  const presentation = {\n    '@context': [CREDENTIALS_CONTEXT_V1_URL],\n    type: ['VerifiablePresentation']\n  };\n  if(verifiableCredential) {\n    const credentials = [].concat(verifiableCredential);\n    // ensure all credentials are valid\n    for(const credential of credentials) {\n      _checkCredential({credential, now});\n    }\n    presentation.verifiableCredential = credentials;\n  }\n  if(id) {\n    presentation.id = id;\n  }\n  if(holder) {\n    presentation.holder = holder;\n  }\n\n  _checkPresentation(presentation);\n\n  return presentation;\n}\n\n/**\n * Signs a given presentation.\n *\n * @param {object} [options={}] - Options to use.\n *\n * Required:\n * @param {Presentation} options.presentation - A presentation.\n * @param {LinkedDataSignature} options.suite - passed in to sign()\n *\n * Either pass in a ProofPurpose, or a default one will be created with params:\n * @param {ProofPurpose} [options.purpose] - A ProofPurpose. If not specified,\n *   a default purpose will be created with the domain and challenge options.\n *\n * @param {string} [options.domain] - A domain.\n * @param {string} options.challenge - A required challenge.\n *\n * @param {Function} [options.documentLoader] - A document loader.\n *\n * @returns {Promise<{VerifiablePresentation}>} A VerifiablePresentation with\n *   a proof.\n */\nexport async function signPresentation(options = {}) {\n  const {presentation, domain, challenge} = options;\n  const purpose = options.purpose || new AuthenticationProofPurpose({\n    domain,\n    challenge\n  });\n\n  const documentLoader = options.documentLoader || defaultDocumentLoader;\n\n  return jsigs.sign(presentation, {...options, purpose, documentLoader});\n}\n\n/**\n * Verifies that the VerifiablePresentation is well formed, and checks the\n * proof signature if it's present. Also verifies all the VerifiableCredentials\n * that are present in the presentation, if any.\n *\n * @param {object} [options={}] - The options.\n * @param {VerifiablePresentation} options.presentation - A\n *   VerifiablePresentation.\n *\n * @param {LinkedDataSignature|LinkedDataSignature[]} options.suite - See the\n *   definition in the `verify()` docstring, for this param.\n *\n * @param {boolean} [options.unsignedPresentation=false] - By default, this\n *   function assumes that a presentation is signed (and will return an error if\n *   a `proof` section is missing). Set this to `true` if you're using an\n *   unsigned presentation.\n *\n * Either pass in a proof purpose,\n * @param {AuthenticationProofPurpose} [options.presentationPurpose] - A\n *   ProofPurpose. If not specified, a default purpose will be created with\n *   the challenge, controller, and domain options.\n *\n * @param {string} [options.challenge] - A challenge. Required if purpose is\n *   not passed in.\n * @param {string} [options.controller] - A controller. Required if purpose is\n *   not passed in.\n * @param {string} [options.domain] - A domain. Required if purpose is not\n *   passed in.\n *\n * @param {Function} [options.documentLoader] - A document loader.\n * @param {Function} [options.checkStatus] - Optional function for checking\n *   credential status if `credentialStatus` is present on the credential.\n * @param {string|Date} [options.now] - A string representing date time in\n *   ISO 8601 format or an instance of Date. Defaults to current date time.\n *\n * @throws {Error} If presentation is missing required params.\n *\n * @returns {Promise<VerifyPresentationResult>} The verification result.\n */\nasync function _verifyPresentation(options = {}) {\n  const {presentation, unsignedPresentation} = options;\n\n  _checkPresentation(presentation);\n\n  const documentLoader = options.documentLoader || defaultDocumentLoader;\n\n  // FIXME: verify presentation first, then each individual credential\n  // only if that proof is verified\n\n  // if verifiableCredentials are present, verify them, individually\n  let credentialResults;\n  let verified = true;\n  const credentials = jsonld.getValues(presentation, 'verifiableCredential');\n  if(credentials.length > 0) {\n    // verify every credential in `verifiableCredential`\n    credentialResults = await Promise.all(credentials.map(credential => {\n      return verifyCredential({...options, credential, documentLoader});\n    }));\n\n    for(const [i, credentialResult] of credentialResults.entries()) {\n      credentialResult.credentialId = credentials[i].id;\n    }\n\n    const allCredentialsVerified = credentialResults.every(r => r.verified);\n    if(!allCredentialsVerified) {\n      verified = false;\n    }\n  }\n\n  if(unsignedPresentation) {\n    // No need to verify the proof section of this presentation\n    return {verified, results: [presentation], credentialResults};\n  }\n\n  const {controller, domain, challenge} = options;\n  if(!options.presentationPurpose && !challenge) {\n    throw new Error(\n      'A \"challenge\" param is required for AuthenticationProofPurpose.');\n  }\n\n  const purpose = options.presentationPurpose ||\n    new AuthenticationProofPurpose({controller, domain, challenge});\n\n  const presentationResult = await jsigs.verify(\n    presentation, {...options, purpose, documentLoader});\n\n  return {\n    presentationResult,\n    verified: verified && presentationResult.verified,\n    credentialResults,\n    error: presentationResult.error\n  };\n}\n\n/**\n * @param {string|object} obj - Either an object with an id property\n *   or a string that is an id.\n * @returns {string|undefined} Either an id or undefined.\n * @private\n *\n */\nfunction _getId(obj) {\n  if(typeof obj === 'string') {\n    return obj;\n  }\n\n  if(!('id' in obj)) {\n    return;\n  }\n\n  return obj.id;\n}\n\n// export for testing\n/**\n * @param {object} presentation - An object that could be a presentation.\n *\n * @throws {Error}\n * @private\n */\nexport function _checkPresentation(presentation) {\n  // normalize to an array to allow the common case of context being a string\n  const context = Array.isArray(presentation['@context']) ?\n    presentation['@context'] : [presentation['@context']];\n\n  // ensure first context is 'https://www.w3.org/2018/credentials/v1'\n  if(context[0] !== CREDENTIALS_CONTEXT_V1_URL) {\n    throw new Error(\n      `\"${CREDENTIALS_CONTEXT_V1_URL}\" needs to be first in the ` +\n      'list of contexts.');\n  }\n\n  const types = jsonld.getValues(presentation, 'type');\n\n  // check type presence\n  if(!types.includes('VerifiablePresentation')) {\n    throw new Error('\"type\" must include \"VerifiablePresentation\".');\n  }\n}\n\n// export for testing\n/**\n * @param {object} options - The options.\n * @param {object} options.credential - An object that could be a\n *   VerifiableCredential.\n * @param {string|Date} [options.now] - A string representing date time in\n *   ISO 8601 format or an instance of Date. Defaults to current date time.\n *\n * @throws {Error}\n * @private\n */\nexport function _checkCredential({credential, now = new Date()}) {\n  if(typeof now === 'string') {\n    now = new Date(now);\n  }\n  // ensure first context is 'https://www.w3.org/2018/credentials/v1'\n  if(credential['@context'][0] !== CREDENTIALS_CONTEXT_V1_URL) {\n    throw new Error(\n      `\"${CREDENTIALS_CONTEXT_V1_URL}\" needs to be first in the ` +\n      'list of contexts.');\n  }\n\n  // check type presence and cardinality\n  if(!credential.type) {\n    throw new Error('\"type\" property is required.');\n  }\n\n  if(!jsonld.getValues(credential, 'type').includes('VerifiableCredential')) {\n    throw new Error('\"type\" must include `VerifiableCredential`.');\n  }\n\n  if(!credential.credentialSubject) {\n    throw new Error('\"credentialSubject\" property is required.');\n  }\n\n  // If credentialSubject.id is present and is not a URI, reject it\n  if(credential.credentialSubject.id) {\n    _validateUriId({\n      id: credential.credentialSubject.id, propertyName: 'credentialSubject.id'\n    });\n  }\n\n  if(!credential.issuer) {\n    throw new Error('\"issuer\" property is required.');\n  }\n\n  // check issuanceDate cardinality\n  if(jsonld.getValues(credential, 'issuanceDate').length > 1) {\n    throw new Error('\"issuanceDate\" property can only have one value.');\n  }\n\n  // check issued is a date\n  if(!credential.issuanceDate) {\n    throw new Error('\"issuanceDate\" property is required.');\n  }\n\n  if('issuanceDate' in credential) {\n    let {issuanceDate} = credential;\n    if(!dateRegex.test(issuanceDate)) {\n      throw new Error(`\"issuanceDate\" must be a valid date: ${issuanceDate}`);\n    }\n    // check if `now` is before `issuanceDate`\n    issuanceDate = new Date(issuanceDate);\n    if(now < issuanceDate) {\n      throw new Error(\n        `The current date time (${now.toISOString()}) is before the ` +\n        `\"issuanceDate\" (${issuanceDate.toISOString()}).`);\n    }\n  }\n\n  // check issuer cardinality\n  if(jsonld.getValues(credential, 'issuer').length > 1) {\n    throw new Error('\"issuer\" property can only have one value.');\n  }\n\n  // check issuer is a URL\n  if('issuer' in credential) {\n    const issuer = _getId(credential.issuer);\n    if(!issuer) {\n      throw new Error(`\"issuer\" id is required.`);\n    }\n    _validateUriId({id: issuer, propertyName: 'issuer'});\n  }\n\n  if('credentialStatus' in credential) {\n    if(!credential.credentialStatus.id) {\n      throw new Error('\"credentialStatus\" must include an id.');\n    }\n    if(!credential.credentialStatus.type) {\n      throw new Error('\"credentialStatus\" must include a type.');\n    }\n  }\n\n  // check evidences are URLs\n  jsonld.getValues(credential, 'evidence').forEach(evidence => {\n    const evidenceId = _getId(evidence);\n    if(evidenceId) {\n      _validateUriId({id: evidenceId, propertyName: 'evidence'});\n    }\n  });\n\n  if('expirationDate' in credential) {\n    const {expirationDate} = credential;\n    // check if `expirationDate` property is a date\n    if(!dateRegex.test(expirationDate)) {\n      throw new Error(\n        `\"expirationDate\" must be a valid date: ${expirationDate}`);\n    }\n    // check if `now` is after `expirationDate`\n    if(now > new Date(expirationDate)) {\n      throw new Error('Credential has expired.');\n    }\n  }\n}\n\nfunction _validateUriId({id, propertyName}) {\n  let parsed;\n  try {\n    parsed = new URL(id);\n  } catch(e) {\n    const error = new TypeError(`\"${propertyName}\" must be a URI: \"${id}\".`);\n    error.cause = e;\n    throw error;\n  }\n\n  if(!parsed.protocol) {\n    throw new TypeError(`\"${propertyName}\" must be a URI: \"${id}\".`);\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}