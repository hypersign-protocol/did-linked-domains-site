{"ast":null,"code":"\"use strict\";\n\n/**\n * Copyright (c) 2023, Hypermine Pvt. Ltd.\n * All rights reserved.\n * Author: Hypermine Core Team\n */\nrequire(\"core-js/modules/es.array.push.js\");\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst schema_1 = require(\"../../libs/generated/ssi/schema\");\nconst schemaRPC_1 = require(\"./schemaRPC\");\nconst constants = __importStar(require(\"../constants\"));\nconst utils_1 = __importDefault(require(\"../utils\"));\nconst ed25519 = require('@stablelib/ed25519');\nclass HyperSignSchema {\n  constructor(params = {}) {\n    const {\n      namespace,\n      offlineSigner,\n      nodeRpcEndpoint,\n      nodeRestEndpoint\n    } = params;\n    const nodeRPCEp = nodeRpcEndpoint ? nodeRpcEndpoint : 'MAIN';\n    const nodeRestEp = nodeRestEndpoint ? nodeRestEndpoint : '';\n    this.schemaRpc = new schemaRPC_1.SchemaRpc({\n      offlineSigner,\n      nodeRpcEndpoint: nodeRPCEp,\n      nodeRestEndpoint: nodeRestEp\n    });\n    this.namespace = namespace && namespace != '' ? namespace : '';\n    this.type = constants.SCHEMA.SCHEMA_TYPE, this.modelVersion = '1.0', this.id = '', this.name = '', this.author = '', this.authored = '';\n    this.schema = {\n      schema: '',\n      description: '',\n      type: '',\n      properties: '',\n      required: [],\n      additionalProperties: false\n    };\n  }\n  // Ref:\n  _getSchemaId() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const b = yield utils_1.default.getUUID();\n      // ID Structure ->  sch:<method>:<namespace>:<method-specific-id>:<version>\n      let id;\n      if (this.namespace && this.namespace != '') {\n        id = `${constants.SCHEMA.SCHEME}:${constants.SCHEMA.METHOD}:${this.namespace}:${b}:${this.modelVersion}`;\n      } else {\n        id = `${constants.SCHEMA.SCHEME}:${constants.SCHEMA.METHOD}:${b}:${this.modelVersion}`;\n      }\n      return id;\n    });\n  }\n  _getDateTime() {\n    return new Date(new Date().getTime() - 100000).toISOString().slice(0, -5) + 'Z';\n  }\n  /**\n   * Initialise the offlinesigner to interact with Hypersign blockchain\n   */\n  init() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.schemaRpc) {\n        throw new Error('HID-SSI-SDK:: Error: HID-SSI-SDK:: Error: HypersignSchema class is not instantiated with Offlinesigner or have not been initilized');\n      }\n      yield this.schemaRpc.init();\n    });\n  }\n  /**\n   * Generates a new schema doc without proof\n   * @params\n   *  - params.name                 : Name of the schema\n   *  - params.description          : Optional - Description of the schema\n   *  - params.author               : DID of the author\n   *  - params.fields               : Schema fields of type ISchemaFields\n   *  - params.additionalProperties : If additionalProperties can be added, boolean\n   * @returns {Promise<SchemaDocument>} SchemaDocument object\n   */\n  generate(params) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!params.author) throw new Error('HID-SSI-SDK:: Error: Author must be passed');\n      this.id = yield this._getSchemaId();\n      this.name = params.name;\n      this.author = params.author;\n      this.authored = this._getDateTime();\n      this.schema = {\n        schema: constants.SCHEMA.SCHEMA_JSON,\n        description: params.description ? params.description : '',\n        type: 'object',\n        properties: '',\n        required: [],\n        additionalProperties: params.additionalProperties\n      };\n      const t = {};\n      if (params.fields && params.fields.length > 0) {\n        params.fields.forEach(prop => {\n          const schemaPropsObj = {};\n          schemaPropsObj.propName = prop.name;\n          schemaPropsObj.val = {};\n          schemaPropsObj.val.type = prop.type;\n          if (prop.format) schemaPropsObj.val.format = prop.format;\n          t[schemaPropsObj.propName] = schemaPropsObj.val;\n          if (prop.isRequired) {\n            this.schema.required.push(prop.name);\n          }\n        });\n        this.schema.properties = JSON.stringify(t);\n      }\n      return {\n        type: this.type,\n        modelVersion: this.modelVersion,\n        id: this.id,\n        name: this.name,\n        author: this.author,\n        authored: this.authored,\n        schema: this.schema\n      };\n    });\n  }\n  /**\n   * Signs a schema document and attaches proof\n   * @params\n   *  - params.schema               : The schema document without proof\n   *  - params.privateKeyMultibase  : Private Key to sign the doc\n   *  - params.verificationMethodId : VerificationMethodId of the document\n   * @returns {Promise<Schema>} Schema with proof\n   */\n  sign(params) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!params.privateKeyMultibase) throw new Error('HID-SSI-SDK:: Error: params.privateKeyMultibase must be passed');\n      if (!params.verificationMethodId) throw new Error('HID-SSI-SDK:: Error: params.verificationMethodId must be passed');\n      if (!params.schema) throw new Error('HID-SSI-SDK:: Error: Schema must be passed');\n      const {\n        privateKeyMultibase: privateKeyMultibaseConverted\n      } = utils_1.default.convertEd25519verificationkey2020toStableLibKeysInto({\n        privKey: params.privateKeyMultibase\n      });\n      const schemaDoc = params.schema;\n      const dataBytes = (yield schema_1.Schema.encode(schemaDoc)).finish();\n      const signed = ed25519.sign(privateKeyMultibaseConverted, dataBytes);\n      const proof = {\n        type: constants.SCHEMA.SIGNATURE_TYPE,\n        created: this._getDateTime(),\n        verificationMethod: params.verificationMethodId,\n        proofPurpose: constants.SCHEMA.PROOF_PURPOSE,\n        proofValue: Buffer.from(signed).toString('base64')\n      };\n      schemaDoc.proof = {};\n      Object.assign(schemaDoc.proof, Object.assign({}, proof));\n      return schemaDoc;\n    });\n  }\n  /**\n   * Register a schema Document in Hypersign blockchain - an onchain activity\n   * @params\n   *  - params.schema               : The schema document with schemaProof\n   * @returns {Promise<object>} Result of the registration\n   */\n  register(params) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!params.schema) throw new Error('HID-SSI-SDK:: Error: schema must be passed');\n      if (!params.schema.proof) throw new Error('HID-SSI-SDK:: Error: schema.proof must be passed');\n      if (!params.schema.proof.created) throw new Error('HID-SSI-SDK:: Error: schema.proof must Contain created');\n      if (!params.schema.proof.proofPurpose) throw new Error('HID-SSI-SDK:: Error: schema.proof must Contain proofPurpose');\n      if (!params.schema.proof.proofValue) throw new Error('HID-SSI-SDK:: Error: schema.proof must Contain proofValue');\n      if (!params.schema.proof.type) throw new Error('HID-SSI-SDK:: Error: schema.proof must Contain type');\n      if (!params.schema.proof.verificationMethod) throw new Error('HID-SSI-SDK:: Error: schema.proof must Contain verificationMethod');\n      if (!this.schemaRpc) {\n        throw new Error('HID-SSI-SDK:: Error: HypersignSchema class is not instantiated with Offlinesigner or have not been initilized');\n      }\n      return this.schemaRpc.createSchema(params.schema, params.schema.proof);\n    });\n  }\n  /**\n   * Resolves a schema document with schemId from Hypersign blockchain - an onchain activity\n   * @params\n   *  - params.schemaId             : Id of the schema document\n   * @returns {Promise<Schema>} Returns schema document\n   */\n  resolve(params) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!params.schemaId) throw new Error('HID-SSI-SDK:: Error: SchemaId must be passed');\n      if (!this.schemaRpc) {\n        throw new Error('HID-SSI-SDK:: Error: HypersignSchema class is not instantiated with Offlinesigner or have not been initilized');\n      }\n      const schemaArr = yield this.schemaRpc.resolveSchema(params.schemaId);\n      if (!schemaArr || schemaArr.length < 0) {\n        throw new Error('HID-SSI-SDK:: Error: No schema found, id = ' + params.schemaId);\n      }\n      const schema = schemaArr[0];\n      return schema;\n    });\n  }\n}\nexports.default = HyperSignSchema;","map":{"version":3,"names":["require","__createBinding","Object","create","o","m","k","k2","undefined","desc","getOwnPropertyDescriptor","__esModule","writable","configurable","enumerable","get","defineProperty","__setModuleDefault","v","value","__importStar","mod","result","prototype","hasOwnProperty","call","__awaiter","thisArg","_arguments","P","generator","adopt","resolve","Promise","reject","fulfilled","step","next","e","rejected","done","then","apply","__importDefault","exports","schema_1","schemaRPC_1","constants","utils_1","ed25519","HyperSignSchema","constructor","params","namespace","offlineSigner","nodeRpcEndpoint","nodeRestEndpoint","nodeRPCEp","nodeRestEp","schemaRpc","SchemaRpc","type","SCHEMA","SCHEMA_TYPE","modelVersion","id","name","author","authored","schema","description","properties","required","additionalProperties","_getSchemaId","b","default","getUUID","SCHEME","METHOD","_getDateTime","Date","getTime","toISOString","slice","init","Error","generate","SCHEMA_JSON","t","fields","length","forEach","prop","schemaPropsObj","propName","val","format","isRequired","push","JSON","stringify","sign","privateKeyMultibase","verificationMethodId","privateKeyMultibaseConverted","convertEd25519verificationkey2020toStableLibKeysInto","privKey","schemaDoc","dataBytes","Schema","encode","finish","signed","proof","SIGNATURE_TYPE","created","verificationMethod","proofPurpose","PROOF_PURPOSE","proofValue","Buffer","from","toString","assign","register","createSchema","schemaId","schemaArr","resolveSchema"],"sources":["/home/pratap/hid-ssi-js-sdk/build/src/schema/schema.js"],"sourcesContent":["\"use strict\";\n/**\n * Copyright (c) 2023, Hypermine Pvt. Ltd.\n * All rights reserved.\n * Author: Hypermine Core Team\n */\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst schema_1 = require(\"../../libs/generated/ssi/schema\");\nconst schemaRPC_1 = require(\"./schemaRPC\");\nconst constants = __importStar(require(\"../constants\"));\nconst utils_1 = __importDefault(require(\"../utils\"));\nconst ed25519 = require('@stablelib/ed25519');\nclass HyperSignSchema {\n    constructor(params = {}) {\n        const { namespace, offlineSigner, nodeRpcEndpoint, nodeRestEndpoint } = params;\n        const nodeRPCEp = nodeRpcEndpoint ? nodeRpcEndpoint : 'MAIN';\n        const nodeRestEp = nodeRestEndpoint ? nodeRestEndpoint : '';\n        this.schemaRpc = new schemaRPC_1.SchemaRpc({ offlineSigner, nodeRpcEndpoint: nodeRPCEp, nodeRestEndpoint: nodeRestEp });\n        this.namespace = namespace && namespace != '' ? namespace : '';\n        (this.type = constants.SCHEMA.SCHEMA_TYPE),\n            (this.modelVersion = '1.0'),\n            (this.id = ''),\n            (this.name = ''),\n            (this.author = ''),\n            (this.authored = '');\n        this.schema = {\n            schema: '',\n            description: '',\n            type: '',\n            properties: '',\n            required: [],\n            additionalProperties: false,\n        };\n    }\n    // Ref:\n    _getSchemaId() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const b = yield utils_1.default.getUUID();\n            // ID Structure ->  sch:<method>:<namespace>:<method-specific-id>:<version>\n            let id;\n            if (this.namespace && this.namespace != '') {\n                id = `${constants.SCHEMA.SCHEME}:${constants.SCHEMA.METHOD}:${this.namespace}:${b}:${this.modelVersion}`;\n            }\n            else {\n                id = `${constants.SCHEMA.SCHEME}:${constants.SCHEMA.METHOD}:${b}:${this.modelVersion}`;\n            }\n            return id;\n        });\n    }\n    _getDateTime() {\n        return new Date(new Date().getTime() - 100000).toISOString().slice(0, -5) + 'Z';\n    }\n    /**\n     * Initialise the offlinesigner to interact with Hypersign blockchain\n     */\n    init() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!this.schemaRpc) {\n                throw new Error('HID-SSI-SDK:: Error: HID-SSI-SDK:: Error: HypersignSchema class is not instantiated with Offlinesigner or have not been initilized');\n            }\n            yield this.schemaRpc.init();\n        });\n    }\n    /**\n     * Generates a new schema doc without proof\n     * @params\n     *  - params.name                 : Name of the schema\n     *  - params.description          : Optional - Description of the schema\n     *  - params.author               : DID of the author\n     *  - params.fields               : Schema fields of type ISchemaFields\n     *  - params.additionalProperties : If additionalProperties can be added, boolean\n     * @returns {Promise<SchemaDocument>} SchemaDocument object\n     */\n    generate(params) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!params.author)\n                throw new Error('HID-SSI-SDK:: Error: Author must be passed');\n            this.id = yield this._getSchemaId();\n            this.name = params.name;\n            this.author = params.author;\n            this.authored = this._getDateTime();\n            this.schema = {\n                schema: constants.SCHEMA.SCHEMA_JSON,\n                description: params.description ? params.description : '',\n                type: 'object',\n                properties: '',\n                required: [],\n                additionalProperties: params.additionalProperties,\n            };\n            const t = {};\n            if (params.fields && params.fields.length > 0) {\n                params.fields.forEach((prop) => {\n                    const schemaPropsObj = {};\n                    schemaPropsObj.propName = prop.name;\n                    schemaPropsObj.val = {};\n                    schemaPropsObj.val.type = prop.type;\n                    if (prop.format)\n                        schemaPropsObj.val.format = prop.format;\n                    t[schemaPropsObj.propName] = schemaPropsObj.val;\n                    if (prop.isRequired) {\n                        this.schema.required.push(prop.name);\n                    }\n                });\n                this.schema.properties = JSON.stringify(t);\n            }\n            return {\n                type: this.type,\n                modelVersion: this.modelVersion,\n                id: this.id,\n                name: this.name,\n                author: this.author,\n                authored: this.authored,\n                schema: this.schema,\n            };\n        });\n    }\n    /**\n     * Signs a schema document and attaches proof\n     * @params\n     *  - params.schema               : The schema document without proof\n     *  - params.privateKeyMultibase  : Private Key to sign the doc\n     *  - params.verificationMethodId : VerificationMethodId of the document\n     * @returns {Promise<Schema>} Schema with proof\n     */\n    sign(params) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!params.privateKeyMultibase)\n                throw new Error('HID-SSI-SDK:: Error: params.privateKeyMultibase must be passed');\n            if (!params.verificationMethodId)\n                throw new Error('HID-SSI-SDK:: Error: params.verificationMethodId must be passed');\n            if (!params.schema)\n                throw new Error('HID-SSI-SDK:: Error: Schema must be passed');\n            const { privateKeyMultibase: privateKeyMultibaseConverted } = utils_1.default.convertEd25519verificationkey2020toStableLibKeysInto({\n                privKey: params.privateKeyMultibase,\n            });\n            const schemaDoc = params.schema;\n            const dataBytes = (yield schema_1.Schema.encode(schemaDoc)).finish();\n            const signed = ed25519.sign(privateKeyMultibaseConverted, dataBytes);\n            const proof = {\n                type: constants.SCHEMA.SIGNATURE_TYPE,\n                created: this._getDateTime(),\n                verificationMethod: params.verificationMethodId,\n                proofPurpose: constants.SCHEMA.PROOF_PURPOSE,\n                proofValue: Buffer.from(signed).toString('base64'),\n            };\n            schemaDoc.proof = {};\n            Object.assign(schemaDoc.proof, Object.assign({}, proof));\n            return schemaDoc;\n        });\n    }\n    /**\n     * Register a schema Document in Hypersign blockchain - an onchain activity\n     * @params\n     *  - params.schema               : The schema document with schemaProof\n     * @returns {Promise<object>} Result of the registration\n     */\n    register(params) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!params.schema)\n                throw new Error('HID-SSI-SDK:: Error: schema must be passed');\n            if (!params.schema.proof)\n                throw new Error('HID-SSI-SDK:: Error: schema.proof must be passed');\n            if (!params.schema.proof.created)\n                throw new Error('HID-SSI-SDK:: Error: schema.proof must Contain created');\n            if (!params.schema.proof.proofPurpose)\n                throw new Error('HID-SSI-SDK:: Error: schema.proof must Contain proofPurpose');\n            if (!params.schema.proof.proofValue)\n                throw new Error('HID-SSI-SDK:: Error: schema.proof must Contain proofValue');\n            if (!params.schema.proof.type)\n                throw new Error('HID-SSI-SDK:: Error: schema.proof must Contain type');\n            if (!params.schema.proof.verificationMethod)\n                throw new Error('HID-SSI-SDK:: Error: schema.proof must Contain verificationMethod');\n            if (!this.schemaRpc) {\n                throw new Error('HID-SSI-SDK:: Error: HypersignSchema class is not instantiated with Offlinesigner or have not been initilized');\n            }\n            return this.schemaRpc.createSchema(params.schema, params.schema.proof);\n        });\n    }\n    /**\n     * Resolves a schema document with schemId from Hypersign blockchain - an onchain activity\n     * @params\n     *  - params.schemaId             : Id of the schema document\n     * @returns {Promise<Schema>} Returns schema document\n     */\n    resolve(params) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!params.schemaId)\n                throw new Error('HID-SSI-SDK:: Error: SchemaId must be passed');\n            if (!this.schemaRpc) {\n                throw new Error('HID-SSI-SDK:: Error: HypersignSchema class is not instantiated with Offlinesigner or have not been initilized');\n            }\n            const schemaArr = yield this.schemaRpc.resolveSchema(params.schemaId);\n            if (!schemaArr || schemaArr.length < 0) {\n                throw new Error('HID-SSI-SDK:: Error: No schema found, id = ' + params.schemaId);\n            }\n            const schema = schemaArr[0];\n            return schema;\n        });\n    }\n}\nexports.default = HyperSignSchema;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}