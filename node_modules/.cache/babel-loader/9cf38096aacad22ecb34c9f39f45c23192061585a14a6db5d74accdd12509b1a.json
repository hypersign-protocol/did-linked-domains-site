{"ast":null,"code":"/*!\n * Copyright (c) 2017-2023 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n\nconst constants = require('../constants');\nconst jsonld = require('jsonld');\nconst util = require('../util');\nconst {\n  sha256digest\n} = require('../sha256digest');\nconst LinkedDataProof = require('./LinkedDataProof');\nmodule.exports = class LinkedDataSignature extends LinkedDataProof {\n  /**\n   * Parent class from which the various LinkDataSignature suites (such as\n   * `Ed25519Signature2020`) inherit.\n   * NOTE: Developers are never expected to use this class directly, but to\n   * only work with individual suites.\n   *\n   * @param {object} options - Options hashmap.\n   * @param {string} options.type - Suite name, provided by subclass.\n   * @typedef LDKeyPair\n   * @param {LDKeyPair} LDKeyClass - The crypto-ld key class that this suite\n   *   will use to sign/verify signatures. Provided by subclass. Used\n   *   during the `verifySignature` operation, to create an instance (containing\n   *   a `verifier()` property) of a public key fetched via a `documentLoader`.\n   *\n   * @param {string} contextUrl - JSON-LD context URL that corresponds to this\n   *   signature suite. Provided by subclass. Used for enforcing suite context\n   *   during the `sign()` operation.\n   *\n   * For `sign()` operations, either a `key` OR a `signer` is required.\n   * For `verify()` operations, you can pass in a verifier (from KMS), or\n   * the public key will be fetched via documentLoader.\n   *\n   * @param {object} [options.key] - An optional key object (containing an\n   *   `id` property, and either `signer` or `verifier`, depending on the\n   *   intended operation. Useful for when the application is managing keys\n   *   itself (when using a KMS, you never have access to the private key,\n   *   and so should use the `signer` param instead).\n   *\n   * @param {{sign: Function, id: string}} [options.signer] - Signer object\n   *   that has two properties: an async `sign()` method, and an `id`. This is\n   *   useful when interfacing with a KMS (since you don't get access to the\n   *   private key and its `signer`, the KMS client gives you only the signer\n   *   object to use).\n   *\n   * @param {{verify: Function, id: string}} [options.verifier] - Verifier\n   *   object that has two properties: an async `verify()` method, and an `id`.\n   *   Useful when working with a KMS-provided verifier.\n   *\n   * Advanced optional parameters and overrides:\n   *\n   * @param {object} [options.proof] - A JSON-LD document with options to use\n   *   for the `proof` node (e.g. any other custom fields can be provided here\n   *   using a context different from security-v2). If not provided, this is\n   *   constructed during signing.\n   * @param {string|Date} [options.date] - Signing date to use (otherwise\n   *   defaults to `now()`).\n   * @param {boolean} [options.useNativeCanonize] - Whether to use a native\n   *   canonize algorithm.\n   * @param {object} [options.canonizeOptions] - Options to pass to\n   *   canonize algorithm.\n   */\n  constructor({\n    type,\n    proof,\n    LDKeyClass,\n    date,\n    key,\n    signer,\n    verifier,\n    useNativeCanonize,\n    canonizeOptions,\n    contextUrl\n  } = {}) {\n    super({\n      type\n    });\n    this.LDKeyClass = LDKeyClass;\n    this.contextUrl = contextUrl;\n    this.proof = proof;\n    const vm = _processSignatureParams({\n      key,\n      signer,\n      verifier\n    });\n    this.verificationMethod = vm.verificationMethod;\n    this.key = vm.key;\n    this.signer = vm.signer;\n    this.verifier = vm.verifier;\n    this.canonizeOptions = canonizeOptions;\n    if (date) {\n      this.date = new Date(date);\n      if (isNaN(this.date)) {\n        throw TypeError(`\"date\" \"${date}\" is not a valid date.`);\n      }\n    }\n    this.useNativeCanonize = useNativeCanonize;\n    this._hashCache = null;\n  }\n\n  /**\n   * @param {object} options - The options to use.\n   * @param {object} options.document - The document to be signed.\n   * @param {ProofPurpose} options.purpose - The proof purpose instance.\n   * @param {Array} options.proofSet - Any existing proof set.\n   * @param {function} options.documentLoader - The document loader to use.\n   * @param {function} options.expansionMap - NOT SUPPORTED; do not use.\n   *\n   * @returns {Promise<object>} Resolves with the created proof object.\n   */\n  async createProof({\n    document,\n    purpose,\n    proofSet,\n    documentLoader,\n    expansionMap\n  }) {\n    if (expansionMap) {\n      throw new Error('\"expansionMap\" not supported.');\n    }\n\n    // build proof (currently known as `signature options` in spec)\n    let proof;\n    if (this.proof) {\n      // shallow copy\n      proof = {\n        ...this.proof\n      };\n    } else {\n      // create proof JSON-LD document\n      proof = {};\n    }\n\n    // ensure proof type is set\n    proof.type = this.type;\n\n    // set default `now` date if not given in `proof` or `options`\n    let date = this.date;\n    if (proof.created === undefined && date === undefined) {\n      date = new Date();\n    }\n\n    // ensure date is in string format\n    if (date && typeof date !== 'string') {\n      date = util.w3cDate(date);\n    }\n\n    // add API overrides\n    if (date) {\n      proof.created = date;\n    }\n    proof.verificationMethod = this.verificationMethod;\n\n    // add any extensions to proof (mostly for legacy support)\n    proof = await this.updateProof({\n      document,\n      proof,\n      proofSet,\n      purpose,\n      documentLoader\n    });\n\n    // allow purpose to update the proof; the `proof` is in the\n    // SECURITY_CONTEXT_URL `@context` -- therefore the `purpose` must\n    // ensure any added fields are also represented in that same `@context`\n    proof = await purpose.update(proof, {\n      document,\n      suite: this,\n      documentLoader\n    });\n\n    // create data to sign\n    const verifyData = await this.createVerifyData({\n      document,\n      proof,\n      proofSet,\n      documentLoader\n    });\n\n    // sign data\n    proof = await this.sign({\n      verifyData,\n      document,\n      proof,\n      documentLoader\n    });\n    return proof;\n  }\n\n  /**\n   * @param {object} options - The options to use.\n   * @param {object} options.proof - The proof to be updated.\n   * @param {Array} options.proofSet - Any existing proof set.\n   * @param {function} options.expansionMap - NOT SUPPORTED; do not use.\n   *\n   * @returns {Promise<object>} Resolves with the created proof object.\n   */\n  async updateProof({\n    proof,\n    expansionMap\n  }) {\n    if (expansionMap) {\n      throw new Error('\"expansionMap\" not supported.');\n    }\n    // extending classes may do more\n    return proof;\n  }\n\n  /**\n   * @param {object} options - The options to use.\n   * @param {object} options.proof - The proof to be verified.\n   * @param {object} options.document - The document the proof applies to.\n   * @param {ProofPurpose} options.purpose - The proof purpose instance.\n   * @param {Array} options.proofSet - Any existing proof set.\n   * @param {function} options.documentLoader - The document loader to use.\n   * @param {function} options.expansionMap - NOT SUPPORTED; do not use.\n   *\n   * @returns {Promise<{object}>} Resolves with the verification result.\n   */\n  async verifyProof({\n    proof,\n    document,\n    proofSet,\n    documentLoader,\n    expansionMap\n  }) {\n    if (expansionMap) {\n      throw new Error('\"expansionMap\" not supported.');\n    }\n    try {\n      // create data to verify\n      const verifyData = await this.createVerifyData({\n        document,\n        proof,\n        proofSet,\n        documentLoader,\n        expansionMap\n      });\n\n      // fetch verification method\n      const verificationMethod = await this.getVerificationMethod({\n        proof,\n        document,\n        documentLoader,\n        expansionMap\n      });\n\n      // verify signature on data\n      const verified = await this.verifySignature({\n        verifyData,\n        verificationMethod,\n        document,\n        proof,\n        documentLoader,\n        expansionMap\n      });\n      if (!verified) {\n        throw new Error('Invalid signature.');\n      }\n      return {\n        verified: true,\n        verificationMethod\n      };\n    } catch (error) {\n      return {\n        verified: false,\n        error\n      };\n    }\n  }\n  async canonize(input, {\n    documentLoader,\n    expansionMap,\n    skipExpansion\n  }) {\n    if (expansionMap) {\n      throw new Error('\"expansionMap\" not supported.');\n    }\n    return jsonld.canonize(input, {\n      algorithm: 'URDNA2015',\n      // do not resolve any relative URLs or terms, throw errors instead\n      base: null,\n      format: 'application/n-quads',\n      documentLoader,\n      // throw errors if any values would be dropped due to missing\n      // definitions or relative URLs\n      safe: true,\n      skipExpansion,\n      useNative: this.useNativeCanonize,\n      ...this.canonizeOptions\n    });\n  }\n  async canonizeProof(proof, {\n    document,\n    documentLoader,\n    expansionMap\n  }) {\n    if (expansionMap) {\n      throw new Error('\"expansionMap\" not supported.');\n    }\n    // `jws`,`signatureValue`,`proofValue` must not be included in the proof\n    // options\n    proof = {\n      '@context': document['@context'] || constants.SECURITY_CONTEXT_URL,\n      ...proof\n    };\n    delete proof.jws;\n    delete proof.signatureValue;\n    delete proof.proofValue;\n    return this.canonize(proof, {\n      documentLoader,\n      expansionMap,\n      skipExpansion: false,\n      ...this.canonizeOptions\n    });\n  }\n\n  /**\n   * @param {object} options - The options to use.\n   * @param {object} options.document - The document to be signed/verified.\n   * @param {object} options.proof - The proof to be verified.\n   * @param {Array} options.proofSet - Any existing proof set.\n   * @param {function} options.documentLoader - The document loader to use.\n   * @param {function} options.expansionMap - NOT SUPPORTED; do not use.\n   *\n   * @returns {Promise<{Uint8Array}>}.\n   */\n  async createVerifyData({\n    document,\n    proof,\n    documentLoader,\n    expansionMap\n  }) {\n    if (expansionMap) {\n      throw new Error('\"expansionMap\" not supported.');\n    }\n    // get cached document hash\n    let cachedDocHash;\n    const {\n      _hashCache\n    } = this;\n    if (_hashCache && _hashCache.document === document) {\n      cachedDocHash = _hashCache.hash;\n    } else {\n      this._hashCache = {\n        document,\n        // canonize and hash document\n        hash: cachedDocHash = this.canonize(document, {\n          documentLoader,\n          expansionMap\n        }).then(c14nDocument => sha256digest({\n          string: c14nDocument\n        }))\n      };\n    }\n\n    // await both c14n proof hash and c14n document hash\n    const [proofHash, docHash] = await Promise.all([\n    // canonize and hash proof\n    this.canonizeProof(proof, {\n      document,\n      documentLoader,\n      expansionMap\n    }).then(c14nProofOptions => sha256digest({\n      string: c14nProofOptions\n    })), cachedDocHash]);\n\n    // concatenate hash of c14n proof options and hash of c14n document\n    return util.concat(proofHash, docHash);\n  }\n\n  /**\n   * @param verifyData {Uint8Array}.\n   * @param document {object} document from which to derive a new document\n   *   and proof.\n   * @param proof {object}\n   * @param proofSet {Array}\n   * @param documentLoader {function}\n   *\n   * @returns {Promise<{object}>} The new document with `proof`.\n   */\n  async derive() {\n    throw new Error('Must be implemented by a derived class.');\n  }\n\n  /**\n   * @param document {object} to be signed.\n   * @param proof {object}\n   * @param documentLoader {function}\n   */\n  async getVerificationMethod({\n    proof,\n    documentLoader\n  }) {\n    let {\n      verificationMethod\n    } = proof;\n    if (typeof verificationMethod === 'object') {\n      verificationMethod = verificationMethod.id;\n    }\n    if (!verificationMethod) {\n      throw new Error('No \"verificationMethod\" found in proof.');\n    }\n\n    // Note: `expansionMap` is intentionally not passed; we can safely drop\n    // properties here and must allow for it\n    const framed = await jsonld.frame(verificationMethod, {\n      '@context': constants.SECURITY_CONTEXT_URL,\n      '@embed': '@always',\n      id: verificationMethod\n    }, {\n      documentLoader,\n      compactToRelative: false,\n      safe: true\n    });\n    if (!framed) {\n      throw new Error(`Verification method ${verificationMethod} not found.`);\n    }\n\n    // ensure verification method has not been revoked\n    if (framed.revoked !== undefined) {\n      throw new Error('The verification method has been revoked.');\n    }\n    return framed;\n  }\n\n  /**\n   * @param verifyData {Uint8Array}.\n   * @param document {object} to be signed.\n   * @param proof {object}\n   * @param documentLoader {function}\n   * @param expansionMap {function}\n   *\n   * @returns {Promise<{object}>} the proof containing the signature value.\n   */\n  async sign() {\n    throw new Error('Must be implemented by a derived class.');\n  }\n\n  /**\n   * @param verifyData {Uint8Array}.\n   * @param verificationMethod {object}.\n   * @param document {object} to be signed.\n   * @param proof {object}\n   * @param documentLoader {function}\n   * @param expansionMap {function}\n   *\n   * @returns {Promise<boolean>}\n   */\n  async verifySignature() {\n    throw new Error('Must be implemented by a derived class.');\n  }\n\n  /**\n   * Ensures the document to be signed contains the required signature suite\n   * specific `@context`, by either adding it (if `addSuiteContext` is true),\n   * or throwing an error if it's missing.\n   *\n   * @param {object} options - Options hashmap.\n   * @param {object} options.document - JSON-LD document to be signed.\n   * @param {boolean} options.addSuiteContext - Add suite context?\n   */\n  ensureSuiteContext({\n    document,\n    addSuiteContext\n  }) {\n    const {\n      contextUrl\n    } = this;\n    if (_includesContext({\n      document,\n      contextUrl\n    })) {\n      // document already includes the required context\n      return;\n    }\n    if (!addSuiteContext) {\n      throw new TypeError(`The document to be signed must contain this suite's @context, ` + `\"${contextUrl}\".`);\n    }\n\n    // enforce the suite's context by adding it to the document\n    const existingContext = document['@context'] || [];\n    document['@context'] = Array.isArray(existingContext) ? [...existingContext, contextUrl] : [existingContext, contextUrl];\n  }\n};\n\n/**\n * Tests whether a provided JSON-LD document includes a context URL in its\n * `@context` property.\n *\n * @param {object} options - Options hashmap.\n * @param {object} options.document - A JSON-LD document.\n * @param {string} options.contextUrl - A context URL.\n *\n * @returns {boolean} Returns true if document includes context.\n */\nfunction _includesContext({\n  document,\n  contextUrl\n}) {\n  const context = document['@context'];\n  return context === contextUrl || Array.isArray(context) && context.includes(contextUrl);\n}\n\n/**\n * See constructor docstring for param details.\n *\n * @returns {{verificationMethod: string, key: LDKeyPair,\n *   signer: {sign: Function, id: string},\n *   verifier: {verify: Function, id: string}}} - Validated and initialized\n *   key-related parameters.\n */\nfunction _processSignatureParams({\n  key,\n  signer,\n  verifier\n}) {\n  // We are explicitly not requiring a key or signer/verifier param to be\n  // present, to support the verify() use case where the verificationMethod\n  // is being fetched by the documentLoader\n\n  const vm = {};\n  if (key) {\n    vm.key = key;\n    vm.verificationMethod = key.id;\n    if (typeof key.signer === 'function') {\n      vm.signer = key.signer();\n    }\n    if (typeof key.verifier === 'function') {\n      vm.verifier = key.verifier();\n    }\n    if (!(vm.signer || vm.verifier)) {\n      throw new TypeError('The \"key\" parameter must contain a \"signer\" or \"verifier\" method.');\n    }\n  } else {\n    vm.verificationMethod = signer && signer.id || verifier && verifier.id;\n    vm.signer = signer;\n    vm.verifier = verifier;\n  }\n  if (vm.signer) {\n    if (typeof vm.signer.sign !== 'function') {\n      throw new TypeError('A signer API has not been specified.');\n    }\n  }\n  if (vm.verifier) {\n    if (typeof vm.verifier.verify !== 'function') {\n      throw new TypeError('A verifier API has not been specified.');\n    }\n  }\n  return vm;\n}","map":{"version":3,"names":["constants","require","jsonld","util","sha256digest","LinkedDataProof","module","exports","LinkedDataSignature","constructor","type","proof","LDKeyClass","date","key","signer","verifier","useNativeCanonize","canonizeOptions","contextUrl","vm","_processSignatureParams","verificationMethod","Date","isNaN","TypeError","_hashCache","createProof","document","purpose","proofSet","documentLoader","expansionMap","Error","created","undefined","w3cDate","updateProof","update","suite","verifyData","createVerifyData","sign","verifyProof","getVerificationMethod","verified","verifySignature","error","canonize","input","skipExpansion","algorithm","base","format","safe","useNative","canonizeProof","SECURITY_CONTEXT_URL","jws","signatureValue","proofValue","cachedDocHash","hash","then","c14nDocument","string","proofHash","docHash","Promise","all","c14nProofOptions","concat","derive","id","framed","frame","compactToRelative","revoked","ensureSuiteContext","addSuiteContext","_includesContext","existingContext","Array","isArray","context","includes","verify"],"sources":["/home/pratap/domain-linkege/node_modules/jsonld-signatures/lib/suites/LinkedDataSignature.js"],"sourcesContent":["/*!\n * Copyright (c) 2017-2023 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n\nconst constants = require('../constants');\nconst jsonld = require('jsonld');\nconst util = require('../util');\nconst {sha256digest} = require('../sha256digest');\nconst LinkedDataProof = require('./LinkedDataProof');\n\nmodule.exports = class LinkedDataSignature extends LinkedDataProof {\n  /**\n   * Parent class from which the various LinkDataSignature suites (such as\n   * `Ed25519Signature2020`) inherit.\n   * NOTE: Developers are never expected to use this class directly, but to\n   * only work with individual suites.\n   *\n   * @param {object} options - Options hashmap.\n   * @param {string} options.type - Suite name, provided by subclass.\n   * @typedef LDKeyPair\n   * @param {LDKeyPair} LDKeyClass - The crypto-ld key class that this suite\n   *   will use to sign/verify signatures. Provided by subclass. Used\n   *   during the `verifySignature` operation, to create an instance (containing\n   *   a `verifier()` property) of a public key fetched via a `documentLoader`.\n   *\n   * @param {string} contextUrl - JSON-LD context URL that corresponds to this\n   *   signature suite. Provided by subclass. Used for enforcing suite context\n   *   during the `sign()` operation.\n   *\n   * For `sign()` operations, either a `key` OR a `signer` is required.\n   * For `verify()` operations, you can pass in a verifier (from KMS), or\n   * the public key will be fetched via documentLoader.\n   *\n   * @param {object} [options.key] - An optional key object (containing an\n   *   `id` property, and either `signer` or `verifier`, depending on the\n   *   intended operation. Useful for when the application is managing keys\n   *   itself (when using a KMS, you never have access to the private key,\n   *   and so should use the `signer` param instead).\n   *\n   * @param {{sign: Function, id: string}} [options.signer] - Signer object\n   *   that has two properties: an async `sign()` method, and an `id`. This is\n   *   useful when interfacing with a KMS (since you don't get access to the\n   *   private key and its `signer`, the KMS client gives you only the signer\n   *   object to use).\n   *\n   * @param {{verify: Function, id: string}} [options.verifier] - Verifier\n   *   object that has two properties: an async `verify()` method, and an `id`.\n   *   Useful when working with a KMS-provided verifier.\n   *\n   * Advanced optional parameters and overrides:\n   *\n   * @param {object} [options.proof] - A JSON-LD document with options to use\n   *   for the `proof` node (e.g. any other custom fields can be provided here\n   *   using a context different from security-v2). If not provided, this is\n   *   constructed during signing.\n   * @param {string|Date} [options.date] - Signing date to use (otherwise\n   *   defaults to `now()`).\n   * @param {boolean} [options.useNativeCanonize] - Whether to use a native\n   *   canonize algorithm.\n   * @param {object} [options.canonizeOptions] - Options to pass to\n   *   canonize algorithm.\n   */\n  constructor({\n    type, proof, LDKeyClass, date, key, signer, verifier, useNativeCanonize,\n    canonizeOptions, contextUrl\n  } = {}) {\n    super({type});\n    this.LDKeyClass = LDKeyClass;\n    this.contextUrl = contextUrl;\n    this.proof = proof;\n    const vm = _processSignatureParams({key, signer, verifier});\n    this.verificationMethod = vm.verificationMethod;\n    this.key = vm.key;\n    this.signer = vm.signer;\n    this.verifier = vm.verifier;\n    this.canonizeOptions = canonizeOptions;\n    if(date) {\n      this.date = new Date(date);\n      if(isNaN(this.date)) {\n        throw TypeError(`\"date\" \"${date}\" is not a valid date.`);\n      }\n    }\n    this.useNativeCanonize = useNativeCanonize;\n    this._hashCache = null;\n  }\n\n  /**\n   * @param {object} options - The options to use.\n   * @param {object} options.document - The document to be signed.\n   * @param {ProofPurpose} options.purpose - The proof purpose instance.\n   * @param {Array} options.proofSet - Any existing proof set.\n   * @param {function} options.documentLoader - The document loader to use.\n   * @param {function} options.expansionMap - NOT SUPPORTED; do not use.\n   *\n   * @returns {Promise<object>} Resolves with the created proof object.\n   */\n  async createProof({\n    document, purpose, proofSet, documentLoader, expansionMap\n  }) {\n    if(expansionMap) {\n      throw new Error('\"expansionMap\" not supported.');\n    }\n\n    // build proof (currently known as `signature options` in spec)\n    let proof;\n    if(this.proof) {\n      // shallow copy\n      proof = {...this.proof};\n    } else {\n      // create proof JSON-LD document\n      proof = {};\n    }\n\n    // ensure proof type is set\n    proof.type = this.type;\n\n    // set default `now` date if not given in `proof` or `options`\n    let date = this.date;\n    if(proof.created === undefined && date === undefined) {\n      date = new Date();\n    }\n\n    // ensure date is in string format\n    if(date && typeof date !== 'string') {\n      date = util.w3cDate(date);\n    }\n\n    // add API overrides\n    if(date) {\n      proof.created = date;\n    }\n\n    proof.verificationMethod = this.verificationMethod;\n\n    // add any extensions to proof (mostly for legacy support)\n    proof = await this.updateProof(\n      {document, proof, proofSet, purpose, documentLoader});\n\n    // allow purpose to update the proof; the `proof` is in the\n    // SECURITY_CONTEXT_URL `@context` -- therefore the `purpose` must\n    // ensure any added fields are also represented in that same `@context`\n    proof = await purpose.update(\n      proof, {document, suite: this, documentLoader});\n\n    // create data to sign\n    const verifyData = await this.createVerifyData(\n      {document, proof, proofSet, documentLoader});\n\n    // sign data\n    proof = await this.sign({verifyData, document, proof, documentLoader});\n\n    return proof;\n  }\n\n  /**\n   * @param {object} options - The options to use.\n   * @param {object} options.proof - The proof to be updated.\n   * @param {Array} options.proofSet - Any existing proof set.\n   * @param {function} options.expansionMap - NOT SUPPORTED; do not use.\n   *\n   * @returns {Promise<object>} Resolves with the created proof object.\n   */\n  async updateProof({proof, expansionMap}) {\n    if(expansionMap) {\n      throw new Error('\"expansionMap\" not supported.');\n    }\n    // extending classes may do more\n    return proof;\n  }\n\n  /**\n   * @param {object} options - The options to use.\n   * @param {object} options.proof - The proof to be verified.\n   * @param {object} options.document - The document the proof applies to.\n   * @param {ProofPurpose} options.purpose - The proof purpose instance.\n   * @param {Array} options.proofSet - Any existing proof set.\n   * @param {function} options.documentLoader - The document loader to use.\n   * @param {function} options.expansionMap - NOT SUPPORTED; do not use.\n   *\n   * @returns {Promise<{object}>} Resolves with the verification result.\n   */\n  async verifyProof({proof, document, proofSet, documentLoader, expansionMap}) {\n    if(expansionMap) {\n      throw new Error('\"expansionMap\" not supported.');\n    }\n\n    try {\n      // create data to verify\n      const verifyData = await this.createVerifyData(\n        {document, proof, proofSet, documentLoader, expansionMap});\n\n      // fetch verification method\n      const verificationMethod = await this.getVerificationMethod(\n        {proof, document, documentLoader, expansionMap});\n\n      // verify signature on data\n      const verified = await this.verifySignature({\n        verifyData, verificationMethod, document, proof,\n        documentLoader, expansionMap});\n      if(!verified) {\n        throw new Error('Invalid signature.');\n      }\n\n      return {verified: true, verificationMethod};\n    } catch(error) {\n      return {verified: false, error};\n    }\n  }\n\n  async canonize(input, {documentLoader, expansionMap, skipExpansion}) {\n    if(expansionMap) {\n      throw new Error('\"expansionMap\" not supported.');\n    }\n    return jsonld.canonize(input, {\n      algorithm: 'URDNA2015',\n      // do not resolve any relative URLs or terms, throw errors instead\n      base: null,\n      format: 'application/n-quads',\n      documentLoader,\n      // throw errors if any values would be dropped due to missing\n      // definitions or relative URLs\n      safe: true,\n      skipExpansion,\n      useNative: this.useNativeCanonize,\n      ...this.canonizeOptions\n    });\n  }\n\n  async canonizeProof(proof, {document, documentLoader, expansionMap}) {\n    if(expansionMap) {\n      throw new Error('\"expansionMap\" not supported.');\n    }\n    // `jws`,`signatureValue`,`proofValue` must not be included in the proof\n    // options\n    proof = {\n      '@context': document['@context'] || constants.SECURITY_CONTEXT_URL,\n      ...proof\n    };\n    delete proof.jws;\n    delete proof.signatureValue;\n    delete proof.proofValue;\n    return this.canonize(proof, {\n      documentLoader,\n      expansionMap,\n      skipExpansion: false,\n      ...this.canonizeOptions\n    });\n  }\n\n  /**\n   * @param {object} options - The options to use.\n   * @param {object} options.document - The document to be signed/verified.\n   * @param {object} options.proof - The proof to be verified.\n   * @param {Array} options.proofSet - Any existing proof set.\n   * @param {function} options.documentLoader - The document loader to use.\n   * @param {function} options.expansionMap - NOT SUPPORTED; do not use.\n   *\n   * @returns {Promise<{Uint8Array}>}.\n   */\n  async createVerifyData({document, proof, documentLoader, expansionMap}) {\n    if(expansionMap) {\n      throw new Error('\"expansionMap\" not supported.');\n    }\n    // get cached document hash\n    let cachedDocHash;\n    const {_hashCache} = this;\n    if(_hashCache && _hashCache.document === document) {\n      cachedDocHash = _hashCache.hash;\n    } else {\n      this._hashCache = {\n        document,\n        // canonize and hash document\n        hash: cachedDocHash =\n          this.canonize(document, {documentLoader, expansionMap})\n            .then(c14nDocument => sha256digest({string: c14nDocument}))\n      };\n    }\n\n    // await both c14n proof hash and c14n document hash\n    const [proofHash, docHash] = await Promise.all([\n      // canonize and hash proof\n      this.canonizeProof(\n        proof, {document, documentLoader, expansionMap})\n        .then(c14nProofOptions => sha256digest({string: c14nProofOptions})),\n      cachedDocHash\n    ]);\n\n    // concatenate hash of c14n proof options and hash of c14n document\n    return util.concat(proofHash, docHash);\n  }\n\n  /**\n   * @param verifyData {Uint8Array}.\n   * @param document {object} document from which to derive a new document\n   *   and proof.\n   * @param proof {object}\n   * @param proofSet {Array}\n   * @param documentLoader {function}\n   *\n   * @returns {Promise<{object}>} The new document with `proof`.\n   */\n  async derive() {\n    throw new Error('Must be implemented by a derived class.');\n  }\n\n  /**\n   * @param document {object} to be signed.\n   * @param proof {object}\n   * @param documentLoader {function}\n   */\n  async getVerificationMethod({proof, documentLoader}) {\n    let {verificationMethod} = proof;\n\n    if(typeof verificationMethod === 'object') {\n      verificationMethod = verificationMethod.id;\n    }\n\n    if(!verificationMethod) {\n      throw new Error('No \"verificationMethod\" found in proof.');\n    }\n\n    // Note: `expansionMap` is intentionally not passed; we can safely drop\n    // properties here and must allow for it\n    const framed = await jsonld.frame(verificationMethod, {\n      '@context': constants.SECURITY_CONTEXT_URL,\n      '@embed': '@always',\n      id: verificationMethod\n    }, {documentLoader, compactToRelative: false, safe: true});\n    if(!framed) {\n      throw new Error(`Verification method ${verificationMethod} not found.`);\n    }\n\n    // ensure verification method has not been revoked\n    if(framed.revoked !== undefined) {\n      throw new Error('The verification method has been revoked.');\n    }\n\n    return framed;\n  }\n\n  /**\n   * @param verifyData {Uint8Array}.\n   * @param document {object} to be signed.\n   * @param proof {object}\n   * @param documentLoader {function}\n   * @param expansionMap {function}\n   *\n   * @returns {Promise<{object}>} the proof containing the signature value.\n   */\n  async sign() {\n    throw new Error('Must be implemented by a derived class.');\n  }\n\n  /**\n   * @param verifyData {Uint8Array}.\n   * @param verificationMethod {object}.\n   * @param document {object} to be signed.\n   * @param proof {object}\n   * @param documentLoader {function}\n   * @param expansionMap {function}\n   *\n   * @returns {Promise<boolean>}\n   */\n  async verifySignature() {\n    throw new Error('Must be implemented by a derived class.');\n  }\n\n  /**\n   * Ensures the document to be signed contains the required signature suite\n   * specific `@context`, by either adding it (if `addSuiteContext` is true),\n   * or throwing an error if it's missing.\n   *\n   * @param {object} options - Options hashmap.\n   * @param {object} options.document - JSON-LD document to be signed.\n   * @param {boolean} options.addSuiteContext - Add suite context?\n   */\n  ensureSuiteContext({document, addSuiteContext}) {\n    const {contextUrl} = this;\n\n    if(_includesContext({document, contextUrl})) {\n      // document already includes the required context\n      return;\n    }\n\n    if(!addSuiteContext) {\n      throw new TypeError(\n        `The document to be signed must contain this suite's @context, ` +\n        `\"${contextUrl}\".`);\n    }\n\n    // enforce the suite's context by adding it to the document\n    const existingContext = document['@context'] || [];\n\n    document['@context'] = Array.isArray(existingContext) ?\n      [...existingContext, contextUrl] : [existingContext, contextUrl];\n  }\n};\n\n/**\n * Tests whether a provided JSON-LD document includes a context URL in its\n * `@context` property.\n *\n * @param {object} options - Options hashmap.\n * @param {object} options.document - A JSON-LD document.\n * @param {string} options.contextUrl - A context URL.\n *\n * @returns {boolean} Returns true if document includes context.\n */\nfunction _includesContext({document, contextUrl}) {\n  const context = document['@context'];\n  return context === contextUrl ||\n    (Array.isArray(context) && context.includes(contextUrl));\n}\n\n/**\n * See constructor docstring for param details.\n *\n * @returns {{verificationMethod: string, key: LDKeyPair,\n *   signer: {sign: Function, id: string},\n *   verifier: {verify: Function, id: string}}} - Validated and initialized\n *   key-related parameters.\n */\nfunction _processSignatureParams({key, signer, verifier}) {\n  // We are explicitly not requiring a key or signer/verifier param to be\n  // present, to support the verify() use case where the verificationMethod\n  // is being fetched by the documentLoader\n\n  const vm = {};\n  if(key) {\n    vm.key = key;\n    vm.verificationMethod = key.id;\n    if(typeof key.signer === 'function') {\n      vm.signer = key.signer();\n    }\n    if(typeof key.verifier === 'function') {\n      vm.verifier = key.verifier();\n    }\n    if(!(vm.signer || vm.verifier)) {\n      throw new TypeError(\n        'The \"key\" parameter must contain a \"signer\" or \"verifier\" method.');\n    }\n  } else {\n    vm.verificationMethod = (signer && signer.id) ||\n      (verifier && verifier.id);\n    vm.signer = signer;\n    vm.verifier = verifier;\n  }\n\n  if(vm.signer) {\n    if(typeof vm.signer.sign !== 'function') {\n      throw new TypeError('A signer API has not been specified.');\n    }\n  }\n  if(vm.verifier) {\n    if(typeof vm.verifier.verify !== 'function') {\n      throw new TypeError('A verifier API has not been specified.');\n    }\n  }\n\n  return vm;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}