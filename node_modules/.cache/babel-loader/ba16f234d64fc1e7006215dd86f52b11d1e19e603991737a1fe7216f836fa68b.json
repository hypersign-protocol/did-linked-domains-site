{"ast":null,"code":"/*!\n * Copyright (c) 2017-2021 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n\nconst constants = require('../constants');\nconst jsonld = require('jsonld');\nconst util = require('../util');\nconst {\n  sha256digest\n} = require('../sha256digest');\nconst LinkedDataProof = require('./LinkedDataProof');\nmodule.exports = class LinkedDataSignature extends LinkedDataProof {\n  /**\n   * Parent class from which the various LinkDataSignature suites (such as\n   * `Ed25519Signature2020`) inherit.\n   * NOTE: Developers are never expected to use this class directly, but to\n   * only work with individual suites.\n   *\n   * @param {object} options - Options hashmap.\n   * @param {string} options.type - Suite name, provided by subclass.\n   * @typedef LDKeyPair\n   * @param {LDKeyPair} LDKeyClass - The crypto-ld key class that this suite\n   *   will use to sign/verify signatures. Provided by subclass. Used\n   *   during the `verifySignature` operation, to create an instance (containing\n   *   a `verifier()` property) of a public key fetched via a `documentLoader`.\n   *\n   * @param {string} contextUrl - JSON-LD context URL that corresponds to this\n   *   signature suite. Provided by subclass. Used for enforcing suite context\n   *   during the `sign()` operation.\n   *\n   * For `sign()` operations, either a `key` OR a `signer` is required.\n   * For `verify()` operations, you can pass in a verifier (from KMS), or\n   * the public key will be fetched via documentLoader.\n   *\n   * @param {object} [options.key] - An optional key object (containing an\n   *   `id` property, and either `signer` or `verifier`, depending on the\n   *   intended operation. Useful for when the application is managing keys\n   *   itself (when using a KMS, you never have access to the private key,\n   *   and so should use the `signer` param instead).\n   *\n   * @param {{sign: Function, id: string}} [options.signer] - Signer object\n   *   that has two properties: an async `sign()` method, and an `id`. This is\n   *   useful when interfacing with a KMS (since you don't get access to the\n   *   private key and its `signer`, the KMS client gives you only the signer\n   *   object to use).\n   *\n   * @param {{verify: Function, id: string}} [options.verifier] - Verifier\n   *   object that has two properties: an async `verify()` method, and an `id`.\n   *   Useful when working with a KMS-provided verifier.\n   *\n   * Advanced optional parameters and overrides:\n   *\n   * @param {object} [options.proof] - A JSON-LD document with options to use\n   *   for the `proof` node (e.g. any other custom fields can be provided here\n   *   using a context different from security-v2). If not provided, this is\n   *   constructed during signing.\n   * @param {string|Date} [options.date] - Signing date to use (otherwise\n   *   defaults to `now()`).\n   * @param {boolean} [options.useNativeCanonize] - Whether to use a native\n   *   canonize algorithm.\n   */\n  constructor({\n    type,\n    proof,\n    LDKeyClass,\n    date,\n    key,\n    signer,\n    verifier,\n    useNativeCanonize,\n    contextUrl\n  } = {}) {\n    super({\n      type\n    });\n    this.LDKeyClass = LDKeyClass;\n    this.contextUrl = contextUrl;\n    this.proof = proof;\n    const vm = _processSignatureParams({\n      key,\n      signer,\n      verifier\n    });\n    this.verificationMethod = vm.verificationMethod;\n    this.key = vm.key;\n    this.signer = vm.signer;\n    this.verifier = vm.verifier;\n    if (date) {\n      this.date = new Date(date);\n      if (isNaN(this.date)) {\n        throw TypeError(`\"date\" \"${date}\" is not a valid date.`);\n      }\n    }\n    this.useNativeCanonize = useNativeCanonize;\n    this._hashCache = null;\n  }\n\n  /**\n   * @param document {object} to be signed.\n   * @param purpose {ProofPurpose}\n   * @param documentLoader {function}\n   * @param expansionMap {function}\n   *\n   * @returns {Promise<object>} Resolves with the created proof object.\n   */\n  async createProof({\n    document,\n    purpose,\n    documentLoader,\n    expansionMap\n  }) {\n    // build proof (currently known as `signature options` in spec)\n    let proof;\n    if (this.proof) {\n      // shallow copy\n      proof = {\n        ...this.proof\n      };\n    } else {\n      // create proof JSON-LD document\n      proof = {};\n    }\n\n    // ensure proof type is set\n    proof.type = this.type;\n\n    // set default `now` date if not given in `proof` or `options`\n    let date = this.date;\n    if (proof.created === undefined && date === undefined) {\n      date = new Date();\n    }\n\n    // ensure date is in string format\n    if (date && typeof date !== 'string') {\n      date = util.w3cDate(date);\n    }\n\n    // add API overrides\n    if (date) {\n      proof.created = date;\n    }\n    proof.verificationMethod = this.verificationMethod;\n\n    // add any extensions to proof (mostly for legacy support)\n    proof = await this.updateProof({\n      document,\n      proof,\n      purpose,\n      documentLoader,\n      expansionMap\n    });\n\n    // allow purpose to update the proof; the `proof` is in the\n    // SECURITY_CONTEXT_URL `@context` -- therefore the `purpose` must\n    // ensure any added fields are also represented in that same `@context`\n    proof = await purpose.update(proof, {\n      document,\n      suite: this,\n      documentLoader,\n      expansionMap\n    });\n\n    // create data to sign\n    const verifyData = await this.createVerifyData({\n      document,\n      proof,\n      documentLoader,\n      expansionMap\n    });\n\n    // sign data\n    proof = await this.sign({\n      verifyData,\n      document,\n      proof,\n      documentLoader,\n      expansionMap\n    });\n    return proof;\n  }\n\n  /**\n   * @param document {object} to be signed.\n   * @param purpose {ProofPurpose}\n   * @param documentLoader {function}\n   * @param expansionMap {function}\n   *\n   * @returns {Promise<object>} Resolves with the created proof object.\n   */\n  async updateProof({\n    proof\n  }) {\n    // extending classes may do more\n    return proof;\n  }\n\n  /**\n   * @param proof {object} the proof to be verified.\n   * @param document {object} the document the proof applies to.\n   * @param documentLoader {function}\n   * @param expansionMap {function}\n   *\n   * @returns {Promise<{object}>} Resolves with the verification result.\n   */\n  async verifyProof({\n    proof,\n    document,\n    documentLoader,\n    expansionMap\n  }) {\n    try {\n      // create data to verify\n      const verifyData = await this.createVerifyData({\n        document,\n        proof,\n        documentLoader,\n        expansionMap\n      });\n\n      // fetch verification method\n      const verificationMethod = await this.getVerificationMethod({\n        proof,\n        document,\n        documentLoader,\n        expansionMap\n      });\n\n      // verify signature on data\n      const verified = await this.verifySignature({\n        verifyData,\n        verificationMethod,\n        document,\n        proof,\n        documentLoader,\n        expansionMap\n      });\n      if (!verified) {\n        throw new Error('Invalid signature.');\n      }\n      return {\n        verified: true,\n        verificationMethod\n      };\n    } catch (error) {\n      return {\n        verified: false,\n        error\n      };\n    }\n  }\n  async canonize(input, {\n    documentLoader,\n    expansionMap,\n    skipExpansion\n  }) {\n    return jsonld.canonize(input, {\n      algorithm: 'URDNA2015',\n      format: 'application/n-quads',\n      documentLoader,\n      expansionMap,\n      skipExpansion,\n      useNative: this.useNativeCanonize\n    });\n  }\n  async canonizeProof(proof, {\n    document,\n    documentLoader,\n    expansionMap\n  }) {\n    // `jws`,`signatureValue`,`proofValue` must not be included in the proof\n    // options\n    proof = {\n      '@context': document['@context'] || constants.SECURITY_CONTEXT_URL,\n      ...proof\n    };\n    delete proof.jws;\n    delete proof.signatureValue;\n    delete proof.proofValue;\n    return this.canonize(proof, {\n      documentLoader,\n      expansionMap,\n      skipExpansion: false\n    });\n  }\n\n  /**\n   * @param document {object} to be signed/verified.\n   * @param proof {object}\n   * @param documentLoader {function}\n   * @param expansionMap {function}\n   *\n   * @returns {Promise<{Uint8Array}>}.\n   */\n  async createVerifyData({\n    document,\n    proof,\n    documentLoader,\n    expansionMap\n  }) {\n    // get cached document hash\n    let cachedDocHash;\n    const {\n      _hashCache\n    } = this;\n    if (_hashCache && _hashCache.document === document) {\n      cachedDocHash = _hashCache.hash;\n    } else {\n      this._hashCache = {\n        document,\n        // canonize and hash document\n        hash: cachedDocHash = this.canonize(document, {\n          documentLoader,\n          expansionMap\n        }).then(c14nDocument => sha256digest({\n          string: c14nDocument\n        }))\n      };\n    }\n\n    // await both c14n proof hash and c14n document hash\n    const [proofHash, docHash] = await Promise.all([\n    // canonize and hash proof\n    this.canonizeProof(proof, {\n      document,\n      documentLoader,\n      expansionMap\n    }).then(c14nProofOptions => sha256digest({\n      string: c14nProofOptions\n    })), cachedDocHash]);\n\n    // concatenate hash of c14n proof options and hash of c14n document\n    return util.concat(proofHash, docHash);\n  }\n\n  /**\n   * @param document {object} to be signed.\n   * @param proof {object}\n   * @param documentLoader {function}\n   */\n  async getVerificationMethod({\n    proof,\n    documentLoader\n  }) {\n    let {\n      verificationMethod\n    } = proof;\n    if (typeof verificationMethod === 'object') {\n      verificationMethod = verificationMethod.id;\n    }\n    if (!verificationMethod) {\n      throw new Error('No \"verificationMethod\" found in proof.');\n    }\n\n    // Note: `expansionMap` is intentionally not passed; we can safely drop\n    // properties here and must allow for it\n    const framed = await jsonld.frame(verificationMethod, {\n      '@context': constants.SECURITY_CONTEXT_URL,\n      '@embed': '@always',\n      id: verificationMethod\n    }, {\n      documentLoader,\n      compactToRelative: false\n    });\n    if (!framed) {\n      throw new Error(`Verification method ${verificationMethod} not found.`);\n    }\n\n    // ensure verification method has not been revoked\n    if (framed.revoked !== undefined) {\n      throw new Error('The verification method has been revoked.');\n    }\n    return framed;\n  }\n\n  /**\n   * @param verifyData {Uint8Array}.\n   * @param document {object} to be signed.\n   * @param proof {object}\n   * @param documentLoader {function}\n   * @param expansionMap {function}\n   *\n   * @returns {Promise<{object}>} the proof containing the signature value.\n   */\n  async sign() {\n    throw new Error('Must be implemented by a derived class.');\n  }\n\n  /**\n   * @param verifyData {Uint8Array}.\n   * @param verificationMethod {object}.\n   * @param document {object} to be signed.\n   * @param proof {object}\n   * @param documentLoader {function}\n   * @param expansionMap {function}\n   *\n   * @returns {Promise<boolean>}\n   */\n  async verifySignature() {\n    throw new Error('Must be implemented by a derived class.');\n  }\n\n  /**\n   * Ensures the document to be signed contains the required signature suite\n   * specific `@context`, by either adding it (if `addSuiteContext` is true),\n   * or throwing an error if it's missing.\n   *\n   * @param {object} options - Options hashmap.\n   * @param {object} options.document - JSON-LD document to be signed.\n   * @param {boolean} options.addSuiteContext - Add suite context?\n   */\n  ensureSuiteContext({\n    document,\n    addSuiteContext\n  }) {\n    const {\n      contextUrl\n    } = this;\n    if (_includesContext({\n      document,\n      contextUrl\n    })) {\n      // document already includes the required context\n      return;\n    }\n    if (!addSuiteContext) {\n      throw new TypeError(`The document to be signed must contain this suite's @context, ` + `\"${contextUrl}\".`);\n    }\n\n    // enforce the suite's context by adding it to the document\n    const existingContext = document['@context'] || [];\n    document['@context'] = Array.isArray(existingContext) ? [...existingContext, contextUrl] : [existingContext, contextUrl];\n  }\n};\n\n/**\n * Tests whether a provided JSON-LD document includes a context URL in its\n * `@context` property.\n *\n * @param {object} options - Options hashmap.\n * @param {object} options.document - A JSON-LD document.\n * @param {string} options.contextUrl - A context URL.\n *\n * @returns {boolean} Returns true if document includes context.\n */\nfunction _includesContext({\n  document,\n  contextUrl\n}) {\n  const context = document['@context'];\n  return context === contextUrl || Array.isArray(context) && context.includes(contextUrl);\n}\n\n/**\n * See constructor docstring for param details.\n *\n * @returns {{verificationMethod: string, key: LDKeyPair,\n *   signer: {sign: Function, id: string},\n *   verifier: {verify: Function, id: string}}} - Validated and initialized\n *   key-related parameters.\n */\nfunction _processSignatureParams({\n  key,\n  signer,\n  verifier\n}) {\n  // We are explicitly not requiring a key or signer/verifier param to be\n  // present, to support the verify() use case where the verificationMethod\n  // is being fetched by the documentLoader\n\n  const vm = {};\n  if (key) {\n    vm.key = key;\n    vm.verificationMethod = key.id;\n    if (typeof key.signer === 'function') {\n      vm.signer = key.signer();\n    }\n    if (typeof key.verifier === 'function') {\n      vm.verifier = key.verifier();\n    }\n    if (!(vm.signer || vm.verifier)) {\n      throw new TypeError('The \"key\" parameter must contain a \"signer\" or \"verifier\" method.');\n    }\n  } else {\n    vm.verificationMethod = signer && signer.id || verifier && verifier.id;\n    vm.signer = signer;\n    vm.verifier = verifier;\n  }\n  if (vm.signer) {\n    if (typeof vm.signer.sign !== 'function') {\n      throw new TypeError('A signer API has not been specified.');\n    }\n  }\n  if (vm.verifier) {\n    if (typeof vm.verifier.verify !== 'function') {\n      throw new TypeError('A verifier API has not been specified.');\n    }\n  }\n  return vm;\n}","map":{"version":3,"names":["constants","require","jsonld","util","sha256digest","LinkedDataProof","module","exports","LinkedDataSignature","constructor","type","proof","LDKeyClass","date","key","signer","verifier","useNativeCanonize","contextUrl","vm","_processSignatureParams","verificationMethod","Date","isNaN","TypeError","_hashCache","createProof","document","purpose","documentLoader","expansionMap","created","undefined","w3cDate","updateProof","update","suite","verifyData","createVerifyData","sign","verifyProof","getVerificationMethod","verified","verifySignature","Error","error","canonize","input","skipExpansion","algorithm","format","useNative","canonizeProof","SECURITY_CONTEXT_URL","jws","signatureValue","proofValue","cachedDocHash","hash","then","c14nDocument","string","proofHash","docHash","Promise","all","c14nProofOptions","concat","id","framed","frame","compactToRelative","revoked","ensureSuiteContext","addSuiteContext","_includesContext","existingContext","Array","isArray","context","includes","verify"],"sources":["/home/pratap/hid-ssi-js-sdk/node_modules/jsonld-signatures/lib/suites/LinkedDataSignature.js"],"sourcesContent":["/*!\n * Copyright (c) 2017-2021 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n\nconst constants = require('../constants');\nconst jsonld = require('jsonld');\nconst util = require('../util');\nconst {sha256digest} = require('../sha256digest');\nconst LinkedDataProof = require('./LinkedDataProof');\n\nmodule.exports = class LinkedDataSignature extends LinkedDataProof {\n  /**\n   * Parent class from which the various LinkDataSignature suites (such as\n   * `Ed25519Signature2020`) inherit.\n   * NOTE: Developers are never expected to use this class directly, but to\n   * only work with individual suites.\n   *\n   * @param {object} options - Options hashmap.\n   * @param {string} options.type - Suite name, provided by subclass.\n   * @typedef LDKeyPair\n   * @param {LDKeyPair} LDKeyClass - The crypto-ld key class that this suite\n   *   will use to sign/verify signatures. Provided by subclass. Used\n   *   during the `verifySignature` operation, to create an instance (containing\n   *   a `verifier()` property) of a public key fetched via a `documentLoader`.\n   *\n   * @param {string} contextUrl - JSON-LD context URL that corresponds to this\n   *   signature suite. Provided by subclass. Used for enforcing suite context\n   *   during the `sign()` operation.\n   *\n   * For `sign()` operations, either a `key` OR a `signer` is required.\n   * For `verify()` operations, you can pass in a verifier (from KMS), or\n   * the public key will be fetched via documentLoader.\n   *\n   * @param {object} [options.key] - An optional key object (containing an\n   *   `id` property, and either `signer` or `verifier`, depending on the\n   *   intended operation. Useful for when the application is managing keys\n   *   itself (when using a KMS, you never have access to the private key,\n   *   and so should use the `signer` param instead).\n   *\n   * @param {{sign: Function, id: string}} [options.signer] - Signer object\n   *   that has two properties: an async `sign()` method, and an `id`. This is\n   *   useful when interfacing with a KMS (since you don't get access to the\n   *   private key and its `signer`, the KMS client gives you only the signer\n   *   object to use).\n   *\n   * @param {{verify: Function, id: string}} [options.verifier] - Verifier\n   *   object that has two properties: an async `verify()` method, and an `id`.\n   *   Useful when working with a KMS-provided verifier.\n   *\n   * Advanced optional parameters and overrides:\n   *\n   * @param {object} [options.proof] - A JSON-LD document with options to use\n   *   for the `proof` node (e.g. any other custom fields can be provided here\n   *   using a context different from security-v2). If not provided, this is\n   *   constructed during signing.\n   * @param {string|Date} [options.date] - Signing date to use (otherwise\n   *   defaults to `now()`).\n   * @param {boolean} [options.useNativeCanonize] - Whether to use a native\n   *   canonize algorithm.\n   */\n  constructor({\n    type, proof, LDKeyClass, date, key, signer, verifier, useNativeCanonize,\n    contextUrl\n  } = {}) {\n    super({type});\n    this.LDKeyClass = LDKeyClass;\n    this.contextUrl = contextUrl;\n    this.proof = proof;\n    const vm = _processSignatureParams({key, signer, verifier});\n    this.verificationMethod = vm.verificationMethod;\n    this.key = vm.key;\n    this.signer = vm.signer;\n    this.verifier = vm.verifier;\n    if(date) {\n      this.date = new Date(date);\n      if(isNaN(this.date)) {\n        throw TypeError(`\"date\" \"${date}\" is not a valid date.`);\n      }\n    }\n    this.useNativeCanonize = useNativeCanonize;\n    this._hashCache = null;\n  }\n\n  /**\n   * @param document {object} to be signed.\n   * @param purpose {ProofPurpose}\n   * @param documentLoader {function}\n   * @param expansionMap {function}\n   *\n   * @returns {Promise<object>} Resolves with the created proof object.\n   */\n  async createProof({document, purpose, documentLoader, expansionMap}) {\n    // build proof (currently known as `signature options` in spec)\n    let proof;\n    if(this.proof) {\n      // shallow copy\n      proof = {...this.proof};\n    } else {\n      // create proof JSON-LD document\n      proof = {};\n    }\n\n    // ensure proof type is set\n    proof.type = this.type;\n\n    // set default `now` date if not given in `proof` or `options`\n    let date = this.date;\n    if(proof.created === undefined && date === undefined) {\n      date = new Date();\n    }\n\n    // ensure date is in string format\n    if(date && typeof date !== 'string') {\n      date = util.w3cDate(date);\n    }\n\n    // add API overrides\n    if(date) {\n      proof.created = date;\n    }\n\n    proof.verificationMethod = this.verificationMethod;\n\n    // add any extensions to proof (mostly for legacy support)\n    proof = await this.updateProof({\n      document, proof, purpose, documentLoader, expansionMap\n    });\n\n    // allow purpose to update the proof; the `proof` is in the\n    // SECURITY_CONTEXT_URL `@context` -- therefore the `purpose` must\n    // ensure any added fields are also represented in that same `@context`\n    proof = await purpose.update(\n      proof, {document, suite: this, documentLoader, expansionMap});\n\n    // create data to sign\n    const verifyData = await this.createVerifyData({\n      document, proof, documentLoader, expansionMap\n    });\n\n    // sign data\n    proof = await this.sign(\n      {verifyData, document, proof, documentLoader, expansionMap});\n\n    return proof;\n  }\n\n  /**\n   * @param document {object} to be signed.\n   * @param purpose {ProofPurpose}\n   * @param documentLoader {function}\n   * @param expansionMap {function}\n   *\n   * @returns {Promise<object>} Resolves with the created proof object.\n   */\n  async updateProof({proof}) {\n    // extending classes may do more\n    return proof;\n  }\n\n  /**\n   * @param proof {object} the proof to be verified.\n   * @param document {object} the document the proof applies to.\n   * @param documentLoader {function}\n   * @param expansionMap {function}\n   *\n   * @returns {Promise<{object}>} Resolves with the verification result.\n   */\n  async verifyProof({proof, document, documentLoader, expansionMap}) {\n    try {\n      // create data to verify\n      const verifyData = await this.createVerifyData(\n        {document, proof, documentLoader, expansionMap});\n\n      // fetch verification method\n      const verificationMethod = await this.getVerificationMethod(\n        {proof, document, documentLoader, expansionMap});\n\n      // verify signature on data\n      const verified = await this.verifySignature({\n        verifyData, verificationMethod, document, proof,\n        documentLoader, expansionMap});\n      if(!verified) {\n        throw new Error('Invalid signature.');\n      }\n\n      return {verified: true, verificationMethod};\n    } catch(error) {\n      return {verified: false, error};\n    }\n  }\n\n  async canonize(input, {documentLoader, expansionMap, skipExpansion}) {\n    return jsonld.canonize(input, {\n      algorithm: 'URDNA2015',\n      format: 'application/n-quads',\n      documentLoader,\n      expansionMap,\n      skipExpansion,\n      useNative: this.useNativeCanonize\n    });\n  }\n\n  async canonizeProof(proof, {document, documentLoader, expansionMap}) {\n    // `jws`,`signatureValue`,`proofValue` must not be included in the proof\n    // options\n    proof = {\n      '@context': document['@context'] || constants.SECURITY_CONTEXT_URL,\n      ...proof\n    };\n    delete proof.jws;\n    delete proof.signatureValue;\n    delete proof.proofValue;\n    return this.canonize(proof, {\n      documentLoader,\n      expansionMap,\n      skipExpansion: false\n    });\n  }\n\n  /**\n   * @param document {object} to be signed/verified.\n   * @param proof {object}\n   * @param documentLoader {function}\n   * @param expansionMap {function}\n   *\n   * @returns {Promise<{Uint8Array}>}.\n   */\n  async createVerifyData({document, proof, documentLoader, expansionMap}) {\n    // get cached document hash\n    let cachedDocHash;\n    const {_hashCache} = this;\n    if(_hashCache && _hashCache.document === document) {\n      cachedDocHash = _hashCache.hash;\n    } else {\n      this._hashCache = {\n        document,\n        // canonize and hash document\n        hash: cachedDocHash =\n          this.canonize(document, {documentLoader, expansionMap})\n            .then(c14nDocument => sha256digest({string: c14nDocument}))\n      };\n    }\n\n    // await both c14n proof hash and c14n document hash\n    const [proofHash, docHash] = await Promise.all([\n      // canonize and hash proof\n      this.canonizeProof(\n        proof, {document, documentLoader, expansionMap})\n        .then(c14nProofOptions => sha256digest({string: c14nProofOptions})),\n      cachedDocHash\n    ]);\n\n    // concatenate hash of c14n proof options and hash of c14n document\n    return util.concat(proofHash, docHash);\n  }\n\n  /**\n   * @param document {object} to be signed.\n   * @param proof {object}\n   * @param documentLoader {function}\n   */\n  async getVerificationMethod({proof, documentLoader}) {\n    let {verificationMethod} = proof;\n\n    if(typeof verificationMethod === 'object') {\n      verificationMethod = verificationMethod.id;\n    }\n\n    if(!verificationMethod) {\n      throw new Error('No \"verificationMethod\" found in proof.');\n    }\n\n    // Note: `expansionMap` is intentionally not passed; we can safely drop\n    // properties here and must allow for it\n    const framed = await jsonld.frame(verificationMethod, {\n      '@context': constants.SECURITY_CONTEXT_URL,\n      '@embed': '@always',\n      id: verificationMethod\n    }, {documentLoader, compactToRelative: false});\n    if(!framed) {\n      throw new Error(`Verification method ${verificationMethod} not found.`);\n    }\n\n    // ensure verification method has not been revoked\n    if(framed.revoked !== undefined) {\n      throw new Error('The verification method has been revoked.');\n    }\n\n    return framed;\n  }\n\n  /**\n   * @param verifyData {Uint8Array}.\n   * @param document {object} to be signed.\n   * @param proof {object}\n   * @param documentLoader {function}\n   * @param expansionMap {function}\n   *\n   * @returns {Promise<{object}>} the proof containing the signature value.\n   */\n  async sign() {\n    throw new Error('Must be implemented by a derived class.');\n  }\n\n  /**\n   * @param verifyData {Uint8Array}.\n   * @param verificationMethod {object}.\n   * @param document {object} to be signed.\n   * @param proof {object}\n   * @param documentLoader {function}\n   * @param expansionMap {function}\n   *\n   * @returns {Promise<boolean>}\n   */\n  async verifySignature() {\n    throw new Error('Must be implemented by a derived class.');\n  }\n\n  /**\n   * Ensures the document to be signed contains the required signature suite\n   * specific `@context`, by either adding it (if `addSuiteContext` is true),\n   * or throwing an error if it's missing.\n   *\n   * @param {object} options - Options hashmap.\n   * @param {object} options.document - JSON-LD document to be signed.\n   * @param {boolean} options.addSuiteContext - Add suite context?\n   */\n  ensureSuiteContext({document, addSuiteContext}) {\n    const {contextUrl} = this;\n\n    if(_includesContext({document, contextUrl})) {\n      // document already includes the required context\n      return;\n    }\n\n    if(!addSuiteContext) {\n      throw new TypeError(\n        `The document to be signed must contain this suite's @context, ` +\n        `\"${contextUrl}\".`);\n    }\n\n    // enforce the suite's context by adding it to the document\n    const existingContext = document['@context'] || [];\n\n    document['@context'] = Array.isArray(existingContext) ?\n      [...existingContext, contextUrl] : [existingContext, contextUrl];\n  }\n};\n\n/**\n * Tests whether a provided JSON-LD document includes a context URL in its\n * `@context` property.\n *\n * @param {object} options - Options hashmap.\n * @param {object} options.document - A JSON-LD document.\n * @param {string} options.contextUrl - A context URL.\n *\n * @returns {boolean} Returns true if document includes context.\n */\nfunction _includesContext({document, contextUrl}) {\n  const context = document['@context'];\n  return context === contextUrl ||\n    (Array.isArray(context) && context.includes(contextUrl));\n}\n\n/**\n * See constructor docstring for param details.\n *\n * @returns {{verificationMethod: string, key: LDKeyPair,\n *   signer: {sign: Function, id: string},\n *   verifier: {verify: Function, id: string}}} - Validated and initialized\n *   key-related parameters.\n */\nfunction _processSignatureParams({key, signer, verifier}) {\n  // We are explicitly not requiring a key or signer/verifier param to be\n  // present, to support the verify() use case where the verificationMethod\n  // is being fetched by the documentLoader\n\n  const vm = {};\n  if(key) {\n    vm.key = key;\n    vm.verificationMethod = key.id;\n    if(typeof key.signer === 'function') {\n      vm.signer = key.signer();\n    }\n    if(typeof key.verifier === 'function') {\n      vm.verifier = key.verifier();\n    }\n    if(!(vm.signer || vm.verifier)) {\n      throw new TypeError(\n        'The \"key\" parameter must contain a \"signer\" or \"verifier\" method.');\n    }\n  } else {\n    vm.verificationMethod = (signer && signer.id) ||\n      (verifier && verifier.id);\n    vm.signer = signer;\n    vm.verifier = verifier;\n  }\n\n  if(vm.signer) {\n    if(typeof vm.signer.sign !== 'function') {\n      throw new TypeError('A signer API has not been specified.');\n    }\n  }\n  if(vm.verifier) {\n    if(typeof vm.verifier.verify !== 'function') {\n      throw new TypeError('A verifier API has not been specified.');\n    }\n  }\n\n  return vm;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}