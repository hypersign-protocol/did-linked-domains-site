{"ast":null,"code":"\"use strict\";\n\n/**\n *  The Interface class is a low-level class that accepts an\n *  ABI and provides all the necessary functionality to encode\n *  and decode paramaters to and results from methods, events\n *  and errors.\n *\n *  It also provides several convenience methods to automatically\n *  search and find matching transactions and events to parse them.\n *\n *  @_subsection api/abi:Interfaces  [interfaces]\n */\nvar _classPrivateMethodInitSpec = require(\"/home/pratap/domain-linkege/node_modules/@babel/runtime/helpers/classPrivateMethodInitSpec.js\").default;\nvar _classPrivateFieldInitSpec = require(\"/home/pratap/domain-linkege/node_modules/@babel/runtime/helpers/classPrivateFieldInitSpec.js\").default;\nvar _classPrivateMethodGet = require(\"/home/pratap/domain-linkege/node_modules/@babel/runtime/helpers/classPrivateMethodGet.js\").default;\nvar _classPrivateFieldGet = require(\"/home/pratap/domain-linkege/node_modules/@babel/runtime/helpers/classPrivateFieldGet.js\").default;\nvar _classPrivateFieldSet = require(\"/home/pratap/domain-linkege/node_modules/@babel/runtime/helpers/classPrivateFieldSet.js\").default;\nvar _defineProperty = require(\"/home/pratap/domain-linkege/node_modules/@babel/runtime/helpers/defineProperty.js\").default;\nrequire(\"core-js/modules/es.array.push.js\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Interface = exports.Indexed = exports.ErrorDescription = exports.TransactionDescription = exports.LogDescription = exports.Result = exports.checkResultErrors = void 0;\nconst index_js_1 = require(\"../crypto/index.js\");\nconst index_js_2 = require(\"../hash/index.js\");\nconst index_js_3 = require(\"../utils/index.js\");\nconst abi_coder_js_1 = require(\"./abi-coder.js\");\nconst abstract_coder_js_1 = require(\"./coders/abstract-coder.js\");\nObject.defineProperty(exports, \"checkResultErrors\", {\n  enumerable: true,\n  get: function () {\n    return abstract_coder_js_1.checkResultErrors;\n  }\n});\nObject.defineProperty(exports, \"Result\", {\n  enumerable: true,\n  get: function () {\n    return abstract_coder_js_1.Result;\n  }\n});\nconst fragments_js_1 = require(\"./fragments.js\");\nconst typed_js_1 = require(\"./typed.js\");\n/**\n *  When using the [[Interface-parseLog]] to automatically match a Log to its event\n *  for parsing, a **LogDescription** is returned.\n */\nclass LogDescription {\n  /**\n   *  @_ignore:\n   */\n  constructor(fragment, topic, args) {\n    /**\n     *  The matching fragment for the ``topic0``.\n     */\n    _defineProperty(this, \"fragment\", void 0);\n    /**\n     *  The name of the Event.\n     */\n    _defineProperty(this, \"name\", void 0);\n    /**\n     *  The full Event signature.\n     */\n    _defineProperty(this, \"signature\", void 0);\n    /**\n     *  The topic hash for the Event.\n     */\n    _defineProperty(this, \"topic\", void 0);\n    /**\n     *  The arguments passed into the Event with ``emit``.\n     */\n    _defineProperty(this, \"args\", void 0);\n    const name = fragment.name,\n      signature = fragment.format();\n    (0, index_js_3.defineProperties)(this, {\n      fragment,\n      name,\n      signature,\n      topic,\n      args\n    });\n  }\n}\nexports.LogDescription = LogDescription;\n/**\n *  When using the [[Interface-parseTransaction]] to automatically match\n *  a transaction data to its function for parsing,\n *  a **TransactionDescription** is returned.\n */\nclass TransactionDescription {\n  /**\n   *  @_ignore:\n   */\n  constructor(fragment, selector, args, value) {\n    /**\n     *  The matching fragment from the transaction ``data``.\n     */\n    _defineProperty(this, \"fragment\", void 0);\n    /**\n     *  The name of the Function from the transaction ``data``.\n     */\n    _defineProperty(this, \"name\", void 0);\n    /**\n     *  The arguments passed to the Function from the transaction ``data``.\n     */\n    _defineProperty(this, \"args\", void 0);\n    /**\n     *  The full Function signature from the transaction ``data``.\n     */\n    _defineProperty(this, \"signature\", void 0);\n    /**\n     *  The selector for the Function from the transaction ``data``.\n     */\n    _defineProperty(this, \"selector\", void 0);\n    /**\n     *  The ``value`` (in wei) from the transaction.\n     */\n    _defineProperty(this, \"value\", void 0);\n    const name = fragment.name,\n      signature = fragment.format();\n    (0, index_js_3.defineProperties)(this, {\n      fragment,\n      name,\n      args,\n      signature,\n      selector,\n      value\n    });\n  }\n}\nexports.TransactionDescription = TransactionDescription;\n/**\n *  When using the [[Interface-parseError]] to automatically match an\n *  error for a call result for parsing, an **ErrorDescription** is returned.\n */\nclass ErrorDescription {\n  /**\n   *  @_ignore:\n   */\n  constructor(fragment, selector, args) {\n    /**\n     *  The matching fragment.\n     */\n    _defineProperty(this, \"fragment\", void 0);\n    /**\n     *  The name of the Error.\n     */\n    _defineProperty(this, \"name\", void 0);\n    /**\n     *  The arguments passed to the Error with ``revert``.\n     */\n    _defineProperty(this, \"args\", void 0);\n    /**\n     *  The full Error signature.\n     */\n    _defineProperty(this, \"signature\", void 0);\n    /**\n     *  The selector for the Error.\n     */\n    _defineProperty(this, \"selector\", void 0);\n    const name = fragment.name,\n      signature = fragment.format();\n    (0, index_js_3.defineProperties)(this, {\n      fragment,\n      name,\n      args,\n      signature,\n      selector\n    });\n  }\n}\nexports.ErrorDescription = ErrorDescription;\n/**\n *  An **Indexed** is used as a value when a value that does not\n *  fit within a topic (i.e. not a fixed-length, 32-byte type). It\n *  is the ``keccak256`` of the value, and used for types such as\n *  arrays, tuples, bytes and strings.\n */\nclass Indexed {\n  /**\n   *  Returns ``true`` if %%value%% is an **Indexed**.\n   *\n   *  This provides a Type Guard for property access.\n   */\n  static isIndexed(value) {\n    return !!(value && value._isIndexed);\n  }\n  /**\n   *  @_ignore:\n   */\n  constructor(hash) {\n    /**\n     *  The ``keccak256`` of the value logged.\n     */\n    _defineProperty(this, \"hash\", void 0);\n    /**\n     *  @_ignore:\n     */\n    _defineProperty(this, \"_isIndexed\", void 0);\n    (0, index_js_3.defineProperties)(this, {\n      hash,\n      _isIndexed: true\n    });\n  }\n}\nexports.Indexed = Indexed;\n// https://docs.soliditylang.org/en/v0.8.13/control-structures.html?highlight=panic#panic-via-assert-and-error-via-require\nconst PanicReasons = {\n  \"0\": \"generic panic\",\n  \"1\": \"assert(false)\",\n  \"17\": \"arithmetic overflow\",\n  \"18\": \"division or modulo by zero\",\n  \"33\": \"enum overflow\",\n  \"34\": \"invalid encoded storage byte array accessed\",\n  \"49\": \"out-of-bounds array access; popping on an empty array\",\n  \"50\": \"out-of-bounds access of an array or bytesN\",\n  \"65\": \"out of memory\",\n  \"81\": \"uninitialized function\"\n};\nconst BuiltinErrors = {\n  \"0x08c379a0\": {\n    signature: \"Error(string)\",\n    name: \"Error\",\n    inputs: [\"string\"],\n    reason: message => {\n      return `reverted with reason string ${JSON.stringify(message)}`;\n    }\n  },\n  \"0x4e487b71\": {\n    signature: \"Panic(uint256)\",\n    name: \"Panic\",\n    inputs: [\"uint256\"],\n    reason: code => {\n      let reason = \"unknown panic code\";\n      if (code >= 0 && code <= 0xff && PanicReasons[code.toString()]) {\n        reason = PanicReasons[code.toString()];\n      }\n      return `reverted with panic code 0x${code.toString(16)} (${reason})`;\n    }\n  }\n};\n/**\n *  An Interface abstracts many of the low-level details for\n *  encoding and decoding the data on the blockchain.\n *\n *  An ABI provides information on how to encode data to send to\n *  a Contract, how to decode the results and events and how to\n *  interpret revert errors.\n *\n *  The ABI can be specified by [any supported format](InterfaceAbi).\n */\nvar _errors = /*#__PURE__*/new WeakMap();\nvar _events = /*#__PURE__*/new WeakMap();\nvar _functions = /*#__PURE__*/new WeakMap();\nvar _abiCoder = /*#__PURE__*/new WeakMap();\nvar _getFunction = /*#__PURE__*/new WeakSet();\nvar _getEvent = /*#__PURE__*/new WeakSet();\nclass Interface {\n  /**\n   *  Create a new Interface for the %%fragments%%.\n   */\n  constructor(fragments) {\n    // Find an event definition by any means necessary (unless it is ambiguous)\n    _classPrivateMethodInitSpec(this, _getEvent);\n    // Find a function definition by any means necessary (unless it is ambiguous)\n    _classPrivateMethodInitSpec(this, _getFunction);\n    /**\n     *  All the Contract ABI members (i.e. methods, events, errors, etc).\n     */\n    _defineProperty(this, \"fragments\", void 0);\n    /**\n     *  The Contract constructor.\n     */\n    _defineProperty(this, \"deploy\", void 0);\n    /**\n     *  The Fallback method, if any.\n     */\n    _defineProperty(this, \"fallback\", void 0);\n    /**\n     *  If receiving ether is supported.\n     */\n    _defineProperty(this, \"receive\", void 0);\n    _classPrivateFieldInitSpec(this, _errors, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _events, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _functions, {\n      writable: true,\n      value: void 0\n    });\n    //    #structs: Map<string, StructFragment>;\n    _classPrivateFieldInitSpec(this, _abiCoder, {\n      writable: true,\n      value: void 0\n    });\n    let abi = [];\n    if (typeof fragments === \"string\") {\n      abi = JSON.parse(fragments);\n    } else {\n      abi = fragments;\n    }\n    _classPrivateFieldSet(this, _functions, new Map());\n    _classPrivateFieldSet(this, _errors, new Map());\n    _classPrivateFieldSet(this, _events, new Map());\n    //        this.#structs = new Map();\n    const frags = [];\n    for (const a of abi) {\n      try {\n        frags.push(fragments_js_1.Fragment.from(a));\n      } catch (error) {\n        console.log(\"EE\", error);\n      }\n    }\n    (0, index_js_3.defineProperties)(this, {\n      fragments: Object.freeze(frags)\n    });\n    let fallback = null;\n    let receive = false;\n    _classPrivateFieldSet(this, _abiCoder, this.getAbiCoder());\n    // Add all fragments by their signature\n    this.fragments.forEach((fragment, index) => {\n      let bucket;\n      switch (fragment.type) {\n        case \"constructor\":\n          if (this.deploy) {\n            console.log(\"duplicate definition - constructor\");\n            return;\n          }\n          //checkNames(fragment, \"input\", fragment.inputs);\n          (0, index_js_3.defineProperties)(this, {\n            deploy: fragment\n          });\n          return;\n        case \"fallback\":\n          if (fragment.inputs.length === 0) {\n            receive = true;\n          } else {\n            (0, index_js_3.assertArgument)(!fallback || fragment.payable !== fallback.payable, \"conflicting fallback fragments\", `fragments[${index}]`, fragment);\n            fallback = fragment;\n            receive = fallback.payable;\n          }\n          return;\n        case \"function\":\n          //checkNames(fragment, \"input\", fragment.inputs);\n          //checkNames(fragment, \"output\", (<FunctionFragment>fragment).outputs);\n          bucket = _classPrivateFieldGet(this, _functions);\n          break;\n        case \"event\":\n          //checkNames(fragment, \"input\", fragment.inputs);\n          bucket = _classPrivateFieldGet(this, _events);\n          break;\n        case \"error\":\n          bucket = _classPrivateFieldGet(this, _errors);\n          break;\n        default:\n          return;\n      }\n      // Two identical entries; ignore it\n      const signature = fragment.format();\n      if (bucket.has(signature)) {\n        return;\n      }\n      bucket.set(signature, fragment);\n    });\n    // If we do not have a constructor add a default\n    if (!this.deploy) {\n      (0, index_js_3.defineProperties)(this, {\n        deploy: fragments_js_1.ConstructorFragment.from(\"constructor()\")\n      });\n    }\n    (0, index_js_3.defineProperties)(this, {\n      fallback,\n      receive\n    });\n  }\n  /**\n   *  Returns the entire Human-Readable ABI, as an array of\n   *  signatures, optionally as %%minimal%% strings, which\n   *  removes parameter names and unneceesary spaces.\n   */\n  format(minimal) {\n    const format = minimal ? \"minimal\" : \"full\";\n    const abi = this.fragments.map(f => f.format(format));\n    return abi;\n  }\n  /**\n   *  Return the JSON-encoded ABI. This is the format Solidiy\n   *  returns.\n   */\n  formatJson() {\n    const abi = this.fragments.map(f => f.format(\"json\"));\n    // We need to re-bundle the JSON fragments a bit\n    return JSON.stringify(abi.map(j => JSON.parse(j)));\n  }\n  /**\n   *  The ABI coder that will be used to encode and decode binary\n   *  data.\n   */\n  getAbiCoder() {\n    return abi_coder_js_1.AbiCoder.defaultAbiCoder();\n  }\n  /**\n   *  Get the function name for %%key%%, which may be a function selector,\n   *  function name or function signature that belongs to the ABI.\n   */\n  getFunctionName(key) {\n    const fragment = _classPrivateMethodGet(this, _getFunction, _getFunction2).call(this, key, null, false);\n    (0, index_js_3.assertArgument)(fragment, \"no matching function\", \"key\", key);\n    return fragment.name;\n  }\n  /**\n   *  Returns true if %%key%% (a function selector, function name or\n   *  function signature) is present in the ABI.\n   *\n   *  In the case of a function name, the name may be ambiguous, so\n   *  accessing the [[FunctionFragment]] may require refinement.\n   */\n  hasFunction(key) {\n    return !!_classPrivateMethodGet(this, _getFunction, _getFunction2).call(this, key, null, false);\n  }\n  /**\n   *  Get the [[FunctionFragment]] for %%key%%, which may be a function\n   *  selector, function name or function signature that belongs to the ABI.\n   *\n   *  If %%values%% is provided, it will use the Typed API to handle\n   *  ambiguous cases where multiple functions match by name.\n   *\n   *  If the %%key%% and %%values%% do not refine to a single function in\n   *  the ABI, this will throw.\n   */\n  getFunction(key, values) {\n    return _classPrivateMethodGet(this, _getFunction, _getFunction2).call(this, key, values || null, true);\n  }\n  /**\n   *  Iterate over all functions, calling %%callback%%, sorted by their name.\n   */\n  forEachFunction(callback) {\n    const names = Array.from(_classPrivateFieldGet(this, _functions).keys());\n    names.sort((a, b) => a.localeCompare(b));\n    for (let i = 0; i < names.length; i++) {\n      const name = names[i];\n      callback(_classPrivateFieldGet(this, _functions).get(name), i);\n    }\n  }\n  /**\n   *  Get the event name for %%key%%, which may be a topic hash,\n   *  event name or event signature that belongs to the ABI.\n   */\n  getEventName(key) {\n    const fragment = _classPrivateMethodGet(this, _getEvent, _getEvent2).call(this, key, null, false);\n    (0, index_js_3.assertArgument)(fragment, \"no matching event\", \"key\", key);\n    return fragment.name;\n  }\n  /**\n   *  Returns true if %%key%% (an event topic hash, event name or\n   *  event signature) is present in the ABI.\n   *\n   *  In the case of an event name, the name may be ambiguous, so\n   *  accessing the [[EventFragment]] may require refinement.\n   */\n  hasEvent(key) {\n    return !!_classPrivateMethodGet(this, _getEvent, _getEvent2).call(this, key, null, false);\n  }\n  /**\n   *  Get the [[EventFragment]] for %%key%%, which may be a topic hash,\n   *  event name or event signature that belongs to the ABI.\n   *\n   *  If %%values%% is provided, it will use the Typed API to handle\n   *  ambiguous cases where multiple events match by name.\n   *\n   *  If the %%key%% and %%values%% do not refine to a single event in\n   *  the ABI, this will throw.\n   */\n  getEvent(key, values) {\n    return _classPrivateMethodGet(this, _getEvent, _getEvent2).call(this, key, values || null, true);\n  }\n  /**\n   *  Iterate over all events, calling %%callback%%, sorted by their name.\n   */\n  forEachEvent(callback) {\n    const names = Array.from(_classPrivateFieldGet(this, _events).keys());\n    names.sort((a, b) => a.localeCompare(b));\n    for (let i = 0; i < names.length; i++) {\n      const name = names[i];\n      callback(_classPrivateFieldGet(this, _events).get(name), i);\n    }\n  }\n  /**\n   *  Get the [[ErrorFragment]] for %%key%%, which may be an error\n   *  selector, error name or error signature that belongs to the ABI.\n   *\n   *  If %%values%% is provided, it will use the Typed API to handle\n   *  ambiguous cases where multiple errors match by name.\n   *\n   *  If the %%key%% and %%values%% do not refine to a single error in\n   *  the ABI, this will throw.\n   */\n  getError(key, values) {\n    if ((0, index_js_3.isHexString)(key)) {\n      const selector = key.toLowerCase();\n      if (BuiltinErrors[selector]) {\n        return fragments_js_1.ErrorFragment.from(BuiltinErrors[selector].signature);\n      }\n      for (const fragment of _classPrivateFieldGet(this, _errors).values()) {\n        if (selector === fragment.selector) {\n          return fragment;\n        }\n      }\n      return null;\n    }\n    // It is a bare name, look up the function (will return null if ambiguous)\n    if (key.indexOf(\"(\") === -1) {\n      const matching = [];\n      for (const [name, fragment] of _classPrivateFieldGet(this, _errors)) {\n        if (name.split(\"(\" /* fix:) */)[0] === key) {\n          matching.push(fragment);\n        }\n      }\n      if (matching.length === 0) {\n        if (key === \"Error\") {\n          return fragments_js_1.ErrorFragment.from(\"error Error(string)\");\n        }\n        if (key === \"Panic\") {\n          return fragments_js_1.ErrorFragment.from(\"error Panic(uint256)\");\n        }\n        return null;\n      } else if (matching.length > 1) {\n        const matchStr = matching.map(m => JSON.stringify(m.format())).join(\", \");\n        (0, index_js_3.assertArgument)(false, `ambiguous error description (i.e. ${matchStr})`, \"name\", key);\n      }\n      return matching[0];\n    }\n    // Normalize the signature and lookup the function\n    key = fragments_js_1.ErrorFragment.from(key).format();\n    if (key === \"Error(string)\") {\n      return fragments_js_1.ErrorFragment.from(\"error Error(string)\");\n    }\n    if (key === \"Panic(uint256)\") {\n      return fragments_js_1.ErrorFragment.from(\"error Panic(uint256)\");\n    }\n    const result = _classPrivateFieldGet(this, _errors).get(key);\n    if (result) {\n      return result;\n    }\n    return null;\n  }\n  /**\n   *  Iterate over all errors, calling %%callback%%, sorted by their name.\n   */\n  forEachError(callback) {\n    const names = Array.from(_classPrivateFieldGet(this, _errors).keys());\n    names.sort((a, b) => a.localeCompare(b));\n    for (let i = 0; i < names.length; i++) {\n      const name = names[i];\n      callback(_classPrivateFieldGet(this, _errors).get(name), i);\n    }\n  }\n  // Get the 4-byte selector used by Solidity to identify a function\n  /*\n  getSelector(fragment: ErrorFragment | FunctionFragment): string {\n  if (typeof(fragment) === \"string\") {\n      const matches: Array<Fragment> = [ ];\n       try { matches.push(this.getFunction(fragment)); } catch (error) { }\n      try { matches.push(this.getError(<string>fragment)); } catch (_) { }\n       if (matches.length === 0) {\n          logger.throwArgumentError(\"unknown fragment\", \"key\", fragment);\n      } else if (matches.length > 1) {\n          logger.throwArgumentError(\"ambiguous fragment matches function and error\", \"key\", fragment);\n      }\n       fragment = matches[0];\n  }\n   return dataSlice(id(fragment.format()), 0, 4);\n  }\n  */\n  // Get the 32-byte topic hash used by Solidity to identify an event\n  /*\n  getEventTopic(fragment: EventFragment): string {\n      //if (typeof(fragment) === \"string\") { fragment = this.getEvent(eventFragment); }\n      return id(fragment.format());\n  }\n  */\n  _decodeParams(params, data) {\n    return _classPrivateFieldGet(this, _abiCoder).decode(params, data);\n  }\n  _encodeParams(params, values) {\n    return _classPrivateFieldGet(this, _abiCoder).encode(params, values);\n  }\n  /**\n   *  Encodes a ``tx.data`` object for deploying the Contract with\n   *  the %%values%% as the constructor arguments.\n   */\n  encodeDeploy(values) {\n    return this._encodeParams(this.deploy.inputs, values || []);\n  }\n  /**\n   *  Decodes the result %%data%% (e.g. from an ``eth_call``) for the\n   *  specified error (see [[getError]] for valid values for\n   *  %%key%%).\n   *\n   *  Most developers should prefer the [[parseCallResult]] method instead,\n   *  which will automatically detect a ``CALL_EXCEPTION`` and throw the\n   *  corresponding error.\n   */\n  decodeErrorResult(fragment, data) {\n    if (typeof fragment === \"string\") {\n      const f = this.getError(fragment);\n      (0, index_js_3.assertArgument)(f, \"unknown error\", \"fragment\", fragment);\n      fragment = f;\n    }\n    (0, index_js_3.assertArgument)((0, index_js_3.dataSlice)(data, 0, 4) === fragment.selector, `data signature does not match error ${fragment.name}.`, \"data\", data);\n    return this._decodeParams(fragment.inputs, (0, index_js_3.dataSlice)(data, 4));\n  }\n  /**\n   *  Encodes the transaction revert data for a call result that\n   *  reverted from the the Contract with the sepcified %%error%%\n   *  (see [[getError]] for valid values for %%fragment%%) with the %%values%%.\n   *\n   *  This is generally not used by most developers, unless trying to mock\n   *  a result from a Contract.\n   */\n  encodeErrorResult(fragment, values) {\n    if (typeof fragment === \"string\") {\n      const f = this.getError(fragment);\n      (0, index_js_3.assertArgument)(f, \"unknown error\", \"fragment\", fragment);\n      fragment = f;\n    }\n    return (0, index_js_3.concat)([fragment.selector, this._encodeParams(fragment.inputs, values || [])]);\n  }\n  /**\n   *  Decodes the %%data%% from a transaction ``tx.data`` for\n   *  the function specified (see [[getFunction]] for valid values\n   *  for %%fragment%%).\n   *\n   *  Most developers should prefer the [[parseTransaction]] method\n   *  instead, which will automatically detect the fragment.\n   */\n  decodeFunctionData(fragment, data) {\n    if (typeof fragment === \"string\") {\n      const f = this.getFunction(fragment);\n      (0, index_js_3.assertArgument)(f, \"unknown function\", \"fragment\", fragment);\n      fragment = f;\n    }\n    (0, index_js_3.assertArgument)((0, index_js_3.dataSlice)(data, 0, 4) === fragment.selector, `data signature does not match function ${fragment.name}.`, \"data\", data);\n    return this._decodeParams(fragment.inputs, (0, index_js_3.dataSlice)(data, 4));\n  }\n  /**\n   *  Encodes the ``tx.data`` for a transaction that calls the function\n   *  specified (see [[getFunction]] for valid values for %%fragment%%) with\n   *  the %%values%%.\n   */\n  encodeFunctionData(fragment, values) {\n    if (typeof fragment === \"string\") {\n      const f = this.getFunction(fragment);\n      (0, index_js_3.assertArgument)(f, \"unknown function\", \"fragment\", fragment);\n      fragment = f;\n    }\n    return (0, index_js_3.concat)([fragment.selector, this._encodeParams(fragment.inputs, values || [])]);\n  }\n  /**\n   *  Decodes the result %%data%% (e.g. from an ``eth_call``) for the\n   *  specified function (see [[getFunction]] for valid values for\n   *  %%key%%).\n   *\n   *  Most developers should prefer the [[parseCallResult]] method instead,\n   *  which will automatically detect a ``CALL_EXCEPTION`` and throw the\n   *  corresponding error.\n   */\n  decodeFunctionResult(fragment, data) {\n    if (typeof fragment === \"string\") {\n      const f = this.getFunction(fragment);\n      (0, index_js_3.assertArgument)(f, \"unknown function\", \"fragment\", fragment);\n      fragment = f;\n    }\n    let message = \"invalid length for result data\";\n    const bytes = (0, index_js_3.getBytesCopy)(data);\n    if (bytes.length % 32 === 0) {\n      try {\n        return _classPrivateFieldGet(this, _abiCoder).decode(fragment.outputs, bytes);\n      } catch (error) {\n        message = \"could not decode result data\";\n      }\n    }\n    // Call returned data with no error, but the data is junk\n    (0, index_js_3.assert)(false, message, \"BAD_DATA\", {\n      value: (0, index_js_3.hexlify)(bytes),\n      info: {\n        method: fragment.name,\n        signature: fragment.format()\n      }\n    });\n  }\n  makeError(_data, tx) {\n    const data = (0, index_js_3.getBytes)(_data, \"data\");\n    const error = abi_coder_js_1.AbiCoder.getBuiltinCallException(\"call\", tx, data);\n    // Not a built-in error; try finding a custom error\n    const customPrefix = \"execution reverted (unknown custom error)\";\n    if (error.message.startsWith(customPrefix)) {\n      const selector = (0, index_js_3.hexlify)(data.slice(0, 4));\n      const ef = this.getError(selector);\n      if (ef) {\n        try {\n          const args = _classPrivateFieldGet(this, _abiCoder).decode(ef.inputs, data.slice(4));\n          error.revert = {\n            name: ef.name,\n            signature: ef.format(),\n            args\n          };\n          error.reason = error.revert.signature;\n          error.message = `execution reverted: ${error.reason}`;\n        } catch (e) {\n          error.message = `execution reverted (coult not decode custom error)`;\n        }\n      }\n    }\n    // Add the invocation, if available\n    const parsed = this.parseTransaction(tx);\n    if (parsed) {\n      error.invocation = {\n        method: parsed.name,\n        signature: parsed.signature,\n        args: parsed.args\n      };\n    }\n    return error;\n  }\n  /**\n   *  Encodes the result data (e.g. from an ``eth_call``) for the\n   *  specified function (see [[getFunction]] for valid values\n   *  for %%fragment%%) with %%values%%.\n   *\n   *  This is generally not used by most developers, unless trying to mock\n   *  a result from a Contract.\n   */\n  encodeFunctionResult(fragment, values) {\n    if (typeof fragment === \"string\") {\n      const f = this.getFunction(fragment);\n      (0, index_js_3.assertArgument)(f, \"unknown function\", \"fragment\", fragment);\n      fragment = f;\n    }\n    return (0, index_js_3.hexlify)(_classPrivateFieldGet(this, _abiCoder).encode(fragment.outputs, values || []));\n  }\n  /*\n      spelunk(inputs: Array<ParamType>, values: ReadonlyArray<any>, processfunc: (type: string, value: any) => Promise<any>): Promise<Array<any>> {\n          const promises: Array<Promise<>> = [ ];\n          const process = function(type: ParamType, value: any): any {\n              if (type.baseType === \"array\") {\n                  return descend(type.child\n              }\n              if (type. === \"address\") {\n              }\n          };\n  \n          const descend = function (inputs: Array<ParamType>, values: ReadonlyArray<any>) {\n              if (inputs.length !== values.length) { throw new Error(\"length mismatch\"); }\n              \n          };\n  \n          const result: Array<any> = [ ];\n          values.forEach((value, index) => {\n              if (value == null) {\n                  topics.push(null);\n              } else if (param.baseType === \"array\" || param.baseType === \"tuple\") {\n                  logger.throwArgumentError(\"filtering with tuples or arrays not supported\", (\"contract.\" + param.name), value);\n              } else if (Array.isArray(value)) {\n                  topics.push(value.map((value) => encodeTopic(param, value)));\n              } else {\n                  topics.push(encodeTopic(param, value));\n              }\n          });\n      }\n  */\n  // Create the filter for the event with search criteria (e.g. for eth_filterLog)\n  encodeFilterTopics(fragment, values) {\n    if (typeof fragment === \"string\") {\n      const f = this.getEvent(fragment);\n      (0, index_js_3.assertArgument)(f, \"unknown event\", \"eventFragment\", fragment);\n      fragment = f;\n    }\n    (0, index_js_3.assert)(values.length <= fragment.inputs.length, `too many arguments for ${fragment.format()}`, \"UNEXPECTED_ARGUMENT\", {\n      count: values.length,\n      expectedCount: fragment.inputs.length\n    });\n    const topics = [];\n    if (!fragment.anonymous) {\n      topics.push(fragment.topicHash);\n    }\n    // @TODO: Use the coders for this; to properly support tuples, etc.\n    const encodeTopic = (param, value) => {\n      if (param.type === \"string\") {\n        return (0, index_js_2.id)(value);\n      } else if (param.type === \"bytes\") {\n        return (0, index_js_1.keccak256)((0, index_js_3.hexlify)(value));\n      }\n      if (param.type === \"bool\" && typeof value === \"boolean\") {\n        value = value ? \"0x01\" : \"0x00\";\n      } else if (param.type.match(/^u?int/)) {\n        value = (0, index_js_3.toBeHex)(value); // @TODO: Should this toTwos??\n      } else if (param.type.match(/^bytes/)) {\n        value = (0, index_js_3.zeroPadBytes)(value, 32);\n      } else if (param.type === \"address\") {\n        // Check addresses are valid\n        _classPrivateFieldGet(this, _abiCoder).encode([\"address\"], [value]);\n      }\n      return (0, index_js_3.zeroPadValue)((0, index_js_3.hexlify)(value), 32);\n    };\n    values.forEach((value, index) => {\n      const param = fragment.inputs[index];\n      if (!param.indexed) {\n        (0, index_js_3.assertArgument)(value == null, \"cannot filter non-indexed parameters; must be null\", \"contract.\" + param.name, value);\n        return;\n      }\n      if (value == null) {\n        topics.push(null);\n      } else if (param.baseType === \"array\" || param.baseType === \"tuple\") {\n        (0, index_js_3.assertArgument)(false, \"filtering with tuples or arrays not supported\", \"contract.\" + param.name, value);\n      } else if (Array.isArray(value)) {\n        topics.push(value.map(value => encodeTopic(param, value)));\n      } else {\n        topics.push(encodeTopic(param, value));\n      }\n    });\n    // Trim off trailing nulls\n    while (topics.length && topics[topics.length - 1] === null) {\n      topics.pop();\n    }\n    return topics;\n  }\n  encodeEventLog(fragment, values) {\n    if (typeof fragment === \"string\") {\n      const f = this.getEvent(fragment);\n      (0, index_js_3.assertArgument)(f, \"unknown event\", \"eventFragment\", fragment);\n      fragment = f;\n    }\n    const topics = [];\n    const dataTypes = [];\n    const dataValues = [];\n    if (!fragment.anonymous) {\n      topics.push(fragment.topicHash);\n    }\n    (0, index_js_3.assertArgument)(values.length === fragment.inputs.length, \"event arguments/values mismatch\", \"values\", values);\n    fragment.inputs.forEach((param, index) => {\n      const value = values[index];\n      if (param.indexed) {\n        if (param.type === \"string\") {\n          topics.push((0, index_js_2.id)(value));\n        } else if (param.type === \"bytes\") {\n          topics.push((0, index_js_1.keccak256)(value));\n        } else if (param.baseType === \"tuple\" || param.baseType === \"array\") {\n          // @TODO\n          throw new Error(\"not implemented\");\n        } else {\n          topics.push(_classPrivateFieldGet(this, _abiCoder).encode([param.type], [value]));\n        }\n      } else {\n        dataTypes.push(param);\n        dataValues.push(value);\n      }\n    });\n    return {\n      data: _classPrivateFieldGet(this, _abiCoder).encode(dataTypes, dataValues),\n      topics: topics\n    };\n  }\n  // Decode a filter for the event and the search criteria\n  decodeEventLog(fragment, data, topics) {\n    if (typeof fragment === \"string\") {\n      const f = this.getEvent(fragment);\n      (0, index_js_3.assertArgument)(f, \"unknown event\", \"eventFragment\", fragment);\n      fragment = f;\n    }\n    if (topics != null && !fragment.anonymous) {\n      const eventTopic = fragment.topicHash;\n      (0, index_js_3.assertArgument)((0, index_js_3.isHexString)(topics[0], 32) && topics[0].toLowerCase() === eventTopic, \"fragment/topic mismatch\", \"topics[0]\", topics[0]);\n      topics = topics.slice(1);\n    }\n    const indexed = [];\n    const nonIndexed = [];\n    const dynamic = [];\n    fragment.inputs.forEach((param, index) => {\n      if (param.indexed) {\n        if (param.type === \"string\" || param.type === \"bytes\" || param.baseType === \"tuple\" || param.baseType === \"array\") {\n          indexed.push(fragments_js_1.ParamType.from({\n            type: \"bytes32\",\n            name: param.name\n          }));\n          dynamic.push(true);\n        } else {\n          indexed.push(param);\n          dynamic.push(false);\n        }\n      } else {\n        nonIndexed.push(param);\n        dynamic.push(false);\n      }\n    });\n    const resultIndexed = topics != null ? _classPrivateFieldGet(this, _abiCoder).decode(indexed, (0, index_js_3.concat)(topics)) : null;\n    const resultNonIndexed = _classPrivateFieldGet(this, _abiCoder).decode(nonIndexed, data, true);\n    //const result: (Array<any> & { [ key: string ]: any }) = [ ];\n    const values = [];\n    const keys = [];\n    let nonIndexedIndex = 0,\n      indexedIndex = 0;\n    fragment.inputs.forEach((param, index) => {\n      let value = null;\n      if (param.indexed) {\n        if (resultIndexed == null) {\n          value = new Indexed(null);\n        } else if (dynamic[index]) {\n          value = new Indexed(resultIndexed[indexedIndex++]);\n        } else {\n          try {\n            value = resultIndexed[indexedIndex++];\n          } catch (error) {\n            value = error;\n          }\n        }\n      } else {\n        try {\n          value = resultNonIndexed[nonIndexedIndex++];\n        } catch (error) {\n          value = error;\n        }\n      }\n      values.push(value);\n      keys.push(param.name || null);\n    });\n    return abstract_coder_js_1.Result.fromItems(values, keys);\n  }\n  /**\n   *  Parses a transaction, finding the matching function and extracts\n   *  the parameter values along with other useful function details.\n   *\n   *  If the matching function cannot be found, return null.\n   */\n  parseTransaction(tx) {\n    const data = (0, index_js_3.getBytes)(tx.data, \"tx.data\");\n    const value = (0, index_js_3.getBigInt)(tx.value != null ? tx.value : 0, \"tx.value\");\n    const fragment = this.getFunction((0, index_js_3.hexlify)(data.slice(0, 4)));\n    if (!fragment) {\n      return null;\n    }\n    const args = _classPrivateFieldGet(this, _abiCoder).decode(fragment.inputs, data.slice(4));\n    return new TransactionDescription(fragment, fragment.selector, args, value);\n  }\n  parseCallResult(data) {\n    throw new Error(\"@TODO\");\n  }\n  /**\n   *  Parses a receipt log, finding the matching event and extracts\n   *  the parameter values along with other useful event details.\n   *\n   *  If the matching event cannot be found, returns null.\n   */\n  parseLog(log) {\n    const fragment = this.getEvent(log.topics[0]);\n    if (!fragment || fragment.anonymous) {\n      return null;\n    }\n    // @TODO: If anonymous, and the only method, and the input count matches, should we parse?\n    //        Probably not, because just because it is the only event in the ABI does\n    //        not mean we have the full ABI; maybe just a fragment?\n    return new LogDescription(fragment, fragment.topicHash, this.decodeEventLog(fragment, log.data, log.topics));\n  }\n  /**\n   *  Parses a revert data, finding the matching error and extracts\n   *  the parameter values along with other useful error details.\n   *\n   *  If the matching event cannot be found, returns null.\n   */\n  parseError(data) {\n    const hexData = (0, index_js_3.hexlify)(data);\n    const fragment = this.getError((0, index_js_3.dataSlice)(hexData, 0, 4));\n    if (!fragment) {\n      return null;\n    }\n    const args = _classPrivateFieldGet(this, _abiCoder).decode(fragment.inputs, (0, index_js_3.dataSlice)(hexData, 4));\n    return new ErrorDescription(fragment, fragment.selector, args);\n  }\n  /**\n   *  Creates a new [[Interface]] from the ABI %%value%%.\n   *\n   *  The %%value%% may be provided as an existing [[Interface]] object,\n   *  a JSON-encoded ABI or any Human-Readable ABI format.\n   */\n  static from(value) {\n    // Already an Interface, which is immutable\n    if (value instanceof Interface) {\n      return value;\n    }\n    // JSON\n    if (typeof value === \"string\") {\n      return new Interface(JSON.parse(value));\n    }\n    // Maybe an interface from an older version, or from a symlinked copy\n    if (typeof value.format === \"function\") {\n      return new Interface(value.format(\"json\"));\n    }\n    // Array of fragments\n    return new Interface(value);\n  }\n}\nfunction _getFunction2(key, values, forceUnique) {\n  // Selector\n  if ((0, index_js_3.isHexString)(key)) {\n    const selector = key.toLowerCase();\n    for (const fragment of _classPrivateFieldGet(this, _functions).values()) {\n      if (selector === fragment.selector) {\n        return fragment;\n      }\n    }\n    return null;\n  }\n  // It is a bare name, look up the function (will return null if ambiguous)\n  if (key.indexOf(\"(\") === -1) {\n    const matching = [];\n    for (const [name, fragment] of _classPrivateFieldGet(this, _functions)) {\n      if (name.split(\"(\" /* fix:) */)[0] === key) {\n        matching.push(fragment);\n      }\n    }\n    if (values) {\n      const lastValue = values.length > 0 ? values[values.length - 1] : null;\n      let valueLength = values.length;\n      let allowOptions = true;\n      if (typed_js_1.Typed.isTyped(lastValue) && lastValue.type === \"overrides\") {\n        allowOptions = false;\n        valueLength--;\n      }\n      // Remove all matches that don't have a compatible length. The args\n      // may contain an overrides, so the match may have n or n - 1 parameters\n      for (let i = matching.length - 1; i >= 0; i--) {\n        const inputs = matching[i].inputs.length;\n        if (inputs !== valueLength && (!allowOptions || inputs !== valueLength - 1)) {\n          matching.splice(i, 1);\n        }\n      }\n      // Remove all matches that don't match the Typed signature\n      for (let i = matching.length - 1; i >= 0; i--) {\n        const inputs = matching[i].inputs;\n        for (let j = 0; j < values.length; j++) {\n          // Not a typed value\n          if (!typed_js_1.Typed.isTyped(values[j])) {\n            continue;\n          }\n          // We are past the inputs\n          if (j >= inputs.length) {\n            if (values[j].type === \"overrides\") {\n              continue;\n            }\n            matching.splice(i, 1);\n            break;\n          }\n          // Make sure the value type matches the input type\n          if (values[j].type !== inputs[j].baseType) {\n            matching.splice(i, 1);\n            break;\n          }\n        }\n      }\n    }\n    // We found a single matching signature with an overrides, but the\n    // last value is something that cannot possibly be an options\n    if (matching.length === 1 && values && values.length !== matching[0].inputs.length) {\n      const lastArg = values[values.length - 1];\n      if (lastArg == null || Array.isArray(lastArg) || typeof lastArg !== \"object\") {\n        matching.splice(0, 1);\n      }\n    }\n    if (matching.length === 0) {\n      return null;\n    }\n    if (matching.length > 1 && forceUnique) {\n      const matchStr = matching.map(m => JSON.stringify(m.format())).join(\", \");\n      (0, index_js_3.assertArgument)(false, `ambiguous function description (i.e. matches ${matchStr})`, \"key\", key);\n    }\n    return matching[0];\n  }\n  // Normalize the signature and lookup the function\n  const result = _classPrivateFieldGet(this, _functions).get(fragments_js_1.FunctionFragment.from(key).format());\n  if (result) {\n    return result;\n  }\n  return null;\n}\nfunction _getEvent2(key, values, forceUnique) {\n  // EventTopic\n  if ((0, index_js_3.isHexString)(key)) {\n    const eventTopic = key.toLowerCase();\n    for (const fragment of _classPrivateFieldGet(this, _events).values()) {\n      if (eventTopic === fragment.topicHash) {\n        return fragment;\n      }\n    }\n    return null;\n  }\n  // It is a bare name, look up the function (will return null if ambiguous)\n  if (key.indexOf(\"(\") === -1) {\n    const matching = [];\n    for (const [name, fragment] of _classPrivateFieldGet(this, _events)) {\n      if (name.split(\"(\" /* fix:) */)[0] === key) {\n        matching.push(fragment);\n      }\n    }\n    if (values) {\n      // Remove all matches that don't have a compatible length.\n      for (let i = matching.length - 1; i >= 0; i--) {\n        if (matching[i].inputs.length < values.length) {\n          matching.splice(i, 1);\n        }\n      }\n      // Remove all matches that don't match the Typed signature\n      for (let i = matching.length - 1; i >= 0; i--) {\n        const inputs = matching[i].inputs;\n        for (let j = 0; j < values.length; j++) {\n          // Not a typed value\n          if (!typed_js_1.Typed.isTyped(values[j])) {\n            continue;\n          }\n          // Make sure the value type matches the input type\n          if (values[j].type !== inputs[j].baseType) {\n            matching.splice(i, 1);\n            break;\n          }\n        }\n      }\n    }\n    if (matching.length === 0) {\n      return null;\n    }\n    if (matching.length > 1 && forceUnique) {\n      const matchStr = matching.map(m => JSON.stringify(m.format())).join(\", \");\n      (0, index_js_3.assertArgument)(false, `ambiguous event description (i.e. matches ${matchStr})`, \"key\", key);\n    }\n    return matching[0];\n  }\n  // Normalize the signature and lookup the function\n  const result = _classPrivateFieldGet(this, _events).get(fragments_js_1.EventFragment.from(key).format());\n  if (result) {\n    return result;\n  }\n  return null;\n}\nexports.Interface = Interface;","map":{"version":3,"names":["_classPrivateMethodInitSpec","require","default","_classPrivateFieldInitSpec","_classPrivateMethodGet","_classPrivateFieldGet","_classPrivateFieldSet","_defineProperty","index_js_1","index_js_2","index_js_3","abi_coder_js_1","abstract_coder_js_1","Object","defineProperty","exports","enumerable","get","checkResultErrors","Result","fragments_js_1","typed_js_1","LogDescription","constructor","fragment","topic","args","name","signature","format","defineProperties","TransactionDescription","selector","value","ErrorDescription","Indexed","isIndexed","_isIndexed","hash","PanicReasons","BuiltinErrors","inputs","reason","message","JSON","stringify","code","toString","_errors","WeakMap","_events","_functions","_abiCoder","_getFunction","WeakSet","_getEvent","Interface","fragments","writable","abi","parse","Map","frags","a","push","Fragment","from","error","console","log","freeze","fallback","receive","getAbiCoder","forEach","index","bucket","type","deploy","length","assertArgument","payable","has","set","ConstructorFragment","minimal","map","f","formatJson","j","AbiCoder","defaultAbiCoder","getFunctionName","key","_getFunction2","call","hasFunction","getFunction","values","forEachFunction","callback","names","Array","keys","sort","b","localeCompare","i","getEventName","_getEvent2","hasEvent","getEvent","forEachEvent","getError","isHexString","toLowerCase","ErrorFragment","indexOf","matching","split","matchStr","m","join","result","forEachError","_decodeParams","params","data","decode","_encodeParams","encode","encodeDeploy","decodeErrorResult","dataSlice","encodeErrorResult","concat","decodeFunctionData","encodeFunctionData","decodeFunctionResult","bytes","getBytesCopy","outputs","assert","hexlify","info","method","makeError","_data","tx","getBytes","getBuiltinCallException","customPrefix","startsWith","slice","ef","revert","e","parsed","parseTransaction","invocation","encodeFunctionResult","encodeFilterTopics","count","expectedCount","topics","anonymous","topicHash","encodeTopic","param","id","keccak256","match","toBeHex","zeroPadBytes","zeroPadValue","indexed","baseType","isArray","pop","encodeEventLog","dataTypes","dataValues","Error","decodeEventLog","eventTopic","nonIndexed","dynamic","ParamType","resultIndexed","resultNonIndexed","nonIndexedIndex","indexedIndex","fromItems","getBigInt","parseCallResult","parseLog","parseError","hexData","forceUnique","lastValue","valueLength","allowOptions","Typed","isTyped","splice","lastArg","FunctionFragment","EventFragment"],"sources":["../../src.ts/abi/interface.ts"],"sourcesContent":[null],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}