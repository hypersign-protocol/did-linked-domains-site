{"ast":null,"code":"/*!\n * Copyright (c) 2018-2023 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n\nmodule.exports = class LinkedDataProof {\n  constructor({\n    type\n  } = {}) {\n    if (typeof type !== 'string') {\n      throw new TypeError('A LinkedDataProof must have a \"type\".');\n    }\n    this.type = type;\n  }\n\n  /**\n   * @param {object} options - The options to use.\n   * @param {object} options.document - The document to be signed.\n   * @param {ProofPurpose} options.purpose - The proof purpose instance.\n   * @param {Array} options.proofSet - Any existing proof set.\n   * @param {function} options.documentLoader - The document loader to use.\n   * @param {function} options.expansionMap - NOT SUPPORTED; do not use.\n   *\n   * @returns {Promise<object>} Resolves with the created proof object.\n   */\n  async createProof({\n    /* document, purpose, proofSet, documentLoader, expansionMap */\n  }) {\n    throw new Error('\"createProof\" must be implemented in a derived class.');\n  }\n\n  /**\n   * @param {object} options - The options to use.\n   * @param {object} options.document - The document from which to derive\n   *   a new document and proof.\n   * @param {ProofPurpose} options.purpose - The proof purpose instance.\n   * @param {Array} options.proofSet - Any existing proof set.\n   * @param {function} options.documentLoader - The document loader to use.\n   *\n   * @returns {Promise<object>} Resolves with the new document with a new\n   *   `proof` field.\n   */\n  async derive({\n    /* document, purpose, proofSet, documentLoader */\n  }) {\n    throw new Error('\"deriveProof\" must be implemented in a derived class.');\n  }\n\n  /**\n   * @param {object} options - The options to use.\n   * @param {object} options.proof - The proof to be verified.\n   * @param {object} options.document - The document the proof applies to.\n   * @param {ProofPurpose} options.purpose - The proof purpose instance.\n   * @param {Array} options.proofSet - Any existing proof set.\n   * @param {function} options.documentLoader - The document loader to use.\n   * @param {function} options.expansionMap - NOT SUPPORTED; do not use.\n   *\n   * @returns {Promise<{object}>} Resolves with the verification result.\n   */\n  async verifyProof({\n    /* proof, document, purpose, proofSet, documentLoader, expansionMap */\n  }) {\n    throw new Error('\"verifyProof\" must be implemented in a derived class.');\n  }\n\n  /**\n   * Checks whether a given proof exists in the document.\n   *\n   * @param {object} options - The options to use.\n   * @param {object} options.proof - The proof to match.\n   *\n   * @returns {Promise<boolean>} Whether a match for the proof was found.\n   */\n  async matchProof({\n    proof /*, document, purpose, documentLoader, expansionMap */\n  }) {\n    return proof.type === this.type;\n  }\n};","map":{"version":3,"names":["module","exports","LinkedDataProof","constructor","type","TypeError","createProof","Error","derive","verifyProof","matchProof","proof"],"sources":["/home/pratap/domain-linkege/node_modules/jsonld-signatures/lib/suites/LinkedDataProof.js"],"sourcesContent":["/*!\n * Copyright (c) 2018-2023 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n\nmodule.exports = class LinkedDataProof {\n  constructor({type} = {}) {\n    if(typeof type !== 'string') {\n      throw new TypeError('A LinkedDataProof must have a \"type\".');\n    }\n    this.type = type;\n  }\n\n  /**\n   * @param {object} options - The options to use.\n   * @param {object} options.document - The document to be signed.\n   * @param {ProofPurpose} options.purpose - The proof purpose instance.\n   * @param {Array} options.proofSet - Any existing proof set.\n   * @param {function} options.documentLoader - The document loader to use.\n   * @param {function} options.expansionMap - NOT SUPPORTED; do not use.\n   *\n   * @returns {Promise<object>} Resolves with the created proof object.\n   */\n  async createProof({\n    /* document, purpose, proofSet, documentLoader, expansionMap */\n  }) {\n    throw new Error('\"createProof\" must be implemented in a derived class.');\n  }\n\n  /**\n   * @param {object} options - The options to use.\n   * @param {object} options.document - The document from which to derive\n   *   a new document and proof.\n   * @param {ProofPurpose} options.purpose - The proof purpose instance.\n   * @param {Array} options.proofSet - Any existing proof set.\n   * @param {function} options.documentLoader - The document loader to use.\n   *\n   * @returns {Promise<object>} Resolves with the new document with a new\n   *   `proof` field.\n   */\n  async derive({\n    /* document, purpose, proofSet, documentLoader */\n  }) {\n    throw new Error('\"deriveProof\" must be implemented in a derived class.');\n  }\n\n  /**\n   * @param {object} options - The options to use.\n   * @param {object} options.proof - The proof to be verified.\n   * @param {object} options.document - The document the proof applies to.\n   * @param {ProofPurpose} options.purpose - The proof purpose instance.\n   * @param {Array} options.proofSet - Any existing proof set.\n   * @param {function} options.documentLoader - The document loader to use.\n   * @param {function} options.expansionMap - NOT SUPPORTED; do not use.\n   *\n   * @returns {Promise<{object}>} Resolves with the verification result.\n   */\n  async verifyProof({\n    /* proof, document, purpose, proofSet, documentLoader, expansionMap */\n  }) {\n    throw new Error('\"verifyProof\" must be implemented in a derived class.');\n  }\n\n  /**\n   * Checks whether a given proof exists in the document.\n   *\n   * @param {object} options - The options to use.\n   * @param {object} options.proof - The proof to match.\n   *\n   * @returns {Promise<boolean>} Whether a match for the proof was found.\n   */\n  async matchProof({\n    proof /*, document, purpose, documentLoader, expansionMap */\n  }) {\n    return proof.type === this.type;\n  }\n};\n"],"mappings":"AAAA;AACA;AACA;AACA,YAAY;;AAEZA,MAAM,CAACC,OAAO,GAAG,MAAMC,eAAe,CAAC;EACrCC,WAAWA,CAAC;IAACC;EAAI,CAAC,GAAG,CAAC,CAAC,EAAE;IACvB,IAAG,OAAOA,IAAI,KAAK,QAAQ,EAAE;MAC3B,MAAM,IAAIC,SAAS,CAAC,uCAAuC,CAAC;IAC9D;IACA,IAAI,CAACD,IAAI,GAAGA,IAAI;EAClB;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,MAAME,WAAWA,CAAC;IAChB;EAAA,CACD,EAAE;IACD,MAAM,IAAIC,KAAK,CAAC,uDAAuD,CAAC;EAC1E;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,MAAMC,MAAMA,CAAC;IACX;EAAA,CACD,EAAE;IACD,MAAM,IAAID,KAAK,CAAC,uDAAuD,CAAC;EAC1E;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,MAAME,WAAWA,CAAC;IAChB;EAAA,CACD,EAAE;IACD,MAAM,IAAIF,KAAK,CAAC,uDAAuD,CAAC;EAC1E;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACE,MAAMG,UAAUA,CAAC;IACfC,KAAK,CAAC;EACR,CAAC,EAAE;IACD,OAAOA,KAAK,CAACP,IAAI,KAAK,IAAI,CAACA,IAAI;EACjC;AACF,CAAC"},"metadata":{},"sourceType":"script","externalDependencies":[]}