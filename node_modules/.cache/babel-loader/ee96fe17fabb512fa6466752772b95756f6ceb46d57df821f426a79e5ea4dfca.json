{"ast":null,"code":"/**\n * A JavaScript implementation of Verifiable Credentials.\n *\n * @author Dave Longley\n * @author David I. Lehn\n *\n * @license BSD 3-Clause License\n * Copyright (c) 2017-2021 Digital Bazaar, Inc.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * Redistributions of source code must retain the above copyright notice,\n * this list of conditions and the following disclaimer.\n *\n * Redistributions in binary form must reproduce the above copyright\n * notice, this list of conditions and the following disclaimer in the\n * documentation and/or other materials provided with the distribution.\n *\n * Neither the name of the Digital Bazaar, Inc. nor the names of its\n * contributors may be used to endorse or promote products derived from\n * this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS\n * IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED\n * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A\n * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED\n * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n'use strict';\n\nrequire(\"core-js/modules/web.url-search-params.delete.js\");\nrequire(\"core-js/modules/web.url-search-params.has.js\");\nrequire(\"core-js/modules/web.url-search-params.size.js\");\nconst jsonld = require('jsonld');\nconst jsigs = require('jsonld-signatures');\nconst {\n  AuthenticationProofPurpose\n} = require('jsonld-signatures').purposes;\nconst CredentialIssuancePurpose = require('./CredentialIssuancePurpose');\nconst defaultDocumentLoader = jsigs.extendContextLoader(require('./documentLoader'));\nconst {\n  constants: {\n    CREDENTIALS_CONTEXT_V1_URL\n  }\n} = require('credentials-context');\n\n// Z and T can be lowercase\n// RFC3339 regex\nconst dateRegex = new RegExp('^(\\\\d{4})-(0[1-9]|1[0-2])-' + '(0[1-9]|[12][0-9]|3[01])T([01][0-9]|2[0-3]):' + '([0-5][0-9]):([0-5][0-9]|60)' + '(\\\\.[0-9]+)?(Z|(\\\\+|-)([01][0-9]|2[0-3]):' + '([0-5][0-9]))$', 'i');\nmodule.exports = {\n  issue,\n  createPresentation,\n  signPresentation,\n  verify,\n  verifyCredential,\n  CredentialIssuancePurpose,\n  defaultDocumentLoader,\n  // export for testing:\n  _checkCredential,\n  _checkPresentation,\n  dateRegex\n};\n\n/**\n * @typedef {object} VerifyPresentationResult\n * @property {boolean} verified - True if verified, false if not.\n * @property {object} presentationResult\n * @property {Array} credentialResults\n * @property {object} error\n */\n\n/**\n * @typedef {object} VerifyCredentialResult\n * @property {boolean} verified - True if verified, false if not.\n * @property {object} statusResult\n * @property {Array} results\n * @property {object} error\n */\n\n/**\n * Issues a verifiable credential (by taking a base credential document,\n * and adding a digital signature to it).\n *\n * @param {object} [options={}] - The options to use.\n *\n * @param {object} options.credential - Base credential document.\n * @param {LinkedDataSignature} options.suite - Signature suite (with private\n *   key material), passed in to sign().\n *\n * Either pass in a ProofPurpose, or a default one will be created:\n * @param {ProofPurpose} [options.purpose]\n *\n * Other optional params passed to `sign()`:\n * @param {object} [options.documentLoader] - A document loader.\n * @param {object} [options.expansionMap] - An expansion map.\n *\n * @throws {Error} If missing required properties.\n *\n * @returns {Promise<VerifiableCredential>} Resolves on completion.\n */\nasync function issue({\n  credential,\n  suite,\n  expansionMap,\n  purpose = new CredentialIssuancePurpose(),\n  documentLoader = defaultDocumentLoader\n} = {}) {\n  // check to make sure the `suite` has required params\n  // Note: verificationMethod defaults to publicKey.id, in suite constructor\n  if (!suite) {\n    throw new TypeError('\"suite\" parameter is required for issuing.');\n  }\n  if (!suite.verificationMethod) {\n    throw new TypeError('\"suite.verificationMethod\" property is required.');\n  }\n  if (!credential) {\n    throw new TypeError('\"credential\" parameter is required for issuing.');\n  }\n\n  // Set the issuance date to now(), if missing\n  if (!credential.issuanceDate) {\n    const now = new Date().toJSON();\n    credential.issuanceDate = `${now.substr(0, now.length - 5)}Z`;\n  }\n\n  // run common credential checks\n  _checkCredential(credential);\n  return jsigs.sign(credential, {\n    purpose,\n    documentLoader,\n    suite,\n    expansionMap\n  });\n}\n\n/**\n * Verifies a verifiable presentation:\n *   - Checks that the presentation is well-formed\n *   - Checks the proofs (for example, checks digital signatures against the\n *     provided public keys).\n *\n * @param {object} [options={}] - The options to use.\n *\n * @param {VerifiablePresentation} options.presentation - Verifiable\n *   presentation, signed or unsigned, that may contain within it a\n *   verifiable credential.\n *\n * @param {LinkedDataSignature|LinkedDataSignature[]} suite - One or more\n *   signature suites that are supported by the caller's use case. This is\n *   an explicit design decision -- the calling code must specify which\n *   signature types (ed25519, RSA, etc) are allowed.\n *   Although it is expected that the secure resolution/fetching of the public\n *   key material (to verify against) is to be handled by the documentLoader,\n *   the suite param can optionally include the key directly.\n *\n * @param {boolean} [options.unsignedPresentation=false] - By default, this\n *   function assumes that a presentation is signed (and will return an error if\n *   a `proof` section is missing). Set this to `true` if you're using an\n *   unsigned presentation.\n *\n * Either pass in a proof purpose,\n * @param {AuthenticationProofPurpose} [options.presentationPurpose] - Optional\n *   proof purpose (a default one will be created if not passed in).\n *\n * or a default purpose will be created with params:\n * @param {string} [options.challenge] - Required if purpose is not passed in.\n * @param {string} [options.controller]\n * @param {string} [options.domain]\n *\n * @param {Function} [options.documentLoader]\n * @param {Function} [options.checkStatus]\n *\n * @returns {Promise<VerifyPresentationResult>} The verification result.\n */\nasync function verify(options = {}) {\n  const {\n    presentation\n  } = options;\n  try {\n    if (!presentation) {\n      throw new TypeError('A \"presentation\" property is required for verifying.');\n    }\n    return _verifyPresentation(options);\n  } catch (error) {\n    return {\n      verified: false,\n      results: [{\n        presentation,\n        verified: false,\n        error\n      }],\n      error\n    };\n  }\n}\n\n/**\n * Verifies a verifiable credential:\n *   - Checks that the credential is well-formed\n *   - Checks the proofs (for example, checks digital signatures against the\n *     provided public keys).\n *\n * @param {object} [options={}]\n *\n * @param {object} options.credential - Verifiable credential.\n *\n * @param {LinkedDataSignature|LinkedDataSignature[]} suite - One or more\n *   signature suites that are supported by the caller's use case. This is\n *   an explicit design decision -- the calling code must specify which\n *   signature types (ed25519, RSA, etc) are allowed.\n *   Although it is expected that the secure resolution/fetching of the public\n *   key material (to verify against) is to be handled by the documentLoader,\n *   the suite param can optionally include the key directly.\n *\n * @param {CredentialIssuancePurpose} [options.purpose] - Optional\n *   proof purpose (a default one will be created if not passed in).\n * @param {Function} [options.documentLoader]\n * @param {Function} [options.checkStatus] - Optional function for checking\n *   credential status if `credentialStatus` is present on the credential.\n *\n * @returns {Promise<VerifyCredentialResult>} The verification result.\n */\nasync function verifyCredential(options = {}) {\n  const {\n    credential\n  } = options;\n  try {\n    if (!credential) {\n      throw new TypeError('A \"credential\" property is required for verifying.');\n    }\n    return _verifyCredential(options);\n  } catch (error) {\n    return {\n      verified: false,\n      results: [{\n        credential,\n        verified: false,\n        error\n      }],\n      error\n    };\n  }\n}\n\n/**\n * Verifies a verifiable credential.\n *\n * @private\n * @param {object} [options={}]\n *\n * @param {object} options.credential - Verifiable credential.\n * @param {LinkedDataSignature|LinkedDataSignature[]} suite - See the definition\n *   in the `verify()` docstring, for this param.\n *\n * @throws {Error} If required parameters are missing (in `_checkCredential`).\n *\n * @param {CredentialIssuancePurpose} [options.purpose]\n * @param {Function} [options.documentLoader]\n * @param {Function} [options.checkStatus] - Optional function for checking\n *   credential status if `credentialStatus` is present on the credential.\n *\n * @returns {Promise<VerifyCredentialResult>} The verification result.\n */\nasync function _verifyCredential(options = {}) {\n  const {\n    credential,\n    checkStatus\n  } = options;\n\n  // run common credential checks\n  _checkCredential(credential);\n\n  // if credential status is provided, a `checkStatus` function must be given\n  if (credential.credentialStatus && typeof options.checkStatus !== 'function') {\n    throw new TypeError('A \"checkStatus\" function must be given to verify credentials with ' + '\"credentialStatus\".');\n  }\n  const documentLoader = options.documentLoader || defaultDocumentLoader;\n  const {\n    controller\n  } = options;\n  const purpose = options.purpose || new CredentialIssuancePurpose({\n    controller\n  });\n  let suite = {};\n  if (Array.isArray(options.suite)) {\n    suite = options.suite.find(x => x.verificationMethod === credential.proof.verificationMethod);\n  } else {\n    suite = options.suite;\n  }\n  const result = await jsigs.verify(credential, {\n    purpose,\n    documentLoader,\n    suite\n  });\n\n  // if verification has already failed, skip status check\n  if (!result.verified) {\n    return result;\n  }\n  if (credential.credentialStatus) {\n    result.statusResult = await checkStatus(options);\n    if (!result.statusResult.verified) {\n      result.verified = false;\n    }\n  }\n  return result;\n}\n\n/**\n * Creates an unsigned presentation from a given verifiable credential.\n *\n * @param {object} options - Options to use.\n * @param {object|Array<object>} [options.verifiableCredential] - One or more\n *   verifiable credential.\n * @param {string} [options.id] - Optional VP id.\n * @param {string} [options.holder] - Optional presentation holder url.\n *\n * @throws {TypeError} If verifiableCredential param is missing.\n * @throws {Error} If the credential (or the presentation params) are missing\n *   required properties.\n *\n * @returns {Presentation} The credential wrapped inside of a\n *   VerifiablePresentation.\n */\nfunction createPresentation({\n  verifiableCredential,\n  id,\n  holder\n} = {}) {\n  const presentation = {\n    '@context': [CREDENTIALS_CONTEXT_V1_URL],\n    type: ['VerifiablePresentation']\n  };\n  if (verifiableCredential) {\n    const credentials = [].concat(verifiableCredential);\n    // ensure all credentials are valid\n    for (const credential of credentials) {\n      _checkCredential(credential);\n    }\n    presentation.verifiableCredential = credentials;\n  }\n  if (id) {\n    presentation.id = id;\n  }\n  if (holder) {\n    presentation.holder = holder;\n  }\n  _checkPresentation(presentation);\n  return presentation;\n}\n\n/**\n * Signs a given presentation.\n *\n * @param {object} [options={}] - Options to use.\n *\n * Required:\n * @param {Presentation} options.presentation\n * @param {LinkedDataSignature} options.suite - passed in to sign()\n *\n * Either pass in a ProofPurpose, or a default one will be created with params:\n * @param {ProofPurpose} [options.purpose]\n * @param {string} [options.domain]\n * @param {string} options.challenge - Required.\n *\n * @param {Function} [options.documentLoader]\n *\n * @returns {Promise<{VerifiablePresentation}>} A VerifiablePresentation with\n *   a proof.\n */\nasync function signPresentation(options = {}) {\n  const {\n    presentation,\n    domain,\n    challenge\n  } = options;\n  const purpose = options.purpose || new AuthenticationProofPurpose({\n    domain,\n    challenge\n  });\n  const documentLoader = options.documentLoader || defaultDocumentLoader;\n  return jsigs.sign(presentation, {\n    purpose,\n    documentLoader,\n    ...options\n  });\n}\n\n/**\n * Verifies that the VerifiablePresentation is well formed, and checks the\n * proof signature if it's present. Also verifies all the VerifiableCredentials\n * that are present in the presentation, if any.\n *\n * @param {object} [options={}]\n * @param {VerifiablePresentation} options.presentation\n *\n * @param {LinkedDataSignature|LinkedDataSignature[]} options.suite - See the\n *   definition in the `verify()` docstring, for this param.\n *\n * @param {boolean} [options.unsignedPresentation=false] - By default, this\n *   function assumes that a presentation is signed (and will return an error if\n *   a `proof` section is missing). Set this to `true` if you're using an\n *   unsigned presentation.\n *\n * Either pass in a proof purpose,\n * @param {AuthenticationProofPurpose} [options.presentationPurpose]\n *\n * or a default purpose will be created with params:\n * @param {string} [options.challenge] - Required if purpose is not passed in.\n * @param {string} [options.controller]\n * @param {string} [options.domain]\n *\n * @param {Function} [options.documentLoader]\n * @param {Function} [options.checkStatus]\n *\n * @throws {Error} If presentation is missing required params.\n *\n * @returns {Promise<VerifyPresentationResult>} The verification result.\n */\nasync function _verifyPresentation(options = {}) {\n  const {\n    presentation,\n    unsignedPresentation\n  } = options;\n  _checkPresentation(presentation);\n  const documentLoader = options.documentLoader || defaultDocumentLoader;\n\n  // FIXME: verify presentation first, then each individual credential\n  // only if that proof is verified\n\n  // if verifiableCredentials are present, verify them, individually\n  let credentialResults;\n  let verified = true;\n  const credentials = jsonld.getValues(presentation, 'verifiableCredential');\n  if (credentials.length > 0) {\n    // verify every credential in `verifiableCredential`\n    credentialResults = await Promise.all(credentials.map(credential => {\n      return verifyCredential({\n        credential,\n        documentLoader,\n        ...options\n      });\n    }));\n    for (const [i, credentialResult] of credentialResults.entries()) {\n      credentialResult.credentialId = credentials[i].id;\n    }\n    const allCredentialsVerified = credentialResults.every(r => r.verified);\n    if (!allCredentialsVerified) {\n      verified = false;\n    }\n  }\n  if (unsignedPresentation) {\n    // No need to verify the proof section of this presentation\n    return {\n      verified,\n      results: [presentation],\n      credentialResults\n    };\n  }\n  const {\n    controller,\n    domain,\n    challenge\n  } = options;\n  if (!options.presentationPurpose && !challenge) {\n    throw new Error('A \"challenge\" param is required for AuthenticationProofPurpose.');\n  }\n  const purpose = options.presentationPurpose || new AuthenticationProofPurpose({\n    controller,\n    domain,\n    challenge\n  });\n  let suite = {};\n  if (Array.isArray(options.suite)) {\n    suite = options.suite.find(x => x.verificationMethod === presentation.proof.verificationMethod);\n  } else {\n    suite = options.suite;\n  }\n  const presentationResult = await jsigs.verify(presentation, {\n    purpose,\n    documentLoader,\n    suite\n  });\n  return {\n    presentationResult,\n    verified: verified && presentationResult.verified,\n    credentialResults,\n    error: presentationResult.error\n  };\n}\n\n/**\n * @param {string|object} obj - Either an object with an id property\n *   or a string that is an id.\n * @returns {string|undefined} Either an id or undefined.\n * @private\n *\n */\nfunction _getId(obj) {\n  if (typeof obj === 'string') {\n    return obj;\n  }\n  if (!('id' in obj)) {\n    return;\n  }\n  return obj.id;\n}\n\n/**\n * @param {object} presentation - An object that could be a presentation.\n * @throws {Error}\n * @private\n */\nfunction _checkPresentation(presentation) {\n  // normalize to an array to allow the common case of context being a string\n  const context = Array.isArray(presentation['@context']) ? presentation['@context'] : [presentation['@context']];\n\n  // ensure first context is 'https://www.w3.org/2018/credentials/v1'\n  if (context[0] !== CREDENTIALS_CONTEXT_V1_URL) {\n    throw new Error(`\"${CREDENTIALS_CONTEXT_V1_URL}\" needs to be first in the ` + 'list of contexts.');\n  }\n  const types = jsonld.getValues(presentation, 'type');\n\n  // check type presence\n  if (!types.includes('VerifiablePresentation')) {\n    throw new Error('\"type\" must include \"VerifiablePresentation\".');\n  }\n}\n\n/**\n * @param {object} credential - An object that could be a VerifiableCredential.\n * @throws {Error}\n * @private\n */\nfunction _checkCredential(credential) {\n  // ensure first context is 'https://www.w3.org/2018/credentials/v1'\n  if (credential['@context'][0] !== CREDENTIALS_CONTEXT_V1_URL) {\n    throw new Error(`\"${CREDENTIALS_CONTEXT_V1_URL}\" needs to be first in the ` + 'list of contexts.');\n  }\n\n  // check type presence and cardinality\n  if (!credential.type) {\n    throw new Error('\"type\" property is required.');\n  }\n  if (!jsonld.getValues(credential, 'type').includes('VerifiableCredential')) {\n    throw new Error('\"type\" must include `VerifiableCredential`.');\n  }\n  if (!credential.credentialSubject) {\n    throw new Error('\"credentialSubject\" property is required.');\n  }\n\n  // If credentialSubject.id is present and is not a URI, reject it\n  if (credential.credentialSubject.id) {\n    _validateUriId({\n      id: credential.credentialSubject.id,\n      propertyName: 'credentialSubject.id'\n    });\n  }\n  if (!credential.issuer) {\n    throw new Error('\"issuer\" property is required.');\n  }\n\n  // check issuanceDate cardinality\n  if (jsonld.getValues(credential, 'issuanceDate').length > 1) {\n    throw new Error('\"issuanceDate\" property can only have one value.');\n  }\n\n  // check issued is a date\n  if (!credential.issuanceDate) {\n    throw new Error('\"issuanceDate\" property is required.');\n  }\n  if ('issuanceDate' in credential) {\n    if (!dateRegex.test(credential.issuanceDate)) {\n      throw new Error(`\"issuanceDate\" must be a valid date: ${credential.issuanceDate}`);\n    }\n  }\n\n  // check issuer cardinality\n  if (jsonld.getValues(credential, 'issuer').length > 1) {\n    throw new Error('\"issuer\" property can only have one value.');\n  }\n\n  // check issuer is a URL\n  if ('issuer' in credential) {\n    const issuer = _getId(credential.issuer);\n    if (!issuer) {\n      throw new Error(`\"issuer\" id is required.`);\n    }\n    _validateUriId({\n      id: issuer,\n      propertyName: 'issuer'\n    });\n  }\n  if ('credentialStatus' in credential) {\n    if (!credential.credentialStatus.id) {\n      throw new Error('\"credentialStatus\" must include an id.');\n    }\n    if (!credential.credentialStatus.type) {\n      throw new Error('\"credentialStatus\" must include a type.');\n    }\n  }\n\n  // check evidences are URLs\n  jsonld.getValues(credential, 'evidence').forEach(evidence => {\n    const evidenceId = _getId(evidence);\n    if (evidenceId) {\n      _validateUriId({\n        id: evidenceId,\n        propertyName: 'evidence'\n      });\n    }\n  });\n\n  // check expires is a date\n  if ('expirationDate' in credential && !dateRegex.test(credential.expirationDate)) {\n    throw new Error(`\"expirationDate\" must be a valid date: ${credential.expirationDate}`);\n  }\n}\nfunction _validateUriId({\n  id,\n  propertyName\n}) {\n  let parsed;\n  try {\n    parsed = new URL(id);\n  } catch (e) {\n    const error = new TypeError(`\"${propertyName}\" must be a URI: \"${id}\".`);\n    error.cause = e;\n    throw error;\n  }\n  if (!parsed.protocol) {\n    throw new TypeError(`\"${propertyName}\" must be a URI: \"${id}\".`);\n  }\n}","map":{"version":3,"names":["require","jsonld","jsigs","AuthenticationProofPurpose","purposes","CredentialIssuancePurpose","defaultDocumentLoader","extendContextLoader","constants","CREDENTIALS_CONTEXT_V1_URL","dateRegex","RegExp","module","exports","issue","createPresentation","signPresentation","verify","verifyCredential","_checkCredential","_checkPresentation","credential","suite","expansionMap","purpose","documentLoader","TypeError","verificationMethod","issuanceDate","now","Date","toJSON","substr","length","sign","options","presentation","_verifyPresentation","error","verified","results","_verifyCredential","checkStatus","credentialStatus","controller","Array","isArray","find","x","proof","result","statusResult","verifiableCredential","id","holder","type","credentials","concat","domain","challenge","unsignedPresentation","credentialResults","getValues","Promise","all","map","i","credentialResult","entries","credentialId","allCredentialsVerified","every","r","presentationPurpose","Error","presentationResult","_getId","obj","context","types","includes","credentialSubject","_validateUriId","propertyName","issuer","test","forEach","evidence","evidenceId","expirationDate","parsed","URL","e","cause","protocol"],"sources":["/home/pratap/hid-ssi-js-sdk/node_modules/vc-js/lib/vc.js"],"sourcesContent":["/**\n * A JavaScript implementation of Verifiable Credentials.\n *\n * @author Dave Longley\n * @author David I. Lehn\n *\n * @license BSD 3-Clause License\n * Copyright (c) 2017-2021 Digital Bazaar, Inc.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * Redistributions of source code must retain the above copyright notice,\n * this list of conditions and the following disclaimer.\n *\n * Redistributions in binary form must reproduce the above copyright\n * notice, this list of conditions and the following disclaimer in the\n * documentation and/or other materials provided with the distribution.\n *\n * Neither the name of the Digital Bazaar, Inc. nor the names of its\n * contributors may be used to endorse or promote products derived from\n * this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS\n * IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED\n * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A\n * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED\n * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n'use strict';\n\nconst jsonld = require('jsonld');\nconst jsigs = require('jsonld-signatures');\nconst {AuthenticationProofPurpose} = require('jsonld-signatures').purposes;\nconst CredentialIssuancePurpose = require('./CredentialIssuancePurpose');\nconst defaultDocumentLoader = jsigs.extendContextLoader(\n  require('./documentLoader'));\nconst {constants: {CREDENTIALS_CONTEXT_V1_URL}} =\n  require('credentials-context');\n\n// Z and T can be lowercase\n// RFC3339 regex\nconst dateRegex = new RegExp('^(\\\\d{4})-(0[1-9]|1[0-2])-' +\n    '(0[1-9]|[12][0-9]|3[01])T([01][0-9]|2[0-3]):' +\n    '([0-5][0-9]):([0-5][0-9]|60)' +\n    '(\\\\.[0-9]+)?(Z|(\\\\+|-)([01][0-9]|2[0-3]):' +\n    '([0-5][0-9]))$', 'i');\n\nmodule.exports = {\n  issue,\n  createPresentation,\n  signPresentation,\n  verify,\n  verifyCredential,\n  CredentialIssuancePurpose,\n  defaultDocumentLoader,\n  // export for testing:\n  _checkCredential,\n  _checkPresentation,\n  dateRegex\n};\n\n/**\n * @typedef {object} VerifyPresentationResult\n * @property {boolean} verified - True if verified, false if not.\n * @property {object} presentationResult\n * @property {Array} credentialResults\n * @property {object} error\n */\n\n/**\n * @typedef {object} VerifyCredentialResult\n * @property {boolean} verified - True if verified, false if not.\n * @property {object} statusResult\n * @property {Array} results\n * @property {object} error\n */\n\n/**\n * Issues a verifiable credential (by taking a base credential document,\n * and adding a digital signature to it).\n *\n * @param {object} [options={}] - The options to use.\n *\n * @param {object} options.credential - Base credential document.\n * @param {LinkedDataSignature} options.suite - Signature suite (with private\n *   key material), passed in to sign().\n *\n * Either pass in a ProofPurpose, or a default one will be created:\n * @param {ProofPurpose} [options.purpose]\n *\n * Other optional params passed to `sign()`:\n * @param {object} [options.documentLoader] - A document loader.\n * @param {object} [options.expansionMap] - An expansion map.\n *\n * @throws {Error} If missing required properties.\n *\n * @returns {Promise<VerifiableCredential>} Resolves on completion.\n */\nasync function issue({\n  credential, suite, expansionMap,\n  purpose = new CredentialIssuancePurpose(),\n  documentLoader = defaultDocumentLoader\n} = {}) {\n  // check to make sure the `suite` has required params\n  // Note: verificationMethod defaults to publicKey.id, in suite constructor\n  if(!suite) {\n    throw new TypeError('\"suite\" parameter is required for issuing.');\n  }\n  if(!suite.verificationMethod) {\n    throw new TypeError('\"suite.verificationMethod\" property is required.');\n  }\n\n  if(!credential) {\n    throw new TypeError('\"credential\" parameter is required for issuing.');\n  }\n\n  // Set the issuance date to now(), if missing\n  if(!credential.issuanceDate) {\n    const now = (new Date()).toJSON();\n    credential.issuanceDate = `${now.substr(0, now.length - 5)}Z`;\n  }\n\n  // run common credential checks\n  _checkCredential(credential);\n\n  return jsigs.sign(credential, {purpose, documentLoader, suite, expansionMap});\n}\n\n/**\n * Verifies a verifiable presentation:\n *   - Checks that the presentation is well-formed\n *   - Checks the proofs (for example, checks digital signatures against the\n *     provided public keys).\n *\n * @param {object} [options={}] - The options to use.\n *\n * @param {VerifiablePresentation} options.presentation - Verifiable\n *   presentation, signed or unsigned, that may contain within it a\n *   verifiable credential.\n *\n * @param {LinkedDataSignature|LinkedDataSignature[]} suite - One or more\n *   signature suites that are supported by the caller's use case. This is\n *   an explicit design decision -- the calling code must specify which\n *   signature types (ed25519, RSA, etc) are allowed.\n *   Although it is expected that the secure resolution/fetching of the public\n *   key material (to verify against) is to be handled by the documentLoader,\n *   the suite param can optionally include the key directly.\n *\n * @param {boolean} [options.unsignedPresentation=false] - By default, this\n *   function assumes that a presentation is signed (and will return an error if\n *   a `proof` section is missing). Set this to `true` if you're using an\n *   unsigned presentation.\n *\n * Either pass in a proof purpose,\n * @param {AuthenticationProofPurpose} [options.presentationPurpose] - Optional\n *   proof purpose (a default one will be created if not passed in).\n *\n * or a default purpose will be created with params:\n * @param {string} [options.challenge] - Required if purpose is not passed in.\n * @param {string} [options.controller]\n * @param {string} [options.domain]\n *\n * @param {Function} [options.documentLoader]\n * @param {Function} [options.checkStatus]\n *\n * @returns {Promise<VerifyPresentationResult>} The verification result.\n */\nasync function verify(options = {}) {\n  const {presentation} = options;\n  try {\n    if(!presentation) {\n      throw new TypeError(\n        'A \"presentation\" property is required for verifying.');\n    }\n    return _verifyPresentation(options);\n  } catch(error) {\n    return {\n      verified: false,\n      results: [{presentation, verified: false, error}],\n      error\n    };\n  }\n}\n\n/**\n * Verifies a verifiable credential:\n *   - Checks that the credential is well-formed\n *   - Checks the proofs (for example, checks digital signatures against the\n *     provided public keys).\n *\n * @param {object} [options={}]\n *\n * @param {object} options.credential - Verifiable credential.\n *\n * @param {LinkedDataSignature|LinkedDataSignature[]} suite - One or more\n *   signature suites that are supported by the caller's use case. This is\n *   an explicit design decision -- the calling code must specify which\n *   signature types (ed25519, RSA, etc) are allowed.\n *   Although it is expected that the secure resolution/fetching of the public\n *   key material (to verify against) is to be handled by the documentLoader,\n *   the suite param can optionally include the key directly.\n *\n * @param {CredentialIssuancePurpose} [options.purpose] - Optional\n *   proof purpose (a default one will be created if not passed in).\n * @param {Function} [options.documentLoader]\n * @param {Function} [options.checkStatus] - Optional function for checking\n *   credential status if `credentialStatus` is present on the credential.\n *\n * @returns {Promise<VerifyCredentialResult>} The verification result.\n */\nasync function verifyCredential(options = {}) {\n  const {credential} = options;\n  try {\n    if(!credential) {\n      throw new TypeError(\n        'A \"credential\" property is required for verifying.');\n    }\n    return _verifyCredential(options);\n  } catch(error) {\n    return {\n      verified: false,\n      results: [{credential, verified: false, error}],\n      error\n    };\n  }\n}\n\n/**\n * Verifies a verifiable credential.\n *\n * @private\n * @param {object} [options={}]\n *\n * @param {object} options.credential - Verifiable credential.\n * @param {LinkedDataSignature|LinkedDataSignature[]} suite - See the definition\n *   in the `verify()` docstring, for this param.\n *\n * @throws {Error} If required parameters are missing (in `_checkCredential`).\n *\n * @param {CredentialIssuancePurpose} [options.purpose]\n * @param {Function} [options.documentLoader]\n * @param {Function} [options.checkStatus] - Optional function for checking\n *   credential status if `credentialStatus` is present on the credential.\n *\n * @returns {Promise<VerifyCredentialResult>} The verification result.\n */\nasync function _verifyCredential(options = {}) {\n  const {credential, checkStatus} = options;\n\n  // run common credential checks\n  _checkCredential(credential);\n\n  // if credential status is provided, a `checkStatus` function must be given\n  if(credential.credentialStatus && typeof options.checkStatus !== 'function') {\n    throw new TypeError(\n      'A \"checkStatus\" function must be given to verify credentials with ' +\n      '\"credentialStatus\".');\n  }\n\n  const documentLoader = options.documentLoader || defaultDocumentLoader;\n\n  const {controller} = options;\n  const purpose = options.purpose || new CredentialIssuancePurpose({\n    controller\n  });\n\n  let suite = {};\n  if(Array.isArray(options.suite)){\n    suite = options.suite.find(x => x.verificationMethod === credential.proof.verificationMethod)\n  }else{\n    suite = options.suite\n  }\n  \n\n  const result = await jsigs.verify(\n    credential, {purpose, documentLoader, suite});\n\n  // if verification has already failed, skip status check\n  if(!result.verified) {\n    return result;\n  }\n\n  if(credential.credentialStatus) {\n    result.statusResult = await checkStatus(options);\n    if(!result.statusResult.verified) {\n      result.verified = false;\n    }\n  }\n\n  return result;\n}\n\n/**\n * Creates an unsigned presentation from a given verifiable credential.\n *\n * @param {object} options - Options to use.\n * @param {object|Array<object>} [options.verifiableCredential] - One or more\n *   verifiable credential.\n * @param {string} [options.id] - Optional VP id.\n * @param {string} [options.holder] - Optional presentation holder url.\n *\n * @throws {TypeError} If verifiableCredential param is missing.\n * @throws {Error} If the credential (or the presentation params) are missing\n *   required properties.\n *\n * @returns {Presentation} The credential wrapped inside of a\n *   VerifiablePresentation.\n */\nfunction createPresentation({verifiableCredential, id, holder} = {}) {\n  const presentation = {\n    '@context': [CREDENTIALS_CONTEXT_V1_URL],\n    type: ['VerifiablePresentation']\n  };\n  if(verifiableCredential) {\n    const credentials = [].concat(verifiableCredential);\n    // ensure all credentials are valid\n    for(const credential of credentials) {\n      _checkCredential(credential);\n    }\n    presentation.verifiableCredential = credentials;\n  }\n  if(id) {\n    presentation.id = id;\n  }\n  if(holder) {\n    presentation.holder = holder;\n  }\n\n  _checkPresentation(presentation);\n\n  return presentation;\n}\n\n/**\n * Signs a given presentation.\n *\n * @param {object} [options={}] - Options to use.\n *\n * Required:\n * @param {Presentation} options.presentation\n * @param {LinkedDataSignature} options.suite - passed in to sign()\n *\n * Either pass in a ProofPurpose, or a default one will be created with params:\n * @param {ProofPurpose} [options.purpose]\n * @param {string} [options.domain]\n * @param {string} options.challenge - Required.\n *\n * @param {Function} [options.documentLoader]\n *\n * @returns {Promise<{VerifiablePresentation}>} A VerifiablePresentation with\n *   a proof.\n */\nasync function signPresentation(options = {}) {\n  const {presentation, domain, challenge} = options;\n  const purpose = options.purpose || new AuthenticationProofPurpose({\n    domain,\n    challenge\n  });\n\n  const documentLoader = options.documentLoader || defaultDocumentLoader;\n\n  return jsigs.sign(presentation, {purpose, documentLoader, ...options});\n}\n\n/**\n * Verifies that the VerifiablePresentation is well formed, and checks the\n * proof signature if it's present. Also verifies all the VerifiableCredentials\n * that are present in the presentation, if any.\n *\n * @param {object} [options={}]\n * @param {VerifiablePresentation} options.presentation\n *\n * @param {LinkedDataSignature|LinkedDataSignature[]} options.suite - See the\n *   definition in the `verify()` docstring, for this param.\n *\n * @param {boolean} [options.unsignedPresentation=false] - By default, this\n *   function assumes that a presentation is signed (and will return an error if\n *   a `proof` section is missing). Set this to `true` if you're using an\n *   unsigned presentation.\n *\n * Either pass in a proof purpose,\n * @param {AuthenticationProofPurpose} [options.presentationPurpose]\n *\n * or a default purpose will be created with params:\n * @param {string} [options.challenge] - Required if purpose is not passed in.\n * @param {string} [options.controller]\n * @param {string} [options.domain]\n *\n * @param {Function} [options.documentLoader]\n * @param {Function} [options.checkStatus]\n *\n * @throws {Error} If presentation is missing required params.\n *\n * @returns {Promise<VerifyPresentationResult>} The verification result.\n */\nasync function _verifyPresentation(options = {}) {\n  const {presentation, unsignedPresentation} = options;\n\n  _checkPresentation(presentation);\n\n  const documentLoader = options.documentLoader || defaultDocumentLoader;\n\n  // FIXME: verify presentation first, then each individual credential\n  // only if that proof is verified\n\n  // if verifiableCredentials are present, verify them, individually\n  let credentialResults;\n  let verified = true;\n  const credentials = jsonld.getValues(presentation, 'verifiableCredential');\n  if(credentials.length > 0) {\n    // verify every credential in `verifiableCredential`\n    credentialResults = await Promise.all(credentials.map(credential => {\n      return verifyCredential({credential, documentLoader, ...options});\n    }));\n\n    for(const [i, credentialResult] of credentialResults.entries()) {\n      credentialResult.credentialId = credentials[i].id;\n    }\n\n    const allCredentialsVerified = credentialResults.every(r => r.verified);\n    if(!allCredentialsVerified) {\n      verified = false;\n    }\n  }\n\n  if(unsignedPresentation) {\n    // No need to verify the proof section of this presentation\n    return {verified, results: [presentation], credentialResults};\n  }\n\n  const {controller, domain, challenge} = options;\n  if(!options.presentationPurpose && !challenge) {\n    throw new Error(\n      'A \"challenge\" param is required for AuthenticationProofPurpose.');\n  }\n\n  const purpose = options.presentationPurpose ||\n    new AuthenticationProofPurpose({controller, domain, challenge});\n\n  let suite = {};\n  if(Array.isArray(options.suite)){\n    suite = options.suite.find(x => x.verificationMethod === presentation.proof.verificationMethod)\n  }else{\n    suite = options.suite\n  }\n  \n  const presentationResult = await jsigs.verify(\n    presentation, {purpose, documentLoader, suite});\n\n  return {\n    presentationResult,\n    verified: verified && presentationResult.verified,\n    credentialResults,\n    error: presentationResult.error\n  };\n}\n\n/**\n * @param {string|object} obj - Either an object with an id property\n *   or a string that is an id.\n * @returns {string|undefined} Either an id or undefined.\n * @private\n *\n */\nfunction _getId(obj) {\n  if(typeof obj === 'string') {\n    return obj;\n  }\n\n  if(!('id' in obj)) {\n    return;\n  }\n\n  return obj.id;\n}\n\n/**\n * @param {object} presentation - An object that could be a presentation.\n * @throws {Error}\n * @private\n */\nfunction _checkPresentation(presentation) {\n  // normalize to an array to allow the common case of context being a string\n  const context = Array.isArray(presentation['@context']) ?\n    presentation['@context'] : [presentation['@context']];\n\n  // ensure first context is 'https://www.w3.org/2018/credentials/v1'\n  if(context[0] !== CREDENTIALS_CONTEXT_V1_URL) {\n    throw new Error(\n      `\"${CREDENTIALS_CONTEXT_V1_URL}\" needs to be first in the ` +\n      'list of contexts.');\n  }\n\n  const types = jsonld.getValues(presentation, 'type');\n\n  // check type presence\n  if(!types.includes('VerifiablePresentation')) {\n    throw new Error('\"type\" must include \"VerifiablePresentation\".');\n  }\n}\n\n/**\n * @param {object} credential - An object that could be a VerifiableCredential.\n * @throws {Error}\n * @private\n */\nfunction _checkCredential(credential) {\n  // ensure first context is 'https://www.w3.org/2018/credentials/v1'\n  if(credential['@context'][0] !== CREDENTIALS_CONTEXT_V1_URL) {\n    throw new Error(\n      `\"${CREDENTIALS_CONTEXT_V1_URL}\" needs to be first in the ` +\n      'list of contexts.');\n  }\n\n  // check type presence and cardinality\n  if(!credential.type) {\n    throw new Error('\"type\" property is required.');\n  }\n\n  if(!jsonld.getValues(credential, 'type').includes('VerifiableCredential')) {\n    throw new Error('\"type\" must include `VerifiableCredential`.');\n  }\n\n  if(!credential.credentialSubject) {\n    throw new Error('\"credentialSubject\" property is required.');\n  }\n\n  // If credentialSubject.id is present and is not a URI, reject it\n  if(credential.credentialSubject.id) {\n    _validateUriId({\n      id: credential.credentialSubject.id, propertyName: 'credentialSubject.id'\n    });\n  }\n\n  if(!credential.issuer) {\n    throw new Error('\"issuer\" property is required.');\n  }\n\n  // check issuanceDate cardinality\n  if(jsonld.getValues(credential, 'issuanceDate').length > 1) {\n    throw new Error('\"issuanceDate\" property can only have one value.');\n  }\n\n  // check issued is a date\n  if(!credential.issuanceDate) {\n    throw new Error('\"issuanceDate\" property is required.');\n  }\n\n  if('issuanceDate' in credential) {\n    if(!dateRegex.test(credential.issuanceDate)) {\n      throw new Error(\n        `\"issuanceDate\" must be a valid date: ${credential.issuanceDate}`);\n    }\n  }\n\n  // check issuer cardinality\n  if(jsonld.getValues(credential, 'issuer').length > 1) {\n    throw new Error('\"issuer\" property can only have one value.');\n  }\n\n  // check issuer is a URL\n  if('issuer' in credential) {\n    const issuer = _getId(credential.issuer);\n    if(!issuer) {\n      throw new Error(`\"issuer\" id is required.`);\n    }\n    _validateUriId({id: issuer, propertyName: 'issuer'});\n  }\n\n  if('credentialStatus' in credential) {\n    if(!credential.credentialStatus.id) {\n      throw new Error('\"credentialStatus\" must include an id.');\n    }\n    if(!credential.credentialStatus.type) {\n      throw new Error('\"credentialStatus\" must include a type.');\n    }\n  }\n\n  // check evidences are URLs\n  jsonld.getValues(credential, 'evidence').forEach(evidence => {\n    const evidenceId = _getId(evidence);\n    if(evidenceId) {\n      _validateUriId({id: evidenceId, propertyName: 'evidence'});\n    }\n  });\n\n  // check expires is a date\n  if('expirationDate' in credential &&\n      !dateRegex.test(credential.expirationDate)) {\n    throw new Error(\n      `\"expirationDate\" must be a valid date: ${credential.expirationDate}`);\n  }\n}\n\nfunction _validateUriId({id, propertyName}) {\n  let parsed;\n  try {\n    parsed = new URL(id);\n  } catch(e) {\n    const error = new TypeError(`\"${propertyName}\" must be a URI: \"${id}\".`);\n    error.cause = e;\n    throw error;\n  }\n\n  if(!parsed.protocol) {\n    throw new TypeError(`\"${propertyName}\" must be a URI: \"${id}\".`);\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}