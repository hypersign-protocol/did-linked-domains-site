{"ast":null,"code":"\"use strict\";\n\n/**\n *  A fragment is a single item from an ABI, which may represent any of:\n *\n *  - [Functions](FunctionFragment)\n *  - [Events](EventFragment)\n *  - [Constructors](ConstructorFragment)\n *  - Custom [Errors](ErrorFragment)\n *  - [Fallback or Receive](FallbackFragment) functions\n *\n *  @_subsection api/abi/abi-coder:Fragments  [about-fragments]\n */\nvar _defineProperty = require(\"/home/pratap/domain-linkege/node_modules/@babel/runtime/helpers/defineProperty.js\").default;\nvar _classPrivateMethodInitSpec = require(\"/home/pratap/domain-linkege/node_modules/@babel/runtime/helpers/classPrivateMethodInitSpec.js\").default;\nvar _classPrivateFieldInitSpec = require(\"/home/pratap/domain-linkege/node_modules/@babel/runtime/helpers/classPrivateFieldInitSpec.js\").default;\nvar _classPrivateMethodGet = require(\"/home/pratap/domain-linkege/node_modules/@babel/runtime/helpers/classPrivateMethodGet.js\").default;\nvar _classPrivateFieldSet = require(\"/home/pratap/domain-linkege/node_modules/@babel/runtime/helpers/classPrivateFieldSet.js\").default;\nvar _classPrivateFieldGet = require(\"/home/pratap/domain-linkege/node_modules/@babel/runtime/helpers/classPrivateFieldGet.js\").default;\nrequire(\"core-js/modules/es.array.push.js\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.StructFragment = exports.FunctionFragment = exports.FallbackFragment = exports.ConstructorFragment = exports.EventFragment = exports.ErrorFragment = exports.NamedFragment = exports.Fragment = exports.ParamType = void 0;\nconst index_js_1 = require(\"../utils/index.js\");\nconst index_js_2 = require(\"../hash/index.js\");\n;\n// [ \"a\", \"b\" ] => { \"a\": 1, \"b\": 1 }\nfunction setify(items) {\n  const result = new Set();\n  items.forEach(k => result.add(k));\n  return Object.freeze(result);\n}\n// Visibility Keywords\nconst _kwVisib = \"constant external internal payable private public pure view\";\nconst KwVisib = setify(_kwVisib.split(\" \"));\nconst _kwTypes = \"constructor error event fallback function receive struct\";\nconst KwTypes = setify(_kwTypes.split(\" \"));\nconst _kwModifiers = \"calldata memory storage payable indexed\";\nconst KwModifiers = setify(_kwModifiers.split(\" \"));\nconst _kwOther = \"tuple returns\";\n// All Keywords\nconst _keywords = [_kwTypes, _kwModifiers, _kwOther, _kwVisib].join(\" \");\nconst Keywords = setify(_keywords.split(\" \"));\n// Single character tokens\nconst SimpleTokens = {\n  \"(\": \"OPEN_PAREN\",\n  \")\": \"CLOSE_PAREN\",\n  \"[\": \"OPEN_BRACKET\",\n  \"]\": \"CLOSE_BRACKET\",\n  \",\": \"COMMA\",\n  \"@\": \"AT\"\n};\n// Parser regexes to consume the next token\nconst regexWhitespacePrefix = new RegExp(\"^(\\\\s*)\");\nconst regexNumberPrefix = new RegExp(\"^([0-9]+)\");\nconst regexIdPrefix = new RegExp(\"^([a-zA-Z$_][a-zA-Z0-9$_]*)\");\n// Parser regexs to check validity\nconst regexId = new RegExp(\"^([a-zA-Z$_][a-zA-Z0-9$_]*)$\");\nconst regexType = new RegExp(\"^(address|bool|bytes([0-9]*)|string|u?int([0-9]*))$\");\nvar _offset = /*#__PURE__*/new WeakMap();\nvar _tokens = /*#__PURE__*/new WeakMap();\nvar _subTokenString = /*#__PURE__*/new WeakSet();\nclass TokenString {\n  get offset() {\n    return _classPrivateFieldGet(this, _offset);\n  }\n  get length() {\n    return _classPrivateFieldGet(this, _tokens).length - _classPrivateFieldGet(this, _offset);\n  }\n  constructor(tokens) {\n    _classPrivateMethodInitSpec(this, _subTokenString);\n    _classPrivateFieldInitSpec(this, _offset, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _tokens, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldSet(this, _offset, 0);\n    _classPrivateFieldSet(this, _tokens, tokens.slice());\n  }\n  clone() {\n    return new TokenString(_classPrivateFieldGet(this, _tokens));\n  }\n  reset() {\n    _classPrivateFieldSet(this, _offset, 0);\n  }\n  // Pops and returns the value of the next token, if it is a keyword in allowed; throws if out of tokens\n  popKeyword(allowed) {\n    const top = this.peek();\n    if (top.type !== \"KEYWORD\" || !allowed.has(top.text)) {\n      throw new Error(`expected keyword ${top.text}`);\n    }\n    return this.pop().text;\n  }\n  // Pops and returns the value of the next token if it is `type`; throws if out of tokens\n  popType(type) {\n    if (this.peek().type !== type) {\n      throw new Error(`expected ${type}; got ${JSON.stringify(this.peek())}`);\n    }\n    return this.pop().text;\n  }\n  // Pops and returns a \"(\" TOKENS \")\"\n  popParen() {\n    const top = this.peek();\n    if (top.type !== \"OPEN_PAREN\") {\n      throw new Error(\"bad start\");\n    }\n    const result = _classPrivateMethodGet(this, _subTokenString, _subTokenString2).call(this, _classPrivateFieldGet(this, _offset) + 1, top.match + 1);\n    _classPrivateFieldSet(this, _offset, top.match + 1);\n    return result;\n  }\n  // Pops and returns the items within \"(\" ITEM1 \",\" ITEM2 \",\" ... \")\"\n  popParams() {\n    const top = this.peek();\n    if (top.type !== \"OPEN_PAREN\") {\n      throw new Error(\"bad start\");\n    }\n    const result = [];\n    while (_classPrivateFieldGet(this, _offset) < top.match - 1) {\n      const link = this.peek().linkNext;\n      result.push(_classPrivateMethodGet(this, _subTokenString, _subTokenString2).call(this, _classPrivateFieldGet(this, _offset) + 1, link));\n      _classPrivateFieldSet(this, _offset, link);\n    }\n    _classPrivateFieldSet(this, _offset, top.match + 1);\n    return result;\n  }\n  // Returns the top Token, throwing if out of tokens\n  peek() {\n    if (_classPrivateFieldGet(this, _offset) >= _classPrivateFieldGet(this, _tokens).length) {\n      throw new Error(\"out-of-bounds\");\n    }\n    return _classPrivateFieldGet(this, _tokens)[_classPrivateFieldGet(this, _offset)];\n  }\n  // Returns the next value, if it is a keyword in `allowed`\n  peekKeyword(allowed) {\n    const top = this.peekType(\"KEYWORD\");\n    return top != null && allowed.has(top) ? top : null;\n  }\n  // Returns the value of the next token if it is `type`\n  peekType(type) {\n    if (this.length === 0) {\n      return null;\n    }\n    const top = this.peek();\n    return top.type === type ? top.text : null;\n  }\n  // Returns the next token; throws if out of tokens\n  pop() {\n    var _this$offset, _this$offset2;\n    const result = this.peek();\n    _classPrivateFieldSet(this, _offset, (_this$offset = _classPrivateFieldGet(this, _offset), _this$offset2 = _this$offset++, _this$offset)), _this$offset2;\n    return result;\n  }\n  toString() {\n    const tokens = [];\n    for (let i = _classPrivateFieldGet(this, _offset); i < _classPrivateFieldGet(this, _tokens).length; i++) {\n      const token = _classPrivateFieldGet(this, _tokens)[i];\n      tokens.push(`${token.type}:${token.text}`);\n    }\n    return `<TokenString ${tokens.join(\" \")}>`;\n  }\n}\nfunction _subTokenString2(from = 0, to = 0) {\n  return new TokenString(_classPrivateFieldGet(this, _tokens).slice(from, to).map(t => {\n    return Object.freeze(Object.assign({}, t, {\n      match: t.match - from,\n      linkBack: t.linkBack - from,\n      linkNext: t.linkNext - from\n    }));\n  }));\n}\nfunction lex(text) {\n  const tokens = [];\n  const throwError = message => {\n    const token = offset < text.length ? JSON.stringify(text[offset]) : \"$EOI\";\n    throw new Error(`invalid token ${token} at ${offset}: ${message}`);\n  };\n  let brackets = [];\n  let commas = [];\n  let offset = 0;\n  while (offset < text.length) {\n    // Strip off any leading whitespace\n    let cur = text.substring(offset);\n    let match = cur.match(regexWhitespacePrefix);\n    if (match) {\n      offset += match[1].length;\n      cur = text.substring(offset);\n    }\n    const token = {\n      depth: brackets.length,\n      linkBack: -1,\n      linkNext: -1,\n      match: -1,\n      type: \"\",\n      text: \"\",\n      offset,\n      value: -1\n    };\n    tokens.push(token);\n    let type = SimpleTokens[cur[0]] || \"\";\n    if (type) {\n      token.type = type;\n      token.text = cur[0];\n      offset++;\n      if (type === \"OPEN_PAREN\") {\n        brackets.push(tokens.length - 1);\n        commas.push(tokens.length - 1);\n      } else if (type == \"CLOSE_PAREN\") {\n        if (brackets.length === 0) {\n          throwError(\"no matching open bracket\");\n        }\n        token.match = brackets.pop();\n        tokens[token.match].match = tokens.length - 1;\n        token.depth--;\n        token.linkBack = commas.pop();\n        tokens[token.linkBack].linkNext = tokens.length - 1;\n      } else if (type === \"COMMA\") {\n        token.linkBack = commas.pop();\n        tokens[token.linkBack].linkNext = tokens.length - 1;\n        commas.push(tokens.length - 1);\n      } else if (type === \"OPEN_BRACKET\") {\n        token.type = \"BRACKET\";\n      } else if (type === \"CLOSE_BRACKET\") {\n        // Remove the CLOSE_BRACKET\n        let suffix = tokens.pop().text;\n        if (tokens.length > 0 && tokens[tokens.length - 1].type === \"NUMBER\") {\n          const value = tokens.pop().text;\n          suffix = value + suffix;\n          tokens[tokens.length - 1].value = (0, index_js_1.getNumber)(value);\n        }\n        if (tokens.length === 0 || tokens[tokens.length - 1].type !== \"BRACKET\") {\n          throw new Error(\"missing opening bracket\");\n        }\n        tokens[tokens.length - 1].text += suffix;\n      }\n      continue;\n    }\n    match = cur.match(regexIdPrefix);\n    if (match) {\n      token.text = match[1];\n      offset += token.text.length;\n      if (Keywords.has(token.text)) {\n        token.type = \"KEYWORD\";\n        continue;\n      }\n      if (token.text.match(regexType)) {\n        token.type = \"TYPE\";\n        continue;\n      }\n      token.type = \"ID\";\n      continue;\n    }\n    match = cur.match(regexNumberPrefix);\n    if (match) {\n      token.text = match[1];\n      token.type = \"NUMBER\";\n      offset += token.text.length;\n      continue;\n    }\n    throw new Error(`unexpected token ${JSON.stringify(cur[0])} at position ${offset}`);\n  }\n  return new TokenString(tokens.map(t => Object.freeze(t)));\n}\n// Check only one of `allowed` is in `set`\nfunction allowSingle(set, allowed) {\n  let included = [];\n  for (const key in allowed.keys()) {\n    if (set.has(key)) {\n      included.push(key);\n    }\n  }\n  if (included.length > 1) {\n    throw new Error(`conflicting types: ${included.join(\", \")}`);\n  }\n}\n// Functions to process a Solidity Signature TokenString from left-to-right for...\n// ...the name with an optional type, returning the name\nfunction consumeName(type, tokens) {\n  if (tokens.peekKeyword(KwTypes)) {\n    const keyword = tokens.pop().text;\n    if (keyword !== type) {\n      throw new Error(`expected ${type}, got ${keyword}`);\n    }\n  }\n  return tokens.popType(\"ID\");\n}\n// ...all keywords matching allowed, returning the keywords\nfunction consumeKeywords(tokens, allowed) {\n  const keywords = new Set();\n  while (true) {\n    const keyword = tokens.peekType(\"KEYWORD\");\n    if (keyword == null || allowed && !allowed.has(keyword)) {\n      break;\n    }\n    tokens.pop();\n    if (keywords.has(keyword)) {\n      throw new Error(`duplicate keywords: ${JSON.stringify(keyword)}`);\n    }\n    keywords.add(keyword);\n  }\n  return Object.freeze(keywords);\n}\n// ...all visibility keywords, returning the coalesced mutability\nfunction consumeMutability(tokens) {\n  let modifiers = consumeKeywords(tokens, KwVisib);\n  // Detect conflicting modifiers\n  allowSingle(modifiers, setify(\"constant payable nonpayable\".split(\" \")));\n  allowSingle(modifiers, setify(\"pure view payable nonpayable\".split(\" \")));\n  // Process mutability states\n  if (modifiers.has(\"view\")) {\n    return \"view\";\n  }\n  if (modifiers.has(\"pure\")) {\n    return \"pure\";\n  }\n  if (modifiers.has(\"payable\")) {\n    return \"payable\";\n  }\n  if (modifiers.has(\"nonpayable\")) {\n    return \"nonpayable\";\n  }\n  // Process legacy `constant` last\n  if (modifiers.has(\"constant\")) {\n    return \"view\";\n  }\n  return \"nonpayable\";\n}\n// ...a parameter list, returning the ParamType list\nfunction consumeParams(tokens, allowIndexed) {\n  return tokens.popParams().map(t => ParamType.from(t, allowIndexed));\n}\n// ...a gas limit, returning a BigNumber or null if none\nfunction consumeGas(tokens) {\n  if (tokens.peekType(\"AT\")) {\n    tokens.pop();\n    if (tokens.peekType(\"NUMBER\")) {\n      return (0, index_js_1.getBigInt)(tokens.pop().text);\n    }\n    throw new Error(\"invalid gas\");\n  }\n  return null;\n}\nfunction consumeEoi(tokens) {\n  if (tokens.length) {\n    throw new Error(`unexpected tokens: ${tokens.toString()}`);\n  }\n}\nconst regexArrayType = new RegExp(/^(.*)\\[([0-9]*)\\]$/);\nfunction verifyBasicType(type) {\n  const match = type.match(regexType);\n  (0, index_js_1.assertArgument)(match, \"invalid type\", \"type\", type);\n  if (type === \"uint\") {\n    return \"uint256\";\n  }\n  if (type === \"int\") {\n    return \"int256\";\n  }\n  if (match[2]) {\n    // bytesXX\n    const length = parseInt(match[2]);\n    (0, index_js_1.assertArgument)(length !== 0 && length <= 32, \"invalid bytes length\", \"type\", type);\n  } else if (match[3]) {\n    // intXX or uintXX\n    const size = parseInt(match[3]);\n    (0, index_js_1.assertArgument)(size !== 0 && size <= 256 && size % 8 === 0, \"invalid numeric width\", \"type\", type);\n  }\n  return type;\n}\n// Make the Fragment constructors effectively private\nconst _guard = {};\nconst internal = Symbol.for(\"_ethers_internal\");\nconst ParamTypeInternal = \"_ParamTypeInternal\";\nconst ErrorFragmentInternal = \"_ErrorInternal\";\nconst EventFragmentInternal = \"_EventInternal\";\nconst ConstructorFragmentInternal = \"_ConstructorInternal\";\nconst FallbackFragmentInternal = \"_FallbackInternal\";\nconst FunctionFragmentInternal = \"_FunctionInternal\";\nconst StructFragmentInternal = \"_StructInternal\";\n/**\n *  Each input and output of a [[Fragment]] is an Array of **ParamType**.\n */\nvar _walkAsync = /*#__PURE__*/new WeakSet();\nclass ParamType {\n  /**\n   *  @private\n   */\n  constructor(guard, name, type, baseType, indexed, _components, arrayLength, arrayChildren) {\n    _classPrivateMethodInitSpec(this, _walkAsync);\n    /**\n     *  The local name of the parameter (or ``\"\"`` if unbound)\n     */\n    _defineProperty(this, \"name\", void 0);\n    /**\n     *  The fully qualified type (e.g. ``\"address\"``, ``\"tuple(address)\"``,\n     *  ``\"uint256[3][]\"``)\n     */\n    _defineProperty(this, \"type\", void 0);\n    /**\n     *  The base type (e.g. ``\"address\"``, ``\"tuple\"``, ``\"array\"``)\n     */\n    _defineProperty(this, \"baseType\", void 0);\n    /**\n     *  True if the parameters is indexed.\n     *\n     *  For non-indexable types this is ``null``.\n     */\n    _defineProperty(this, \"indexed\", void 0);\n    /**\n     *  The components for the tuple.\n     *\n     *  For non-tuple types this is ``null``.\n     */\n    _defineProperty(this, \"components\", void 0);\n    /**\n     *  The array length, or ``-1`` for dynamic-lengthed arrays.\n     *\n     *  For non-array types this is ``null``.\n     */\n    _defineProperty(this, \"arrayLength\", void 0);\n    /**\n     *  The type of each child in the array.\n     *\n     *  For non-array types this is ``null``.\n     */\n    _defineProperty(this, \"arrayChildren\", void 0);\n    (0, index_js_1.assertPrivate)(guard, _guard, \"ParamType\");\n    Object.defineProperty(this, internal, {\n      value: ParamTypeInternal\n    });\n    if (_components) {\n      _components = Object.freeze(_components.slice());\n    }\n    if (baseType === \"array\") {\n      if (arrayLength == null || arrayChildren == null) {\n        throw new Error(\"\");\n      }\n    } else if (arrayLength != null || arrayChildren != null) {\n      throw new Error(\"\");\n    }\n    if (baseType === \"tuple\") {\n      if (_components == null) {\n        throw new Error(\"\");\n      }\n    } else if (_components != null) {\n      throw new Error(\"\");\n    }\n    (0, index_js_1.defineProperties)(this, {\n      name,\n      type,\n      baseType,\n      indexed,\n      components: _components,\n      arrayLength,\n      arrayChildren\n    });\n  }\n  /**\n   *  Return a string representation of this type.\n   *\n   *  For example,\n   *\n   *  ``sighash\" => \"(uint256,address)\"``\n   *\n   *  ``\"minimal\" => \"tuple(uint256,address) indexed\"``\n   *\n   *  ``\"full\" => \"tuple(uint256 foo, address bar) indexed baz\"``\n   */\n  format(format) {\n    if (format == null) {\n      format = \"sighash\";\n    }\n    if (format === \"json\") {\n      const name = this.name || undefined; // @TODO: Make this \"\" (minor bump)\n      if (this.isArray()) {\n        const result = JSON.parse(this.arrayChildren.format(\"json\"));\n        result.name = name;\n        result.type += `[${this.arrayLength < 0 ? \"\" : String(this.arrayLength)}]`;\n        return JSON.stringify(result);\n      }\n      const result = {\n        type: this.baseType === \"tuple\" ? \"tuple\" : this.type,\n        name\n      };\n      if (typeof this.indexed === \"boolean\") {\n        result.indexed = this.indexed;\n      }\n      if (this.isTuple()) {\n        result.components = this.components.map(c => JSON.parse(c.format(format)));\n      }\n      return JSON.stringify(result);\n    }\n    let result = \"\";\n    // Array\n    if (this.isArray()) {\n      result += this.arrayChildren.format(format);\n      result += `[${this.arrayLength < 0 ? \"\" : String(this.arrayLength)}]`;\n    } else {\n      if (this.isTuple()) {\n        if (format !== \"sighash\") {\n          result += this.type;\n        }\n        result += \"(\" + this.components.map(comp => comp.format(format)).join(format === \"full\" ? \", \" : \",\") + \")\";\n      } else {\n        result += this.type;\n      }\n    }\n    if (format !== \"sighash\") {\n      if (this.indexed === true) {\n        result += \" indexed\";\n      }\n      if (format === \"full\" && this.name) {\n        result += \" \" + this.name;\n      }\n    }\n    return result;\n  }\n  /**\n   *  Returns true if %%this%% is an Array type.\n   *\n   *  This provides a type gaurd ensuring that [[arrayChildren]]\n   *  and [[arrayLength]] are non-null.\n   */\n  isArray() {\n    return this.baseType === \"array\";\n  }\n  /**\n   *  Returns true if %%this%% is a Tuple type.\n   *\n   *  This provides a type gaurd ensuring that [[components]]\n   *  is non-null.\n   */\n  isTuple() {\n    return this.baseType === \"tuple\";\n  }\n  /**\n   *  Returns true if %%this%% is an Indexable type.\n   *\n   *  This provides a type gaurd ensuring that [[indexed]]\n   *  is non-null.\n   */\n  isIndexable() {\n    return this.indexed != null;\n  }\n  /**\n   *  Walks the **ParamType** with %%value%%, calling %%process%%\n   *  on each type, destructing the %%value%% recursively.\n   */\n  walk(value, process) {\n    if (this.isArray()) {\n      if (!Array.isArray(value)) {\n        throw new Error(\"invalid array value\");\n      }\n      if (this.arrayLength !== -1 && value.length !== this.arrayLength) {\n        throw new Error(\"array is wrong length\");\n      }\n      const _this = this;\n      return value.map(v => _this.arrayChildren.walk(v, process));\n    }\n    if (this.isTuple()) {\n      if (!Array.isArray(value)) {\n        throw new Error(\"invalid tuple value\");\n      }\n      if (value.length !== this.components.length) {\n        throw new Error(\"array is wrong length\");\n      }\n      const _this = this;\n      return value.map((v, i) => _this.components[i].walk(v, process));\n    }\n    return process(this.type, value);\n  }\n  /**\n   *  Walks the **ParamType** with %%value%%, asynchronously calling\n   *  %%process%% on each type, destructing the %%value%% recursively.\n   *\n   *  This can be used to resolve ENS naes by walking and resolving each\n   *  ``\"address\"`` type.\n   */\n  async walkAsync(value, process) {\n    const promises = [];\n    const result = [value];\n    _classPrivateMethodGet(this, _walkAsync, _walkAsync2).call(this, promises, value, process, value => {\n      result[0] = value;\n    });\n    if (promises.length) {\n      await Promise.all(promises);\n    }\n    return result[0];\n  }\n  /**\n   *  Creates a new **ParamType** for %%obj%%.\n   *\n   *  If %%allowIndexed%% then the ``indexed`` keyword is permitted,\n   *  otherwise the ``indexed`` keyword will throw an error.\n   */\n  static from(obj, allowIndexed) {\n    if (ParamType.isParamType(obj)) {\n      return obj;\n    }\n    if (typeof obj === \"string\") {\n      try {\n        return ParamType.from(lex(obj), allowIndexed);\n      } catch (error) {\n        (0, index_js_1.assertArgument)(false, \"invalid param type\", \"obj\", obj);\n      }\n    } else if (obj instanceof TokenString) {\n      let type = \"\",\n        baseType = \"\";\n      let comps = null;\n      if (consumeKeywords(obj, setify([\"tuple\"])).has(\"tuple\") || obj.peekType(\"OPEN_PAREN\")) {\n        // Tuple\n        baseType = \"tuple\";\n        comps = obj.popParams().map(t => ParamType.from(t));\n        type = `tuple(${comps.map(c => c.format()).join(\",\")})`;\n      } else {\n        // Normal\n        type = verifyBasicType(obj.popType(\"TYPE\"));\n        baseType = type;\n      }\n      // Check for Array\n      let arrayChildren = null;\n      let arrayLength = null;\n      while (obj.length && obj.peekType(\"BRACKET\")) {\n        const bracket = obj.pop(); //arrays[i];\n        arrayChildren = new ParamType(_guard, \"\", type, baseType, null, comps, arrayLength, arrayChildren);\n        arrayLength = bracket.value;\n        type += bracket.text;\n        baseType = \"array\";\n        comps = null;\n      }\n      let indexed = null;\n      const keywords = consumeKeywords(obj, KwModifiers);\n      if (keywords.has(\"indexed\")) {\n        if (!allowIndexed) {\n          throw new Error(\"\");\n        }\n        indexed = true;\n      }\n      const name = obj.peekType(\"ID\") ? obj.pop().text : \"\";\n      if (obj.length) {\n        throw new Error(\"leftover tokens\");\n      }\n      return new ParamType(_guard, name, type, baseType, indexed, comps, arrayLength, arrayChildren);\n    }\n    const name = obj.name;\n    (0, index_js_1.assertArgument)(!name || typeof name === \"string\" && name.match(regexId), \"invalid name\", \"obj.name\", name);\n    let indexed = obj.indexed;\n    if (indexed != null) {\n      (0, index_js_1.assertArgument)(allowIndexed, \"parameter cannot be indexed\", \"obj.indexed\", obj.indexed);\n      indexed = !!indexed;\n    }\n    let type = obj.type;\n    let arrayMatch = type.match(regexArrayType);\n    if (arrayMatch) {\n      const arrayLength = parseInt(arrayMatch[2] || \"-1\");\n      const arrayChildren = ParamType.from({\n        type: arrayMatch[1],\n        components: obj.components\n      });\n      return new ParamType(_guard, name || \"\", type, \"array\", indexed, null, arrayLength, arrayChildren);\n    }\n    if (type === \"tuple\" || type.startsWith(\"tuple(\" /* fix: ) */) || type.startsWith(\"(\" /* fix: ) */)) {\n      const comps = obj.components != null ? obj.components.map(c => ParamType.from(c)) : null;\n      const tuple = new ParamType(_guard, name || \"\", type, \"tuple\", indexed, comps, null, null);\n      // @TODO: use lexer to validate and normalize type\n      return tuple;\n    }\n    type = verifyBasicType(obj.type);\n    return new ParamType(_guard, name || \"\", type, type, indexed, null, null, null);\n  }\n  /**\n   *  Returns true if %%value%% is a **ParamType**.\n   */\n  static isParamType(value) {\n    return value && value[internal] === ParamTypeInternal;\n  }\n}\nfunction _walkAsync2(promises, value, process, setValue) {\n  if (this.isArray()) {\n    if (!Array.isArray(value)) {\n      throw new Error(\"invalid array value\");\n    }\n    if (this.arrayLength !== -1 && value.length !== this.arrayLength) {\n      throw new Error(\"array is wrong length\");\n    }\n    const childType = this.arrayChildren;\n    const result = value.slice();\n    result.forEach((value, index) => {\n      _classPrivateMethodGet(childType, _walkAsync, _walkAsync2).call(childType, promises, value, process, value => {\n        result[index] = value;\n      });\n    });\n    setValue(result);\n    return;\n  }\n  if (this.isTuple()) {\n    const components = this.components;\n    // Convert the object into an array\n    let result;\n    if (Array.isArray(value)) {\n      result = value.slice();\n    } else {\n      if (value == null || typeof value !== \"object\") {\n        throw new Error(\"invalid tuple value\");\n      }\n      result = components.map(param => {\n        if (!param.name) {\n          throw new Error(\"cannot use object value with unnamed components\");\n        }\n        if (!(param.name in value)) {\n          throw new Error(`missing value for component ${param.name}`);\n        }\n        return value[param.name];\n      });\n    }\n    if (result.length !== this.components.length) {\n      throw new Error(\"array is wrong length\");\n    }\n    result.forEach((value, index) => {\n      var _components$index;\n      _classPrivateMethodGet(_components$index = components[index], _walkAsync, _walkAsync2).call(_components$index, promises, value, process, value => {\n        result[index] = value;\n      });\n    });\n    setValue(result);\n    return;\n  }\n  const result = process(this.type, value);\n  if (result.then) {\n    promises.push(async function () {\n      setValue(await result);\n    }());\n  } else {\n    setValue(result);\n  }\n}\nexports.ParamType = ParamType;\n/**\n *  An abstract class to represent An individual fragment from a parse ABI.\n */\nclass Fragment {\n  /**\n   *  @private\n   */\n  constructor(guard, type, inputs) {\n    /**\n     *  The type of the fragment.\n     */\n    _defineProperty(this, \"type\", void 0);\n    /**\n     *  The inputs for the fragment.\n     */\n    _defineProperty(this, \"inputs\", void 0);\n    (0, index_js_1.assertPrivate)(guard, _guard, \"Fragment\");\n    inputs = Object.freeze(inputs.slice());\n    (0, index_js_1.defineProperties)(this, {\n      type,\n      inputs\n    });\n  }\n  /**\n   *  Creates a new **Fragment** for %%obj%%, wich can be any supported\n   *  ABI frgament type.\n   */\n  static from(obj) {\n    if (typeof obj === \"string\") {\n      // Try parsing JSON...\n      try {\n        Fragment.from(JSON.parse(obj));\n      } catch (e) {}\n      // ...otherwise, use the human-readable lexer\n      return Fragment.from(lex(obj));\n    }\n    if (obj instanceof TokenString) {\n      // Human-readable ABI (already lexed)\n      const type = obj.peekKeyword(KwTypes);\n      switch (type) {\n        case \"constructor\":\n          return ConstructorFragment.from(obj);\n        case \"error\":\n          return ErrorFragment.from(obj);\n        case \"event\":\n          return EventFragment.from(obj);\n        case \"fallback\":\n        case \"receive\":\n          return FallbackFragment.from(obj);\n        case \"function\":\n          return FunctionFragment.from(obj);\n        case \"struct\":\n          return StructFragment.from(obj);\n      }\n    } else if (typeof obj === \"object\") {\n      // JSON ABI\n      switch (obj.type) {\n        case \"constructor\":\n          return ConstructorFragment.from(obj);\n        case \"error\":\n          return ErrorFragment.from(obj);\n        case \"event\":\n          return EventFragment.from(obj);\n        case \"fallback\":\n        case \"receive\":\n          return FallbackFragment.from(obj);\n        case \"function\":\n          return FunctionFragment.from(obj);\n        case \"struct\":\n          return StructFragment.from(obj);\n      }\n      (0, index_js_1.assert)(false, `unsupported type: ${obj.type}`, \"UNSUPPORTED_OPERATION\", {\n        operation: \"Fragment.from\"\n      });\n    }\n    (0, index_js_1.assertArgument)(false, \"unsupported frgament object\", \"obj\", obj);\n  }\n  /**\n   *  Returns true if %%value%% is a [[ConstructorFragment]].\n   */\n  static isConstructor(value) {\n    return ConstructorFragment.isFragment(value);\n  }\n  /**\n   *  Returns true if %%value%% is an [[ErrorFragment]].\n   */\n  static isError(value) {\n    return ErrorFragment.isFragment(value);\n  }\n  /**\n   *  Returns true if %%value%% is an [[EventFragment]].\n   */\n  static isEvent(value) {\n    return EventFragment.isFragment(value);\n  }\n  /**\n   *  Returns true if %%value%% is a [[FunctionFragment]].\n   */\n  static isFunction(value) {\n    return FunctionFragment.isFragment(value);\n  }\n  /**\n   *  Returns true if %%value%% is a [[StructFragment]].\n   */\n  static isStruct(value) {\n    return StructFragment.isFragment(value);\n  }\n}\nexports.Fragment = Fragment;\n/**\n *  An abstract class to represent An individual fragment\n *  which has a name from a parse ABI.\n */\nclass NamedFragment extends Fragment {\n  /**\n   *  @private\n   */\n  constructor(guard, type, name, inputs) {\n    super(guard, type, inputs);\n    /**\n     *  The name of the fragment.\n     */\n    _defineProperty(this, \"name\", void 0);\n    (0, index_js_1.assertArgument)(typeof name === \"string\" && name.match(regexId), \"invalid identifier\", \"name\", name);\n    inputs = Object.freeze(inputs.slice());\n    (0, index_js_1.defineProperties)(this, {\n      name\n    });\n  }\n}\nexports.NamedFragment = NamedFragment;\nfunction joinParams(format, params) {\n  return \"(\" + params.map(p => p.format(format)).join(format === \"full\" ? \", \" : \",\") + \")\";\n}\n/**\n *  A Fragment which represents a //Custom Error//.\n */\nclass ErrorFragment extends NamedFragment {\n  /**\n   *  @private\n   */\n  constructor(guard, name, inputs) {\n    super(guard, \"error\", name, inputs);\n    Object.defineProperty(this, internal, {\n      value: ErrorFragmentInternal\n    });\n  }\n  /**\n   *  The Custom Error selector.\n   */\n  get selector() {\n    return (0, index_js_2.id)(this.format(\"sighash\")).substring(0, 10);\n  }\n  /**\n   *  Returns a string representation of this fragment as %%format%%.\n   */\n  format(format) {\n    if (format == null) {\n      format = \"sighash\";\n    }\n    if (format === \"json\") {\n      return JSON.stringify({\n        type: \"error\",\n        name: this.name,\n        inputs: this.inputs.map(input => JSON.parse(input.format(format)))\n      });\n    }\n    const result = [];\n    if (format !== \"sighash\") {\n      result.push(\"error\");\n    }\n    result.push(this.name + joinParams(format, this.inputs));\n    return result.join(\" \");\n  }\n  /**\n   *  Returns a new **ErrorFragment** for %%obj%%.\n   */\n  static from(obj) {\n    if (ErrorFragment.isFragment(obj)) {\n      return obj;\n    }\n    if (typeof obj === \"string\") {\n      return ErrorFragment.from(lex(obj));\n    } else if (obj instanceof TokenString) {\n      const name = consumeName(\"error\", obj);\n      const inputs = consumeParams(obj);\n      consumeEoi(obj);\n      return new ErrorFragment(_guard, name, inputs);\n    }\n    return new ErrorFragment(_guard, obj.name, obj.inputs ? obj.inputs.map(ParamType.from) : []);\n  }\n  /**\n   *  Returns ``true`` and provides a type guard if %%value%% is an\n   *  **ErrorFragment**.\n   */\n  static isFragment(value) {\n    return value && value[internal] === ErrorFragmentInternal;\n  }\n}\nexports.ErrorFragment = ErrorFragment;\n/**\n *  A Fragment which represents an Event.\n */\nclass EventFragment extends NamedFragment {\n  /**\n   *  @private\n   */\n  constructor(guard, name, inputs, anonymous) {\n    super(guard, \"event\", name, inputs);\n    /**\n     *  Whether this event is anonymous.\n     */\n    _defineProperty(this, \"anonymous\", void 0);\n    Object.defineProperty(this, internal, {\n      value: EventFragmentInternal\n    });\n    (0, index_js_1.defineProperties)(this, {\n      anonymous\n    });\n  }\n  /**\n   *  The Event topic hash.\n   */\n  get topicHash() {\n    return (0, index_js_2.id)(this.format(\"sighash\"));\n  }\n  /**\n   *  Returns a string representation of this event as %%format%%.\n   */\n  format(format) {\n    if (format == null) {\n      format = \"sighash\";\n    }\n    if (format === \"json\") {\n      return JSON.stringify({\n        type: \"event\",\n        anonymous: this.anonymous,\n        name: this.name,\n        inputs: this.inputs.map(i => JSON.parse(i.format(format)))\n      });\n    }\n    const result = [];\n    if (format !== \"sighash\") {\n      result.push(\"event\");\n    }\n    result.push(this.name + joinParams(format, this.inputs));\n    if (format !== \"sighash\" && this.anonymous) {\n      result.push(\"anonymous\");\n    }\n    return result.join(\" \");\n  }\n  /**\n   *  Return the topic hash for an event with %%name%% and %%params%%.\n   */\n  static getTopicHash(name, params) {\n    params = (params || []).map(p => ParamType.from(p));\n    const fragment = new EventFragment(_guard, name, params, false);\n    return fragment.topicHash;\n  }\n  /**\n   *  Returns a new **EventFragment** for %%obj%%.\n   */\n  static from(obj) {\n    if (EventFragment.isFragment(obj)) {\n      return obj;\n    }\n    if (typeof obj === \"string\") {\n      try {\n        return EventFragment.from(lex(obj));\n      } catch (error) {\n        (0, index_js_1.assertArgument)(false, \"invalid event fragment\", \"obj\", obj);\n      }\n    } else if (obj instanceof TokenString) {\n      const name = consumeName(\"event\", obj);\n      const inputs = consumeParams(obj, true);\n      const anonymous = !!consumeKeywords(obj, setify([\"anonymous\"])).has(\"anonymous\");\n      consumeEoi(obj);\n      return new EventFragment(_guard, name, inputs, anonymous);\n    }\n    return new EventFragment(_guard, obj.name, obj.inputs ? obj.inputs.map(p => ParamType.from(p, true)) : [], !!obj.anonymous);\n  }\n  /**\n   *  Returns ``true`` and provides a type guard if %%value%% is an\n   *  **EventFragment**.\n   */\n  static isFragment(value) {\n    return value && value[internal] === EventFragmentInternal;\n  }\n}\nexports.EventFragment = EventFragment;\n/**\n *  A Fragment which represents a constructor.\n */\nclass ConstructorFragment extends Fragment {\n  /**\n   *  @private\n   */\n  constructor(guard, type, inputs, payable, gas) {\n    super(guard, type, inputs);\n    /**\n     *  Whether the constructor can receive an endowment.\n     */\n    _defineProperty(this, \"payable\", void 0);\n    /**\n     *  The recommended gas limit for deployment or ``null``.\n     */\n    _defineProperty(this, \"gas\", void 0);\n    Object.defineProperty(this, internal, {\n      value: ConstructorFragmentInternal\n    });\n    (0, index_js_1.defineProperties)(this, {\n      payable,\n      gas\n    });\n  }\n  /**\n   *  Returns a string representation of this constructor as %%format%%.\n   */\n  format(format) {\n    (0, index_js_1.assert)(format != null && format !== \"sighash\", \"cannot format a constructor for sighash\", \"UNSUPPORTED_OPERATION\", {\n      operation: \"format(sighash)\"\n    });\n    if (format === \"json\") {\n      return JSON.stringify({\n        type: \"constructor\",\n        stateMutability: this.payable ? \"payable\" : \"undefined\",\n        payable: this.payable,\n        gas: this.gas != null ? this.gas : undefined,\n        inputs: this.inputs.map(i => JSON.parse(i.format(format)))\n      });\n    }\n    const result = [`constructor${joinParams(format, this.inputs)}`];\n    result.push(this.payable ? \"payable\" : \"nonpayable\");\n    if (this.gas != null) {\n      result.push(`@${this.gas.toString()}`);\n    }\n    return result.join(\" \");\n  }\n  /**\n   *  Returns a new **ConstructorFragment** for %%obj%%.\n   */\n  static from(obj) {\n    if (ConstructorFragment.isFragment(obj)) {\n      return obj;\n    }\n    if (typeof obj === \"string\") {\n      try {\n        return ConstructorFragment.from(lex(obj));\n      } catch (error) {\n        (0, index_js_1.assertArgument)(false, \"invalid constuctor fragment\", \"obj\", obj);\n      }\n    } else if (obj instanceof TokenString) {\n      consumeKeywords(obj, setify([\"constructor\"]));\n      const inputs = consumeParams(obj);\n      const payable = !!consumeKeywords(obj, setify([\"payable\"])).has(\"payable\");\n      const gas = consumeGas(obj);\n      consumeEoi(obj);\n      return new ConstructorFragment(_guard, \"constructor\", inputs, payable, gas);\n    }\n    return new ConstructorFragment(_guard, \"constructor\", obj.inputs ? obj.inputs.map(ParamType.from) : [], !!obj.payable, obj.gas != null ? obj.gas : null);\n  }\n  /**\n   *  Returns ``true`` and provides a type guard if %%value%% is a\n   *  **ConstructorFragment**.\n   */\n  static isFragment(value) {\n    return value && value[internal] === ConstructorFragmentInternal;\n  }\n}\nexports.ConstructorFragment = ConstructorFragment;\n/**\n *  A Fragment which represents a method.\n */\nclass FallbackFragment extends Fragment {\n  constructor(guard, inputs, payable) {\n    super(guard, \"fallback\", inputs);\n    /**\n     *  If the function can be sent value during invocation.\n     */\n    _defineProperty(this, \"payable\", void 0);\n    Object.defineProperty(this, internal, {\n      value: FallbackFragmentInternal\n    });\n    (0, index_js_1.defineProperties)(this, {\n      payable\n    });\n  }\n  /**\n   *  Returns a string representation of this fallback as %%format%%.\n   */\n  format(format) {\n    const type = this.inputs.length === 0 ? \"receive\" : \"fallback\";\n    if (format === \"json\") {\n      const stateMutability = this.payable ? \"payable\" : \"nonpayable\";\n      return JSON.stringify({\n        type,\n        stateMutability\n      });\n    }\n    return `${type}()${this.payable ? \" payable\" : \"\"}`;\n  }\n  /**\n   *  Returns a new **FallbackFragment** for %%obj%%.\n   */\n  static from(obj) {\n    if (FallbackFragment.isFragment(obj)) {\n      return obj;\n    }\n    if (typeof obj === \"string\") {\n      try {\n        return FallbackFragment.from(lex(obj));\n      } catch (error) {\n        (0, index_js_1.assertArgument)(false, \"invalid fallback fragment\", \"obj\", obj);\n      }\n    } else if (obj instanceof TokenString) {\n      const errorObj = obj.toString();\n      const topIsValid = obj.peekKeyword(setify([\"fallback\", \"receive\"]));\n      (0, index_js_1.assertArgument)(topIsValid, \"type must be fallback or receive\", \"obj\", errorObj);\n      const type = obj.popKeyword(setify([\"fallback\", \"receive\"]));\n      // receive()\n      if (type === \"receive\") {\n        const inputs = consumeParams(obj);\n        (0, index_js_1.assertArgument)(inputs.length === 0, `receive cannot have arguments`, \"obj.inputs\", inputs);\n        consumeKeywords(obj, setify([\"payable\"]));\n        consumeEoi(obj);\n        return new FallbackFragment(_guard, [], true);\n      }\n      // fallback() [payable]\n      // fallback(bytes) [payable] returns (bytes)\n      let inputs = consumeParams(obj);\n      if (inputs.length) {\n        (0, index_js_1.assertArgument)(inputs.length === 1 && inputs[0].type === \"bytes\", \"invalid fallback inputs\", \"obj.inputs\", inputs.map(i => i.format(\"minimal\")).join(\", \"));\n      } else {\n        inputs = [ParamType.from(\"bytes\")];\n      }\n      const mutability = consumeMutability(obj);\n      (0, index_js_1.assertArgument)(mutability === \"nonpayable\" || mutability === \"payable\", \"fallback cannot be constants\", \"obj.stateMutability\", mutability);\n      if (consumeKeywords(obj, setify([\"returns\"])).has(\"returns\")) {\n        const outputs = consumeParams(obj);\n        (0, index_js_1.assertArgument)(outputs.length === 1 && outputs[0].type === \"bytes\", \"invalid fallback outputs\", \"obj.outputs\", outputs.map(i => i.format(\"minimal\")).join(\", \"));\n      }\n      consumeEoi(obj);\n      return new FallbackFragment(_guard, inputs, mutability === \"payable\");\n    }\n    if (obj.type === \"receive\") {\n      return new FallbackFragment(_guard, [], true);\n    }\n    if (obj.type === \"fallback\") {\n      const inputs = [ParamType.from(\"bytes\")];\n      const payable = obj.stateMutability === \"payable\";\n      return new FallbackFragment(_guard, inputs, payable);\n    }\n    (0, index_js_1.assertArgument)(false, \"invalid fallback description\", \"obj\", obj);\n  }\n  /**\n   *  Returns ``true`` and provides a type guard if %%value%% is a\n   *  **FallbackFragment**.\n   */\n  static isFragment(value) {\n    return value && value[internal] === FallbackFragmentInternal;\n  }\n}\nexports.FallbackFragment = FallbackFragment;\n/**\n *  A Fragment which represents a method.\n */\nclass FunctionFragment extends NamedFragment {\n  /**\n   *  @private\n   */\n  constructor(guard, name, stateMutability, inputs, outputs, gas) {\n    super(guard, \"function\", name, inputs);\n    /**\n     *  If the function is constant (e.g. ``pure`` or ``view`` functions).\n     */\n    _defineProperty(this, \"constant\", void 0);\n    /**\n     *  The returned types for the result of calling this function.\n     */\n    _defineProperty(this, \"outputs\", void 0);\n    /**\n     *  The state mutability (e.g. ``payable``, ``nonpayable``, ``view``\n     *  or ``pure``)\n     */\n    _defineProperty(this, \"stateMutability\", void 0);\n    /**\n     *  If the function can be sent value during invocation.\n     */\n    _defineProperty(this, \"payable\", void 0);\n    /**\n     *  The recommended gas limit to send when calling this function.\n     */\n    _defineProperty(this, \"gas\", void 0);\n    Object.defineProperty(this, internal, {\n      value: FunctionFragmentInternal\n    });\n    outputs = Object.freeze(outputs.slice());\n    const constant = stateMutability === \"view\" || stateMutability === \"pure\";\n    const payable = stateMutability === \"payable\";\n    (0, index_js_1.defineProperties)(this, {\n      constant,\n      gas,\n      outputs,\n      payable,\n      stateMutability\n    });\n  }\n  /**\n   *  The Function selector.\n   */\n  get selector() {\n    return (0, index_js_2.id)(this.format(\"sighash\")).substring(0, 10);\n  }\n  /**\n   *  Returns a string representation of this function as %%format%%.\n   */\n  format(format) {\n    if (format == null) {\n      format = \"sighash\";\n    }\n    if (format === \"json\") {\n      return JSON.stringify({\n        type: \"function\",\n        name: this.name,\n        constant: this.constant,\n        stateMutability: this.stateMutability !== \"nonpayable\" ? this.stateMutability : undefined,\n        payable: this.payable,\n        gas: this.gas != null ? this.gas : undefined,\n        inputs: this.inputs.map(i => JSON.parse(i.format(format))),\n        outputs: this.outputs.map(o => JSON.parse(o.format(format)))\n      });\n    }\n    const result = [];\n    if (format !== \"sighash\") {\n      result.push(\"function\");\n    }\n    result.push(this.name + joinParams(format, this.inputs));\n    if (format !== \"sighash\") {\n      if (this.stateMutability !== \"nonpayable\") {\n        result.push(this.stateMutability);\n      }\n      if (this.outputs && this.outputs.length) {\n        result.push(\"returns\");\n        result.push(joinParams(format, this.outputs));\n      }\n      if (this.gas != null) {\n        result.push(`@${this.gas.toString()}`);\n      }\n    }\n    return result.join(\" \");\n  }\n  /**\n   *  Return the selector for a function with %%name%% and %%params%%.\n   */\n  static getSelector(name, params) {\n    params = (params || []).map(p => ParamType.from(p));\n    const fragment = new FunctionFragment(_guard, name, \"view\", params, [], null);\n    return fragment.selector;\n  }\n  /**\n   *  Returns a new **FunctionFragment** for %%obj%%.\n   */\n  static from(obj) {\n    if (FunctionFragment.isFragment(obj)) {\n      return obj;\n    }\n    if (typeof obj === \"string\") {\n      try {\n        return FunctionFragment.from(lex(obj));\n      } catch (error) {\n        (0, index_js_1.assertArgument)(false, \"invalid function fragment\", \"obj\", obj);\n      }\n    } else if (obj instanceof TokenString) {\n      const name = consumeName(\"function\", obj);\n      const inputs = consumeParams(obj);\n      const mutability = consumeMutability(obj);\n      let outputs = [];\n      if (consumeKeywords(obj, setify([\"returns\"])).has(\"returns\")) {\n        outputs = consumeParams(obj);\n      }\n      const gas = consumeGas(obj);\n      consumeEoi(obj);\n      return new FunctionFragment(_guard, name, mutability, inputs, outputs, gas);\n    }\n    let stateMutability = obj.stateMutability;\n    // Use legacy Solidity ABI logic if stateMutability is missing\n    if (stateMutability == null) {\n      stateMutability = \"payable\";\n      if (typeof obj.constant === \"boolean\") {\n        stateMutability = \"view\";\n        if (!obj.constant) {\n          stateMutability = \"payable\";\n          if (typeof obj.payable === \"boolean\" && !obj.payable) {\n            stateMutability = \"nonpayable\";\n          }\n        }\n      } else if (typeof obj.payable === \"boolean\" && !obj.payable) {\n        stateMutability = \"nonpayable\";\n      }\n    }\n    // @TODO: verifyState for stateMutability (e.g. throw if\n    //        payable: false but stateMutability is \"nonpayable\")\n    return new FunctionFragment(_guard, obj.name, stateMutability, obj.inputs ? obj.inputs.map(ParamType.from) : [], obj.outputs ? obj.outputs.map(ParamType.from) : [], obj.gas != null ? obj.gas : null);\n  }\n  /**\n   *  Returns ``true`` and provides a type guard if %%value%% is a\n   *  **FunctionFragment**.\n   */\n  static isFragment(value) {\n    return value && value[internal] === FunctionFragmentInternal;\n  }\n}\nexports.FunctionFragment = FunctionFragment;\n/**\n *  A Fragment which represents a structure.\n */\nclass StructFragment extends NamedFragment {\n  /**\n   *  @private\n   */\n  constructor(guard, name, inputs) {\n    super(guard, \"struct\", name, inputs);\n    Object.defineProperty(this, internal, {\n      value: StructFragmentInternal\n    });\n  }\n  /**\n   *  Returns a string representation of this struct as %%format%%.\n   */\n  format() {\n    throw new Error(\"@TODO\");\n  }\n  /**\n   *  Returns a new **StructFragment** for %%obj%%.\n   */\n  static from(obj) {\n    if (typeof obj === \"string\") {\n      try {\n        return StructFragment.from(lex(obj));\n      } catch (error) {\n        (0, index_js_1.assertArgument)(false, \"invalid struct fragment\", \"obj\", obj);\n      }\n    } else if (obj instanceof TokenString) {\n      const name = consumeName(\"struct\", obj);\n      const inputs = consumeParams(obj);\n      consumeEoi(obj);\n      return new StructFragment(_guard, name, inputs);\n    }\n    return new StructFragment(_guard, obj.name, obj.inputs ? obj.inputs.map(ParamType.from) : []);\n  }\n  // @TODO: fix this return type\n  /**\n   *  Returns ``true`` and provides a type guard if %%value%% is a\n   *  **StructFragment**.\n   */\n  static isFragment(value) {\n    return value && value[internal] === StructFragmentInternal;\n  }\n}\nexports.StructFragment = StructFragment;","map":{"version":3,"names":["_defineProperty","require","default","_classPrivateMethodInitSpec","_classPrivateFieldInitSpec","_classPrivateMethodGet","_classPrivateFieldSet","_classPrivateFieldGet","index_js_1","index_js_2","setify","items","result","Set","forEach","k","add","Object","freeze","_kwVisib","KwVisib","split","_kwTypes","KwTypes","_kwModifiers","KwModifiers","_kwOther","_keywords","join","Keywords","SimpleTokens","regexWhitespacePrefix","RegExp","regexNumberPrefix","regexIdPrefix","regexId","regexType","_offset","WeakMap","_tokens","_subTokenString","WeakSet","TokenString","offset","length","constructor","tokens","writable","value","slice","clone","reset","popKeyword","allowed","top","peek","type","has","text","Error","pop","popType","JSON","stringify","popParen","_subTokenString2","call","match","popParams","link","linkNext","push","peekKeyword","peekType","_this$offset","_this$offset2","toString","i","token","from","to","map","t","assign","linkBack","lex","throwError","message","brackets","commas","cur","substring","depth","suffix","getNumber","allowSingle","set","included","key","keys","consumeName","keyword","consumeKeywords","keywords","consumeMutability","modifiers","consumeParams","allowIndexed","ParamType","consumeGas","getBigInt","consumeEoi","regexArrayType","verifyBasicType","assertArgument","parseInt","size","_guard","internal","Symbol","for","ParamTypeInternal","ErrorFragmentInternal","EventFragmentInternal","ConstructorFragmentInternal","FallbackFragmentInternal","FunctionFragmentInternal","StructFragmentInternal","_walkAsync","guard","name","baseType","indexed","components","arrayLength","arrayChildren","assertPrivate","defineProperty","defineProperties","format","undefined","isArray","parse","String","isTuple","c","comp","isIndexable","walk","process","Array","_this","v","walkAsync","promises","_walkAsync2","Promise","all","obj","isParamType","error","comps","bracket","arrayMatch","startsWith","tuple","setValue","childType","index","param","_components$index","then","exports","Fragment","inputs","e","ConstructorFragment","ErrorFragment","EventFragment","FallbackFragment","FunctionFragment","StructFragment","assert","operation","isConstructor","isFragment","isError","isEvent","isFunction","isStruct","NamedFragment","joinParams","params","p","selector","id","input","anonymous","topicHash","getTopicHash","fragment","payable","gas","stateMutability","errorObj","topIsValid","mutability","outputs","constant","o","getSelector"],"sources":["../../src.ts/abi/fragments.ts"],"sourcesContent":[null],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}