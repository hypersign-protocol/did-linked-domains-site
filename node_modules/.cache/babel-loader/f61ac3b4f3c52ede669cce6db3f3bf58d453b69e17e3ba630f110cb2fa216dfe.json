{"ast":null,"code":"\"use strict\";\n\nrequire(\"core-js/modules/es.typed-array.to-reversed.js\");\nrequire(\"core-js/modules/es.typed-array.to-sorted.js\");\nrequire(\"core-js/modules/es.typed-array.with.js\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Secp256k1HdWallet = exports.extractKdfConfiguration = void 0;\nconst crypto_1 = require(\"@cosmjs/crypto\");\nconst encoding_1 = require(\"@cosmjs/encoding\");\nconst utils_1 = require(\"@cosmjs/utils\");\nconst addresses_1 = require(\"./addresses\");\nconst paths_1 = require(\"./paths\");\nconst signature_1 = require(\"./signature\");\nconst signdoc_1 = require(\"./signdoc\");\nconst wallet_1 = require(\"./wallet\");\nconst serializationTypeV1 = \"secp256k1wallet-v1\";\n/**\n * A KDF configuration that is not very strong but can be used on the main thread.\n * It takes about 1 second in Node.js 16.0.0 and should have similar runtimes in other modern Wasm hosts.\n */\nconst basicPasswordHashingOptions = {\n  algorithm: \"argon2id\",\n  params: {\n    outputLength: 32,\n    opsLimit: 24,\n    memLimitKib: 12 * 1024\n  }\n};\nfunction isDerivationJson(thing) {\n  if (!(0, utils_1.isNonNullObject)(thing)) return false;\n  if (typeof thing.hdPath !== \"string\") return false;\n  if (typeof thing.prefix !== \"string\") return false;\n  return true;\n}\nfunction extractKdfConfigurationV1(doc) {\n  return doc.kdf;\n}\nfunction extractKdfConfiguration(serialization) {\n  const root = JSON.parse(serialization);\n  if (!(0, utils_1.isNonNullObject)(root)) throw new Error(\"Root document is not an object.\");\n  switch (root.type) {\n    case serializationTypeV1:\n      return extractKdfConfigurationV1(root);\n    default:\n      throw new Error(\"Unsupported serialization type\");\n  }\n}\nexports.extractKdfConfiguration = extractKdfConfiguration;\nconst defaultOptions = {\n  bip39Password: \"\",\n  hdPaths: [(0, paths_1.makeCosmoshubPath)(0)],\n  prefix: \"cosmos\"\n};\nclass Secp256k1HdWallet {\n  constructor(mnemonic, options) {\n    var _a, _b;\n    const hdPaths = (_a = options.hdPaths) !== null && _a !== void 0 ? _a : defaultOptions.hdPaths;\n    const prefix = (_b = options.prefix) !== null && _b !== void 0 ? _b : defaultOptions.prefix;\n    this.secret = mnemonic;\n    this.seed = options.seed;\n    this.accounts = hdPaths.map(hdPath => ({\n      hdPath: hdPath,\n      prefix\n    }));\n  }\n  /**\n   * Restores a wallet from the given BIP39 mnemonic.\n   *\n   * @param mnemonic Any valid English mnemonic.\n   * @param options An optional `Secp256k1HdWalletOptions` object optionally containing a bip39Password, hdPaths, and prefix.\n   */\n  static async fromMnemonic(mnemonic, options = {}) {\n    const mnemonicChecked = new crypto_1.EnglishMnemonic(mnemonic);\n    const seed = await crypto_1.Bip39.mnemonicToSeed(mnemonicChecked, options.bip39Password);\n    return new Secp256k1HdWallet(mnemonicChecked, Object.assign(Object.assign({}, options), {\n      seed: seed\n    }));\n  }\n  /**\n   * Generates a new wallet with a BIP39 mnemonic of the given length.\n   *\n   * @param length The number of words in the mnemonic (12, 15, 18, 21 or 24).\n   * @param options An optional `Secp256k1HdWalletOptions` object optionally containing a bip39Password, hdPaths, and prefix.\n   */\n  static async generate(length = 12, options = {}) {\n    const entropyLength = 4 * Math.floor(11 * length / 33);\n    const entropy = crypto_1.Random.getBytes(entropyLength);\n    const mnemonic = crypto_1.Bip39.encode(entropy);\n    return Secp256k1HdWallet.fromMnemonic(mnemonic.toString(), options);\n  }\n  /**\n   * Restores a wallet from an encrypted serialization.\n   *\n   * @param password The user provided password used to generate an encryption key via a KDF.\n   *                 This is not normalized internally (see \"Unicode normalization\" to learn more).\n   */\n  static async deserialize(serialization, password) {\n    const root = JSON.parse(serialization);\n    if (!(0, utils_1.isNonNullObject)(root)) throw new Error(\"Root document is not an object.\");\n    switch (root.type) {\n      case serializationTypeV1:\n        return Secp256k1HdWallet.deserializeTypeV1(serialization, password);\n      default:\n        throw new Error(\"Unsupported serialization type\");\n    }\n  }\n  /**\n   * Restores a wallet from an encrypted serialization.\n   *\n   * This is an advanced alternative to calling `deserialize(serialization, password)` directly, which allows\n   * you to offload the KDF execution to a non-UI thread (e.g. in a WebWorker).\n   *\n   * The caller is responsible for ensuring the key was derived with the given KDF configuration. This can be\n   * done using `extractKdfConfiguration(serialization)` and `executeKdf(password, kdfConfiguration)` from this package.\n   */\n  static async deserializeWithEncryptionKey(serialization, encryptionKey) {\n    const root = JSON.parse(serialization);\n    if (!(0, utils_1.isNonNullObject)(root)) throw new Error(\"Root document is not an object.\");\n    const untypedRoot = root;\n    switch (untypedRoot.type) {\n      case serializationTypeV1:\n        {\n          const decryptedBytes = await (0, wallet_1.decrypt)((0, encoding_1.fromBase64)(untypedRoot.data), encryptionKey, untypedRoot.encryption);\n          const decryptedDocument = JSON.parse((0, encoding_1.fromUtf8)(decryptedBytes));\n          const {\n            mnemonic,\n            accounts\n          } = decryptedDocument;\n          (0, utils_1.assert)(typeof mnemonic === \"string\");\n          if (!Array.isArray(accounts)) throw new Error(\"Property 'accounts' is not an array\");\n          if (!accounts.every(account => isDerivationJson(account))) {\n            throw new Error(\"Account is not in the correct format.\");\n          }\n          const firstPrefix = accounts[0].prefix;\n          if (!accounts.every(({\n            prefix\n          }) => prefix === firstPrefix)) {\n            throw new Error(\"Accounts do not all have the same prefix\");\n          }\n          const hdPaths = accounts.map(({\n            hdPath\n          }) => (0, crypto_1.stringToPath)(hdPath));\n          return Secp256k1HdWallet.fromMnemonic(mnemonic, {\n            hdPaths: hdPaths,\n            prefix: firstPrefix\n          });\n        }\n      default:\n        throw new Error(\"Unsupported serialization type\");\n    }\n  }\n  static async deserializeTypeV1(serialization, password) {\n    const root = JSON.parse(serialization);\n    if (!(0, utils_1.isNonNullObject)(root)) throw new Error(\"Root document is not an object.\");\n    const encryptionKey = await (0, wallet_1.executeKdf)(password, root.kdf);\n    return Secp256k1HdWallet.deserializeWithEncryptionKey(serialization, encryptionKey);\n  }\n  get mnemonic() {\n    return this.secret.toString();\n  }\n  async getAccounts() {\n    const accountsWithPrivkeys = await this.getAccountsWithPrivkeys();\n    return accountsWithPrivkeys.map(({\n      algo,\n      pubkey,\n      address\n    }) => ({\n      algo: algo,\n      pubkey: pubkey,\n      address: address\n    }));\n  }\n  async signAmino(signerAddress, signDoc) {\n    const accounts = await this.getAccountsWithPrivkeys();\n    const account = accounts.find(({\n      address\n    }) => address === signerAddress);\n    if (account === undefined) {\n      throw new Error(`Address ${signerAddress} not found in wallet`);\n    }\n    const {\n      privkey,\n      pubkey\n    } = account;\n    const message = (0, crypto_1.sha256)((0, signdoc_1.serializeSignDoc)(signDoc));\n    const signature = await crypto_1.Secp256k1.createSignature(message, privkey);\n    const signatureBytes = new Uint8Array([...signature.r(32), ...signature.s(32)]);\n    return {\n      signed: signDoc,\n      signature: (0, signature_1.encodeSecp256k1Signature)(pubkey, signatureBytes)\n    };\n  }\n  /**\n   * Generates an encrypted serialization of this wallet.\n   *\n   * @param password The user provided password used to generate an encryption key via a KDF.\n   *                 This is not normalized internally (see \"Unicode normalization\" to learn more).\n   */\n  async serialize(password) {\n    const kdfConfiguration = basicPasswordHashingOptions;\n    const encryptionKey = await (0, wallet_1.executeKdf)(password, kdfConfiguration);\n    return this.serializeWithEncryptionKey(encryptionKey, kdfConfiguration);\n  }\n  /**\n   * Generates an encrypted serialization of this wallet.\n   *\n   * This is an advanced alternative to calling `serialize(password)` directly, which allows you to\n   * offload the KDF execution to a non-UI thread (e.g. in a WebWorker).\n   *\n   * The caller is responsible for ensuring the key was derived with the given KDF options. If this\n   * is not the case, the wallet cannot be restored with the original password.\n   */\n  async serializeWithEncryptionKey(encryptionKey, kdfConfiguration) {\n    const dataToEncrypt = {\n      mnemonic: this.mnemonic,\n      accounts: this.accounts.map(({\n        hdPath,\n        prefix\n      }) => ({\n        hdPath: (0, crypto_1.pathToString)(hdPath),\n        prefix: prefix\n      }))\n    };\n    const dataToEncryptRaw = (0, encoding_1.toUtf8)(JSON.stringify(dataToEncrypt));\n    const encryptionConfiguration = {\n      algorithm: wallet_1.supportedAlgorithms.xchacha20poly1305Ietf\n    };\n    const encryptedData = await (0, wallet_1.encrypt)(dataToEncryptRaw, encryptionKey, encryptionConfiguration);\n    const out = {\n      type: serializationTypeV1,\n      kdf: kdfConfiguration,\n      encryption: encryptionConfiguration,\n      data: (0, encoding_1.toBase64)(encryptedData)\n    };\n    return JSON.stringify(out);\n  }\n  async getKeyPair(hdPath) {\n    const {\n      privkey\n    } = crypto_1.Slip10.derivePath(crypto_1.Slip10Curve.Secp256k1, this.seed, hdPath);\n    const {\n      pubkey\n    } = await crypto_1.Secp256k1.makeKeypair(privkey);\n    return {\n      privkey: privkey,\n      pubkey: crypto_1.Secp256k1.compressPubkey(pubkey)\n    };\n  }\n  async getAccountsWithPrivkeys() {\n    return Promise.all(this.accounts.map(async ({\n      hdPath,\n      prefix\n    }) => {\n      const {\n        privkey,\n        pubkey\n      } = await this.getKeyPair(hdPath);\n      const address = encoding_1.Bech32.encode(prefix, (0, addresses_1.rawSecp256k1PubkeyToRawAddress)(pubkey));\n      return {\n        algo: \"secp256k1\",\n        privkey: privkey,\n        pubkey: pubkey,\n        address: address\n      };\n    }));\n  }\n}\nexports.Secp256k1HdWallet = Secp256k1HdWallet;","map":{"version":3,"names":["crypto_1","require","encoding_1","utils_1","addresses_1","paths_1","signature_1","signdoc_1","wallet_1","serializationTypeV1","basicPasswordHashingOptions","algorithm","params","outputLength","opsLimit","memLimitKib","isDerivationJson","thing","isNonNullObject","hdPath","prefix","extractKdfConfigurationV1","doc","kdf","extractKdfConfiguration","serialization","root","JSON","parse","Error","type","exports","defaultOptions","bip39Password","hdPaths","makeCosmoshubPath","Secp256k1HdWallet","constructor","mnemonic","options","_a","_b","secret","seed","accounts","map","fromMnemonic","mnemonicChecked","EnglishMnemonic","Bip39","mnemonicToSeed","Object","assign","generate","length","entropyLength","Math","floor","entropy","Random","getBytes","encode","toString","deserialize","password","deserializeTypeV1","deserializeWithEncryptionKey","encryptionKey","untypedRoot","decryptedBytes","decrypt","fromBase64","data","encryption","decryptedDocument","fromUtf8","assert","Array","isArray","every","account","firstPrefix","stringToPath","executeKdf","getAccounts","accountsWithPrivkeys","getAccountsWithPrivkeys","algo","pubkey","address","signAmino","signerAddress","signDoc","find","undefined","privkey","message","sha256","serializeSignDoc","signature","Secp256k1","createSignature","signatureBytes","Uint8Array","r","s","signed","encodeSecp256k1Signature","serialize","kdfConfiguration","serializeWithEncryptionKey","dataToEncrypt","pathToString","dataToEncryptRaw","toUtf8","stringify","encryptionConfiguration","supportedAlgorithms","xchacha20poly1305Ietf","encryptedData","encrypt","out","toBase64","getKeyPair","Slip10","derivePath","Slip10Curve","makeKeypair","compressPubkey","Promise","all","Bech32","rawSecp256k1PubkeyToRawAddress"],"sources":["../src/secp256k1hdwallet.ts"],"sourcesContent":[null],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}