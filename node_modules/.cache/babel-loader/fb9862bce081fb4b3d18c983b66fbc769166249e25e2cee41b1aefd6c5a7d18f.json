{"ast":null,"code":"\"use strict\";\n\n// https://w3c-ccg.github.io/ethereum-eip712-signature-2021-spec/#types-generation\nrequire(\"core-js/modules/es.array.push.js\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.EIP712TypedData = void 0;\nconst {\n  JCS\n} = require('jcs');\n// add canonnicalize to JSON\n// @ts-ignore\nJSON.canonify = JCS.cannonicalize;\nclass EIP712TypedData {\n  constructor() {\n    this.keys = new Map();\n    this.finalOutput = {};\n  }\n  BFS(input, type, finalOutput) {\n    let out = [];\n    let queue = [];\n    queue.push(type);\n    while (queue.length > 0) {\n      let current = queue.shift();\n      Object.keys(input).forEach((key, index) => {\n        const type = typeof input[key];\n        if (type == \"object\") {\n          if (Array.isArray(input[key])) {\n            const isString = input[key].length > 0 && input[key].every(value => {\n              return typeof value == \"string\";\n            });\n            const isBool = input[key].length > 0 && input[key].every(value => {\n              return typeof value == \"boolean\";\n            });\n            const isNumber = input[key].length > 0 && input[key].every(value => {\n              return typeof value == \"number\";\n            });\n            if (isString) {\n              out.push({\n                name: key,\n                type: \"string[]\"\n              });\n            } else if (isBool) {\n              out.push({\n                name: key,\n                type: \"bool[]\"\n              });\n            } else if (isNumber) {\n              out.push({\n                name: key,\n                type: \"uint256[]\"\n              });\n            } else {\n              // throw new Error(\"Array of objects not supported\")\n              let output = {};\n              out.push({\n                name: key,\n                type: key.charAt(0).toUpperCase() + key.slice(1) + \"[]\"\n              });\n              return this.generateTypes(input[key][0], key.charAt(0).toUpperCase() + key.slice(1));\n              // return this.BFS(input[key], key,output,key.charAt(0).toUpperCase() + key.slice(1))\n            }\n          } else {\n            out.push({\n              name: key,\n              type: key.charAt(0).toUpperCase() + key.slice(1)\n            });\n            this.BFS(input[key], key, finalOutput);\n          }\n        }\n        if (type == \"string\") {\n          out.push({\n            name: key,\n            type: \"string\"\n          });\n        }\n        if (type == \"boolean\") {\n          out.push({\n            name: key,\n            type: \"bool\"\n          });\n        }\n        if (type == \"number\") {\n          out.push({\n            name: key,\n            type: \"uint256\"\n          });\n        }\n      });\n    }\n    this.finalOutput[type.charAt(0).toUpperCase() + type.slice(1)] = out;\n  }\n  generateTypes(input, primaryType) {\n    if (primaryType == undefined) {\n      primaryType = \"Document\";\n    }\n    // DFS is used to traverse graph dependencies but we need to explore first object properties first so we use BFS\n    // Canonicalize the type names\n    //@ts-ignore\n    input = JSON.parse(JSON.canonify(input));\n    let out = this.BFS(input, primaryType, this.finalOutput);\n    this.finalOutput = this.finalOutput;\n    //@ts-ignore\n    out = JSON.canonify(this.finalOutput);\n    return JSON.parse(out);\n  }\n}\nexports.EIP712TypedData = EIP712TypedData;","map":{"version":3,"names":["require","Object","defineProperty","exports","value","EIP712TypedData","JCS","JSON","canonify","cannonicalize","constructor","keys","Map","finalOutput","BFS","input","type","out","queue","push","length","current","shift","forEach","key","index","Array","isArray","isString","every","isBool","isNumber","name","output","charAt","toUpperCase","slice","generateTypes","primaryType","undefined","parse"],"sources":["/home/pratap/hid-ssi-js-sdk/node_modules/ethereumeip712signature2021suite/lib/src/TypedData/Eip712Types.js"],"sourcesContent":["\"use strict\";\n// https://w3c-ccg.github.io/ethereum-eip712-signature-2021-spec/#types-generation\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.EIP712TypedData = void 0;\nconst { JCS } = require('jcs');\n// add canonnicalize to JSON\n// @ts-ignore\nJSON.canonify = JCS.cannonicalize;\nclass EIP712TypedData {\n    constructor() {\n        this.keys = new Map();\n        this.finalOutput = {};\n    }\n    BFS(input, type, finalOutput) {\n        let out = [];\n        let queue = [];\n        queue.push(type);\n        while (queue.length > 0) {\n            let current = queue.shift();\n            Object.keys(input).forEach((key, index) => {\n                const type = typeof input[key];\n                if (type == \"object\") {\n                    if (Array.isArray(input[key])) {\n                        const isString = input[key].length > 0 && input[key].every((value) => {\n                            return typeof value == \"string\";\n                        });\n                        const isBool = input[key].length > 0 && input[key].every((value) => {\n                            return typeof value == \"boolean\";\n                        });\n                        const isNumber = input[key].length > 0 && input[key].every((value) => {\n                            return typeof value == \"number\";\n                        });\n                        if (isString) {\n                            out.push({\n                                name: key,\n                                type: \"string[]\"\n                            });\n                        }\n                        else if (isBool) {\n                            out.push({\n                                name: key,\n                                type: \"bool[]\"\n                            });\n                        }\n                        else if (isNumber) {\n                            out.push({\n                                name: key,\n                                type: \"uint256[]\"\n                            });\n                        }\n                        else {\n                            // throw new Error(\"Array of objects not supported\")\n                            let output = {};\n                            out.push({\n                                name: key,\n                                type: key.charAt(0).toUpperCase() + key.slice(1) + \"[]\"\n                            });\n                            return this.generateTypes(input[key][0], key.charAt(0).toUpperCase() + key.slice(1));\n                            // return this.BFS(input[key], key,output,key.charAt(0).toUpperCase() + key.slice(1))\n                        }\n                    }\n                    else {\n                        out.push({\n                            name: key,\n                            type: key.charAt(0).toUpperCase() + key.slice(1)\n                        });\n                        this.BFS(input[key], key, finalOutput);\n                    }\n                }\n                if (type == \"string\") {\n                    out.push({\n                        name: key,\n                        type: \"string\"\n                    });\n                }\n                if (type == \"boolean\") {\n                    out.push({\n                        name: key,\n                        type: \"bool\"\n                    });\n                }\n                if (type == \"number\") {\n                    out.push({\n                        name: key,\n                        type: \"uint256\"\n                    });\n                }\n            });\n        }\n        this.finalOutput[type.charAt(0).toUpperCase() + type.slice(1)] = out;\n    }\n    generateTypes(input, primaryType) {\n        if (primaryType == undefined) {\n            primaryType = \"Document\";\n        }\n        // DFS is used to traverse graph dependencies but we need to explore first object properties first so we use BFS\n        // Canonicalize the type names\n        //@ts-ignore\n        input = JSON.parse(JSON.canonify(input));\n        let out = this.BFS(input, primaryType, this.finalOutput);\n        this.finalOutput = this.finalOutput;\n        //@ts-ignore\n        out = JSON.canonify(this.finalOutput);\n        return JSON.parse(out);\n    }\n}\nexports.EIP712TypedData = EIP712TypedData;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}