{"ast":null,"code":"/*!\n * Copyright (c) 2018 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n\nrequire(\"core-js/modules/es.array.push.js\");\nconst constants = require('./constants');\nconst jsonld = require('jsonld');\nconst {\n  extendContextLoader,\n  strictDocumentLoader\n} = require('./documentLoader');\nconst {\n  serializeError\n} = require('serialize-error');\nconst strictExpansionMap = require('./expansionMap');\nmodule.exports = class ProofSet {\n  /**\n   * Adds a Linked Data proof to a document. If the document contains other\n   * proofs, the new proof will be appended to the existing set of proofs.\n   *\n   * Important note: This method assumes that the term `proof` in the given\n   * document has the same definition as the `https://w3id.org/security/v2`\n   * JSON-LD @context.\n   *\n   * @param document {object} - JSON-LD Document to be signed.\n   * @param options {object} Options hashmap.\n   *\n   * A `suite` option is required:\n   *\n   * @param options.suite {LinkedDataSignature} a signature suite instance\n   *   that will create the proof.\n   *\n   * A `purpose` option is required:\n   *\n   * @param options.purpose {ProofPurpose} a proof purpose instance that will\n   *   augment the proof with information describing its intended purpose.\n   *\n   * Advanced optional parameters and overrides:\n   *\n   * @param [documentLoader] {function} a custom document loader,\n   *   `Promise<RemoteDocument> documentLoader(url)`.\n   * @param [expansionMap] {function} A custom expansion map that is\n   *   passed to the JSON-LD processor; by default a function that will throw\n   *   an error when unmapped properties are detected in the input, use `false`\n   *   to turn this off and allow unmapped properties to be dropped or use a\n   *   custom function.\n   *\n   * @return {Promise<object>} resolves with the signed document, with\n   *   the signature in the top-level `proof` property.\n   */\n  async add(document, {\n    suite,\n    purpose,\n    documentLoader,\n    expansionMap\n  } = {}) {\n    if (!suite) {\n      throw new TypeError('\"options.suite\" is required.');\n    }\n    if (!purpose) {\n      throw new TypeError('\"options.purpose\" is required.');\n    }\n    if (documentLoader) {\n      documentLoader = extendContextLoader(documentLoader);\n    } else {\n      documentLoader = strictDocumentLoader;\n    }\n    if (expansionMap === undefined) {\n      expansionMap = strictExpansionMap;\n    } else if (expansionMap === false) {\n      expansionMap = undefined;\n    }\n\n    // preprocess document to prepare to remove existing proofs\n    // let input;\n    // shallow copy document to allow removal of existing proofs\n    const input = {\n      ...document\n    };\n    delete input.proof;\n\n    // create the new proof (suites MUST output a proof using the security-v2\n    // `@context`)\n    const proof = await suite.createProof({\n      document: input,\n      purpose,\n      documentLoader,\n      expansionMap\n    });\n    jsonld.addValue(document, 'proof', proof);\n    return document;\n  }\n\n  /**\n   * Verifies Linked Data proof(s) on a document. The proofs to be verified\n   * must match the given proof purpose.\n   *\n   * Important note: This method assumes that the term `proof` in the given\n   * document has the same definition as the `https://w3id.org/security/v2`\n   * JSON-LD @context.\n   *\n   * @param {object} document - The JSON-LD document with one or more proofs to\n   *   be verified.\n   *\n   * @param {LinkedDataSignature|LinkedDataSignature[]} suite -\n   *   Acceptable signature suite instances for verifying the proof(s).\n   *\n   * @param {ProofPurpose} purpose - A proof purpose instance that will\n   *   match proofs to be verified and ensure they were created according to\n   *   the appropriate purpose.\n   *\n   * Advanced optional parameters and overrides:\n   *\n   * @param {function} [documentLoader]  a custom document loader,\n   *   `Promise<RemoteDocument> documentLoader(url)`.\n   * @param {function} [expansionMap] - A custom expansion map that is\n   *   passed to the JSON-LD processor; by default a function that will throw\n   *   an error when unmapped properties are detected in the input, use `false`\n   *   to turn this off and allow unmapped properties to be dropped or use a\n   *   custom function.\n   *\n   * @return {Promise<{verified: boolean, results: Array, error: *}>} resolves\n   *   with an object with a `verified`boolean property that is `true` if at\n   *   least one proof matching the given purpose and suite verifies and `false`\n   *   otherwise; a `results` property with an array of detailed results;\n   *   if `false` an `error` property will be present.\n   */\n  async verify(document, {\n    suite,\n    purpose,\n    documentLoader,\n    expansionMap\n  } = {}) {\n    if (!suite) {\n      throw new TypeError('\"options.suite\" is required.');\n    }\n    if (!purpose) {\n      throw new TypeError('\"options.purpose\" is required.');\n    }\n    const suites = Array.isArray(suite) ? suite : [suite];\n    if (suites.length === 0) {\n      throw new TypeError('At least one suite is required.');\n    }\n    if (documentLoader) {\n      documentLoader = extendContextLoader(documentLoader);\n    } else {\n      documentLoader = strictDocumentLoader;\n    }\n    if (expansionMap === undefined) {\n      expansionMap = strictExpansionMap;\n    } else if (expansionMap === false) {\n      expansionMap = undefined;\n    }\n    try {\n      // shallow copy to allow for removal of proof set prior to canonize\n      document = {\n        ...document\n      };\n\n      // get proofs from document\n      const {\n        proofSet,\n        document: doc\n      } = await _getProofs({\n        document,\n        documentLoader,\n        expansionMap\n      });\n      document = doc;\n\n      // verify proofs\n      const results = await _verify({\n        document,\n        suites,\n        proofSet,\n        purpose,\n        documentLoader,\n        expansionMap\n      });\n      if (results.length === 0) {\n        const error = new Error('Did not verify any proofs; insufficient proofs matched the ' + 'acceptable suite(s) and required purpose(s).');\n        error.name = 'NotFoundError';\n        throw error;\n      }\n\n      // combine results\n      const verified = results.some(r => r.verified);\n      if (!verified) {\n        const errors = [].concat(...results.filter(r => r.error).map(r => r.error));\n        const result = {\n          verified,\n          results\n        };\n        if (errors.length > 0) {\n          result.error = errors;\n        }\n        return result;\n      }\n      return {\n        verified,\n        results\n      };\n    } catch (error) {\n      _makeSerializable(error);\n      return {\n        verified: false,\n        error\n      };\n    }\n  }\n};\nasync function _getProofs({\n  document\n}) {\n  // handle document preprocessing to find proofs\n  let proofSet;\n  proofSet = jsonld.getValues(document, 'proof');\n  delete document.proof;\n  if (proofSet.length === 0) {\n    // no possible matches\n    throw new Error('No matching proofs found in the given document.');\n  }\n\n  // shallow copy proofs and add document context or SECURITY_CONTEXT_URL\n  const context = document['@context'] || constants.SECURITY_CONTEXT_URL;\n  proofSet = proofSet.map(proof => ({\n    '@context': context,\n    ...proof\n  }));\n  return {\n    proofSet,\n    document\n  };\n}\nasync function _verify({\n  document,\n  suites,\n  proofSet,\n  purpose,\n  documentLoader,\n  expansionMap\n}) {\n  // map each purpose to at least one proof to verify\n  const purposes = Array.isArray(purpose) ? purpose : [purpose];\n  const purposeToProofs = new Map();\n  const proofToSuite = new Map();\n  const suiteMatchQueue = new Map();\n  await Promise.all(purposes.map(purpose => _matchProofSet({\n    purposeToProofs,\n    proofToSuite,\n    purpose,\n    proofSet,\n    suites,\n    suiteMatchQueue,\n    document,\n    documentLoader,\n    expansionMap\n  })));\n\n  // every purpose must have at least one matching proof or verify will fail\n  if (purposeToProofs.size < purposes.length) {\n    // insufficient proofs to verify, so don't bother verifying any\n    return [];\n  }\n\n  // verify every proof in `proofToSuite`; these proofs matched a purpose\n  const verifyResults = new Map();\n  await Promise.all([...proofToSuite.entries()].map(async ([proof, suite]) => {\n    let result;\n    try {\n      // create backwards-compatible deferred proof purpose to capture\n      // verification method from old-style suites\n      let vm;\n      const purpose = {\n        async validate(proof, {\n          verificationMethod\n        }) {\n          vm = verificationMethod;\n          return {\n            valid: true\n          };\n        }\n      };\n      const {\n        verified,\n        verificationMethod,\n        error\n      } = await suite.verifyProof({\n        proof,\n        document,\n        purpose,\n        documentLoader,\n        expansionMap\n      });\n      if (!vm) {\n        vm = verificationMethod;\n      }\n      result = {\n        proof,\n        verified,\n        verificationMethod: vm,\n        error\n      };\n    } catch (error) {\n      result = {\n        proof,\n        verified: false,\n        error\n      };\n    }\n    if (result.error) {\n      // ensure error is serializable\n      _makeSerializable(result.error);\n    }\n    verifyResults.set(proof, result);\n  }));\n\n  // validate proof against each purpose that matched it\n  await Promise.all([...purposeToProofs.entries()].map(async ([purpose, proofs]) => {\n    for (const proof of proofs) {\n      const result = verifyResults.get(proof);\n      if (!result.verified) {\n        // if proof was not verified, so not bother validating purpose\n        continue;\n      }\n\n      // validate purpose\n      const {\n        verificationMethod\n      } = result;\n      const suite = proofToSuite.get(proof);\n      let purposeResult;\n      try {\n        purposeResult = await purpose.validate(proof, {\n          document,\n          suite,\n          verificationMethod,\n          documentLoader,\n          expansionMap\n        });\n      } catch (error) {\n        purposeResult = {\n          valid: false,\n          error\n        };\n      }\n\n      // add `purposeResult` to verification result regardless of validity\n      // to ensure that all purposes are represented\n      if (result.purposeResult) {\n        if (Array.isArray(result.purposeResult)) {\n          result.purposeResult.push(purposeResult);\n        } else {\n          result.purposeResult = [result.purposeResult, purposeResult];\n        }\n      } else {\n        result.purposeResult = purposeResult;\n      }\n      if (!purposeResult.valid) {\n        // ensure error is serializable\n        _makeSerializable(purposeResult.error);\n\n        // if no top level error set yet, set it\n        if (!result.error) {\n          result.verified = false;\n          result.error = purposeResult.error;\n        }\n      }\n    }\n  }));\n  return [...verifyResults.values()];\n}\n\n// add a `toJSON` method to an error which allows for errors in validation\n// reports to be serialized properly by `JSON.stringify`.\nfunction _makeSerializable(error) {\n  Object.defineProperty(error, 'toJSON', {\n    value: function () {\n      return serializeError(this);\n    },\n    configurable: true,\n    writable: true\n  });\n}\nasync function _matchProofSet({\n  purposeToProofs,\n  proofToSuite,\n  purpose,\n  proofSet,\n  suites,\n  suiteMatchQueue,\n  document,\n  documentLoader,\n  expansionMap\n}) {\n  for (const proof of proofSet) {\n    // first check if the proof matches the purpose; if it doesn't continue\n    if (!(await purpose.match(proof, {\n      document,\n      documentLoader,\n      expansionMap\n    }))) {\n      continue;\n    }\n\n    // next, find the suite that can verify the proof; if found, `matched`\n    // will be set to `true` and the proof will be added to `purposeToProofs`\n    // and `proofToSuite` to be processed -- otherwise it will not be; if\n    // no proofs are added for a given purpose, an exception will be thrown\n    let matched = false;\n    for (const s of suites) {\n      // `matchingProofs` is a map of promises that resolve to whether a\n      // proof matches a suite; multiple purposes and suites may be checked\n      // in parallel so a promise queue is used to prevent duplicate work\n      let matchingProofs = suiteMatchQueue.get(s);\n      if (!matchingProofs) {\n        suiteMatchQueue.set(s, matchingProofs = new Map());\n      }\n      let promise = matchingProofs.get(proof);\n      if (!promise) {\n        promise = s.matchProof({\n          proof,\n          document,\n          documentLoader,\n          expansionMap\n        });\n        matchingProofs.set(proof, promise);\n      }\n      if (await promise) {\n        // found the matching suite for the proof; there should only be one\n        // suite that can verify a particular proof; add the proof to the\n        // map of proofs to be verified along with the matching suite\n        matched = true;\n        proofToSuite.set(proof, s);\n        break;\n      }\n    }\n    if (matched) {\n      // note proof was a match for the purpose and an acceptable suite; it\n      // will need to be verified by the suite and then validated against the\n      // purpose\n      const matches = purposeToProofs.get(purpose);\n      if (matches) {\n        matches.push(proof);\n      } else {\n        purposeToProofs.set(purpose, [proof]);\n      }\n    }\n  }\n}","map":{"version":3,"names":["require","constants","jsonld","extendContextLoader","strictDocumentLoader","serializeError","strictExpansionMap","module","exports","ProofSet","add","document","suite","purpose","documentLoader","expansionMap","TypeError","undefined","input","proof","createProof","addValue","verify","suites","Array","isArray","length","proofSet","doc","_getProofs","results","_verify","error","Error","name","verified","some","r","errors","concat","filter","map","result","_makeSerializable","getValues","context","SECURITY_CONTEXT_URL","purposes","purposeToProofs","Map","proofToSuite","suiteMatchQueue","Promise","all","_matchProofSet","size","verifyResults","entries","vm","validate","verificationMethod","valid","verifyProof","set","proofs","get","purposeResult","push","values","Object","defineProperty","value","configurable","writable","match","matched","s","matchingProofs","promise","matchProof","matches"],"sources":["/home/pratap/hid-ssi-js-sdk/node_modules/jsonld-signatures/lib/ProofSet.js"],"sourcesContent":["/*!\n * Copyright (c) 2018 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n\nconst constants = require('./constants');\nconst jsonld = require('jsonld');\nconst {extendContextLoader, strictDocumentLoader} = require('./documentLoader');\nconst {serializeError} = require('serialize-error');\nconst strictExpansionMap = require('./expansionMap');\n\nmodule.exports = class ProofSet {\n  /**\n   * Adds a Linked Data proof to a document. If the document contains other\n   * proofs, the new proof will be appended to the existing set of proofs.\n   *\n   * Important note: This method assumes that the term `proof` in the given\n   * document has the same definition as the `https://w3id.org/security/v2`\n   * JSON-LD @context.\n   *\n   * @param document {object} - JSON-LD Document to be signed.\n   * @param options {object} Options hashmap.\n   *\n   * A `suite` option is required:\n   *\n   * @param options.suite {LinkedDataSignature} a signature suite instance\n   *   that will create the proof.\n   *\n   * A `purpose` option is required:\n   *\n   * @param options.purpose {ProofPurpose} a proof purpose instance that will\n   *   augment the proof with information describing its intended purpose.\n   *\n   * Advanced optional parameters and overrides:\n   *\n   * @param [documentLoader] {function} a custom document loader,\n   *   `Promise<RemoteDocument> documentLoader(url)`.\n   * @param [expansionMap] {function} A custom expansion map that is\n   *   passed to the JSON-LD processor; by default a function that will throw\n   *   an error when unmapped properties are detected in the input, use `false`\n   *   to turn this off and allow unmapped properties to be dropped or use a\n   *   custom function.\n   *\n   * @return {Promise<object>} resolves with the signed document, with\n   *   the signature in the top-level `proof` property.\n   */\n  async add(document, {suite, purpose, documentLoader, expansionMap} = {}) {\n    if(!suite) {\n      throw new TypeError('\"options.suite\" is required.');\n    }\n    if(!purpose) {\n      throw new TypeError('\"options.purpose\" is required.');\n    }\n\n    if(documentLoader) {\n      documentLoader = extendContextLoader(documentLoader);\n    } else {\n      documentLoader = strictDocumentLoader;\n    }\n    if(expansionMap === undefined) {\n      expansionMap = strictExpansionMap;\n    } else if(expansionMap === false) {\n      expansionMap = undefined;\n    }\n\n    // preprocess document to prepare to remove existing proofs\n    // let input;\n    // shallow copy document to allow removal of existing proofs\n    const input = {...document};\n\n    delete input.proof;\n\n    // create the new proof (suites MUST output a proof using the security-v2\n    // `@context`)\n    const proof = await suite.createProof({\n      document: input, purpose, documentLoader, expansionMap\n    });\n\n    jsonld.addValue(document, 'proof', proof);\n\n    return document;\n  }\n\n  /**\n   * Verifies Linked Data proof(s) on a document. The proofs to be verified\n   * must match the given proof purpose.\n   *\n   * Important note: This method assumes that the term `proof` in the given\n   * document has the same definition as the `https://w3id.org/security/v2`\n   * JSON-LD @context.\n   *\n   * @param {object} document - The JSON-LD document with one or more proofs to\n   *   be verified.\n   *\n   * @param {LinkedDataSignature|LinkedDataSignature[]} suite -\n   *   Acceptable signature suite instances for verifying the proof(s).\n   *\n   * @param {ProofPurpose} purpose - A proof purpose instance that will\n   *   match proofs to be verified and ensure they were created according to\n   *   the appropriate purpose.\n   *\n   * Advanced optional parameters and overrides:\n   *\n   * @param {function} [documentLoader]  a custom document loader,\n   *   `Promise<RemoteDocument> documentLoader(url)`.\n   * @param {function} [expansionMap] - A custom expansion map that is\n   *   passed to the JSON-LD processor; by default a function that will throw\n   *   an error when unmapped properties are detected in the input, use `false`\n   *   to turn this off and allow unmapped properties to be dropped or use a\n   *   custom function.\n   *\n   * @return {Promise<{verified: boolean, results: Array, error: *}>} resolves\n   *   with an object with a `verified`boolean property that is `true` if at\n   *   least one proof matching the given purpose and suite verifies and `false`\n   *   otherwise; a `results` property with an array of detailed results;\n   *   if `false` an `error` property will be present.\n   */\n  async verify(document, {suite, purpose, documentLoader, expansionMap} = {}) {\n    if(!suite) {\n      throw new TypeError('\"options.suite\" is required.');\n    }\n    if(!purpose) {\n      throw new TypeError('\"options.purpose\" is required.');\n    }\n    const suites = Array.isArray(suite) ? suite : [suite];\n    if(suites.length === 0) {\n      throw new TypeError('At least one suite is required.');\n    }\n\n    if(documentLoader) {\n      documentLoader = extendContextLoader(documentLoader);\n    } else {\n      documentLoader = strictDocumentLoader;\n    }\n    if(expansionMap === undefined) {\n      expansionMap = strictExpansionMap;\n    } else if(expansionMap === false) {\n      expansionMap = undefined;\n    }\n\n    try {\n      // shallow copy to allow for removal of proof set prior to canonize\n      document = {...document};\n\n      // get proofs from document\n      const {proofSet, document: doc} = await _getProofs({\n        document, documentLoader, expansionMap\n      });\n      document = doc;\n\n      // verify proofs\n      const results = await _verify({\n        document, suites, proofSet, purpose, documentLoader, expansionMap\n      });\n      if(results.length === 0) {\n        const error = new Error(\n          'Did not verify any proofs; insufficient proofs matched the ' +\n          'acceptable suite(s) and required purpose(s).');\n        error.name = 'NotFoundError';\n        throw error;\n      }\n\n      // combine results\n      const verified = results.some(r => r.verified);\n      if(!verified) {\n        const errors = [].concat(\n          ...results.filter(r => r.error).map(r => r.error));\n        const result = {verified, results};\n        if(errors.length > 0) {\n          result.error = errors;\n        }\n        return result;\n      }\n      return {verified, results};\n    } catch(error) {\n      _makeSerializable(error);\n      return {verified: false, error};\n    }\n  }\n};\n\nasync function _getProofs({document}) {\n  // handle document preprocessing to find proofs\n  let proofSet;\n  proofSet = jsonld.getValues(document, 'proof');\n  delete document.proof;\n\n  if(proofSet.length === 0) {\n    // no possible matches\n    throw new Error('No matching proofs found in the given document.');\n  }\n\n  // shallow copy proofs and add document context or SECURITY_CONTEXT_URL\n  const context = document['@context'] || constants.SECURITY_CONTEXT_URL;\n  proofSet = proofSet.map(proof => ({\n    '@context': context,\n    ...proof\n  }));\n\n  return {proofSet, document};\n}\n\nasync function _verify({\n  document, suites, proofSet, purpose, documentLoader, expansionMap\n}) {\n  // map each purpose to at least one proof to verify\n  const purposes = Array.isArray(purpose) ? purpose : [purpose];\n  const purposeToProofs = new Map();\n  const proofToSuite = new Map();\n  const suiteMatchQueue = new Map();\n  await Promise.all(purposes.map(purpose => _matchProofSet({\n    purposeToProofs, proofToSuite, purpose, proofSet, suites,\n    suiteMatchQueue, document, documentLoader, expansionMap\n  })));\n\n  // every purpose must have at least one matching proof or verify will fail\n  if(purposeToProofs.size < purposes.length) {\n    // insufficient proofs to verify, so don't bother verifying any\n    return [];\n  }\n\n  // verify every proof in `proofToSuite`; these proofs matched a purpose\n  const verifyResults = new Map();\n  await Promise.all([...proofToSuite.entries()].map(async ([proof, suite]) => {\n    let result;\n    try {\n      // create backwards-compatible deferred proof purpose to capture\n      // verification method from old-style suites\n      let vm;\n      const purpose = {\n        async validate(proof, {verificationMethod}) {\n          vm = verificationMethod;\n          return {valid: true};\n        }\n      };\n      const {verified, verificationMethod, error} = await suite.verifyProof({\n        proof, document, purpose, documentLoader, expansionMap\n      });\n      if(!vm) {\n        vm = verificationMethod;\n      }\n      result = {proof, verified, verificationMethod: vm, error};\n    } catch(error) {\n      result = {proof, verified: false, error};\n    }\n\n    if(result.error) {\n      // ensure error is serializable\n      _makeSerializable(result.error);\n    }\n\n    verifyResults.set(proof, result);\n  }));\n\n  // validate proof against each purpose that matched it\n  await Promise.all([...purposeToProofs.entries()].map(\n    async ([purpose, proofs]) => {\n      for(const proof of proofs) {\n        const result = verifyResults.get(proof);\n        if(!result.verified) {\n          // if proof was not verified, so not bother validating purpose\n          continue;\n        }\n\n        // validate purpose\n        const {verificationMethod} = result;\n        const suite = proofToSuite.get(proof);\n        let purposeResult;\n        try {\n          purposeResult = await purpose.validate(proof, {\n            document, suite, verificationMethod, documentLoader, expansionMap\n          });\n        } catch(error) {\n          purposeResult = {valid: false, error};\n        }\n\n        // add `purposeResult` to verification result regardless of validity\n        // to ensure that all purposes are represented\n        if(result.purposeResult) {\n          if(Array.isArray(result.purposeResult)) {\n            result.purposeResult.push(purposeResult);\n          } else {\n            result.purposeResult = [result.purposeResult, purposeResult];\n          }\n        } else {\n          result.purposeResult = purposeResult;\n        }\n\n        if(!purposeResult.valid) {\n          // ensure error is serializable\n          _makeSerializable(purposeResult.error);\n\n          // if no top level error set yet, set it\n          if(!result.error) {\n            result.verified = false;\n            result.error = purposeResult.error;\n          }\n        }\n      }\n    }));\n\n  return [...verifyResults.values()];\n}\n\n// add a `toJSON` method to an error which allows for errors in validation\n// reports to be serialized properly by `JSON.stringify`.\nfunction _makeSerializable(error) {\n  Object.defineProperty(error, 'toJSON', {\n    value: function() {\n      return serializeError(this);\n    },\n    configurable: true,\n    writable: true\n  });\n}\n\nasync function _matchProofSet({\n  purposeToProofs, proofToSuite, purpose, proofSet, suites,\n  suiteMatchQueue, document, documentLoader, expansionMap\n}) {\n  for(const proof of proofSet) {\n    // first check if the proof matches the purpose; if it doesn't continue\n    if(!await purpose.match(proof, {document, documentLoader, expansionMap})) {\n      continue;\n    }\n\n    // next, find the suite that can verify the proof; if found, `matched`\n    // will be set to `true` and the proof will be added to `purposeToProofs`\n    // and `proofToSuite` to be processed -- otherwise it will not be; if\n    // no proofs are added for a given purpose, an exception will be thrown\n    let matched = false;\n    for(const s of suites) {\n      // `matchingProofs` is a map of promises that resolve to whether a\n      // proof matches a suite; multiple purposes and suites may be checked\n      // in parallel so a promise queue is used to prevent duplicate work\n      let matchingProofs = suiteMatchQueue.get(s);\n      if(!matchingProofs) {\n        suiteMatchQueue.set(s, matchingProofs = new Map());\n      }\n      let promise = matchingProofs.get(proof);\n      if(!promise) {\n        promise = s.matchProof({proof, document, documentLoader, expansionMap});\n        matchingProofs.set(proof, promise);\n      }\n      if(await promise) {\n        // found the matching suite for the proof; there should only be one\n        // suite that can verify a particular proof; add the proof to the\n        // map of proofs to be verified along with the matching suite\n        matched = true;\n        proofToSuite.set(proof, s);\n        break;\n      }\n    }\n\n    if(matched) {\n      // note proof was a match for the purpose and an acceptable suite; it\n      // will need to be verified by the suite and then validated against the\n      // purpose\n      const matches = purposeToProofs.get(purpose);\n      if(matches) {\n        matches.push(proof);\n      } else {\n        purposeToProofs.set(purpose, [proof]);\n      }\n    }\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}