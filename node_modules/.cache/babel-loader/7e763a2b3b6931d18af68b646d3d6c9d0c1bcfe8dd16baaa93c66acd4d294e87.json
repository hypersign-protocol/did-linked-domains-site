{"ast":null,"code":"/*\n * Copyright (c) 2017 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n\nrequire(\"core-js/modules/es.array.push.js\");\nconst {\n  parseLinkHeader,\n  buildHeaders\n} = require('../util');\nconst {\n  LINK_HEADER_CONTEXT\n} = require('../constants');\nconst JsonLdError = require('../JsonLdError');\nconst RequestQueue = require('../RequestQueue');\nconst {\n  prependBase\n} = require('../url');\n\n/**\n * Creates a built-in node document loader.\n *\n * @param options the options to use:\n *          secure: require all URLs to use HTTPS.\n *          strictSSL: true to require SSL certificates to be valid,\n *            false not to (default: true).\n *          maxRedirects: the maximum number of redirects to permit, none by\n *            default.\n *          request: the object which will make the request, default is\n *            provided by `https://www.npmjs.com/package/request`.\n *          headers: an object (map) of headers which will be passed as request\n *            headers for the requested document. Accept is not allowed.\n *\n * @return the node document loader.\n */\nmodule.exports = ({\n  secure,\n  strictSSL = true,\n  maxRedirects = -1,\n  request,\n  headers = {}\n} = {\n  strictSSL: true,\n  maxRedirects: -1,\n  headers: {}\n}) => {\n  headers = buildHeaders(headers);\n  // TODO: use `axios`\n  request = request || require('request');\n  const http = require('http');\n  const queue = new RequestQueue();\n  return queue.wrapLoader(function (url) {\n    return loadDocument(url, []);\n  });\n  async function loadDocument(url, redirects) {\n    if (url.indexOf('http:') !== 0 && url.indexOf('https:') !== 0) {\n      throw new JsonLdError('URL could not be dereferenced; only \"http\" and \"https\" URLs are ' + 'supported.', 'jsonld.InvalidUrl', {\n        code: 'loading document failed',\n        url\n      });\n    }\n    if (secure && url.indexOf('https') !== 0) {\n      throw new JsonLdError('URL could not be dereferenced; secure mode is enabled and ' + 'the URL\\'s scheme is not \"https\".', 'jsonld.InvalidUrl', {\n        code: 'loading document failed',\n        url\n      });\n    }\n    // TODO: disable cache until HTTP caching implemented\n    let doc = null; //cache.get(url);\n    if (doc !== null) {\n      return doc;\n    }\n    let result;\n    let alternate = null;\n    try {\n      result = await _request(request, {\n        url,\n        headers,\n        strictSSL,\n        followRedirect: false\n      });\n    } catch (e) {\n      throw new JsonLdError('URL could not be dereferenced, an error occurred.', 'jsonld.LoadDocumentError', {\n        code: 'loading document failed',\n        url,\n        cause: e\n      });\n    }\n    const {\n      res,\n      body\n    } = result;\n    doc = {\n      contextUrl: null,\n      documentUrl: url,\n      document: body || null\n    };\n\n    // handle error\n    const statusText = http.STATUS_CODES[res.statusCode];\n    if (res.statusCode >= 400) {\n      throw new JsonLdError(`URL \"${url}\" could not be dereferenced: ${statusText}`, 'jsonld.InvalidUrl', {\n        code: 'loading document failed',\n        url,\n        httpStatusCode: res.statusCode\n      });\n    }\n\n    // handle Link Header\n    if (res.headers.link && res.headers['content-type'] !== 'application/ld+json') {\n      // only 1 related link header permitted\n      const linkHeaders = parseLinkHeader(res.headers.link);\n      const linkedContext = linkHeaders[LINK_HEADER_CONTEXT];\n      if (Array.isArray(linkedContext)) {\n        throw new JsonLdError('URL could not be dereferenced, it has more than one associated ' + 'HTTP Link Header.', 'jsonld.InvalidUrl', {\n          code: 'multiple context link headers',\n          url\n        });\n      }\n      if (linkedContext) {\n        doc.contextUrl = linkedContext.target;\n      }\n\n      // \"alternate\" link header is a redirect\n      alternate = linkHeaders['alternate'];\n      if (alternate && alternate.type == 'application/ld+json' && !(res.headers['content-type'] || '').match(/^application\\/(\\w*\\+)?json$/)) {\n        res.headers.location = prependBase(url, alternate.target);\n      }\n    }\n\n    // handle redirect\n    if ((alternate || res.statusCode >= 300 && res.statusCode < 400) && res.headers.location) {\n      if (redirects.length === maxRedirects) {\n        throw new JsonLdError('URL could not be dereferenced; there were too many redirects.', 'jsonld.TooManyRedirects', {\n          code: 'loading document failed',\n          url,\n          httpStatusCode: res.statusCode,\n          redirects\n        });\n      }\n      if (redirects.indexOf(url) !== -1) {\n        throw new JsonLdError('URL could not be dereferenced; infinite redirection was detected.', 'jsonld.InfiniteRedirectDetected', {\n          code: 'recursive context inclusion',\n          url,\n          httpStatusCode: res.statusCode,\n          redirects\n        });\n      }\n      redirects.push(url);\n      return loadDocument(res.headers.location, redirects);\n    }\n\n    // cache for each redirected URL\n    redirects.push(url);\n    // TODO: disable cache until HTTP caching implemented\n    /*\n    for(let i = 0; i < redirects.length; ++i) {\n      cache.set(\n        redirects[i],\n        {contextUrl: null, documentUrl: redirects[i], document: body});\n    }\n    */\n\n    return doc;\n  }\n};\nfunction _request(request, options) {\n  return new Promise((resolve, reject) => {\n    request(options, (err, res, body) => {\n      if (err) {\n        reject(err);\n      } else {\n        resolve({\n          res,\n          body\n        });\n      }\n    });\n  });\n}","map":{"version":3,"names":["require","parseLinkHeader","buildHeaders","LINK_HEADER_CONTEXT","JsonLdError","RequestQueue","prependBase","module","exports","secure","strictSSL","maxRedirects","request","headers","http","queue","wrapLoader","url","loadDocument","redirects","indexOf","code","doc","result","alternate","_request","followRedirect","e","cause","res","body","contextUrl","documentUrl","document","statusText","STATUS_CODES","statusCode","httpStatusCode","link","linkHeaders","linkedContext","Array","isArray","target","type","match","location","length","push","options","Promise","resolve","reject","err"],"sources":["/home/pratap/hid-ssi-js-sdk/node_modules/ethereumeip712signature2021suite/node_modules/jsonld/lib/documentLoaders/node.js"],"sourcesContent":["/*\n * Copyright (c) 2017 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n\nconst {parseLinkHeader, buildHeaders} = require('../util');\nconst {LINK_HEADER_CONTEXT} = require('../constants');\nconst JsonLdError = require('../JsonLdError');\nconst RequestQueue = require('../RequestQueue');\nconst {prependBase} = require('../url');\n\n/**\n * Creates a built-in node document loader.\n *\n * @param options the options to use:\n *          secure: require all URLs to use HTTPS.\n *          strictSSL: true to require SSL certificates to be valid,\n *            false not to (default: true).\n *          maxRedirects: the maximum number of redirects to permit, none by\n *            default.\n *          request: the object which will make the request, default is\n *            provided by `https://www.npmjs.com/package/request`.\n *          headers: an object (map) of headers which will be passed as request\n *            headers for the requested document. Accept is not allowed.\n *\n * @return the node document loader.\n */\nmodule.exports = ({\n  secure,\n  strictSSL = true,\n  maxRedirects = -1,\n  request,\n  headers = {}\n} = {strictSSL: true, maxRedirects: -1, headers: {}}) => {\n  headers = buildHeaders(headers);\n  // TODO: use `axios`\n  request = request || require('request');\n  const http = require('http');\n\n  const queue = new RequestQueue();\n  return queue.wrapLoader(function(url) {\n    return loadDocument(url, []);\n  });\n\n  async function loadDocument(url, redirects) {\n    if(url.indexOf('http:') !== 0 && url.indexOf('https:') !== 0) {\n      throw new JsonLdError(\n        'URL could not be dereferenced; only \"http\" and \"https\" URLs are ' +\n        'supported.',\n        'jsonld.InvalidUrl', {code: 'loading document failed', url});\n    }\n    if(secure && url.indexOf('https') !== 0) {\n      throw new JsonLdError(\n        'URL could not be dereferenced; secure mode is enabled and ' +\n        'the URL\\'s scheme is not \"https\".',\n        'jsonld.InvalidUrl', {code: 'loading document failed', url});\n    }\n    // TODO: disable cache until HTTP caching implemented\n    let doc = null;//cache.get(url);\n    if(doc !== null) {\n      return doc;\n    }\n\n    let result;\n    let alternate = null;\n    try {\n      result = await _request(request, {\n        url,\n        headers,\n        strictSSL,\n        followRedirect: false\n      });\n    } catch(e) {\n      throw new JsonLdError(\n        'URL could not be dereferenced, an error occurred.',\n        'jsonld.LoadDocumentError',\n        {code: 'loading document failed', url, cause: e});\n    }\n\n    const {res, body} = result;\n\n    doc = {contextUrl: null, documentUrl: url, document: body || null};\n\n    // handle error\n    const statusText = http.STATUS_CODES[res.statusCode];\n    if(res.statusCode >= 400) {\n      throw new JsonLdError(\n        `URL \"${url}\" could not be dereferenced: ${statusText}`,\n        'jsonld.InvalidUrl', {\n          code: 'loading document failed',\n          url,\n          httpStatusCode: res.statusCode\n        });\n    }\n\n    // handle Link Header\n    if(res.headers.link &&\n      res.headers['content-type'] !== 'application/ld+json') {\n      // only 1 related link header permitted\n      const linkHeaders = parseLinkHeader(res.headers.link);\n      const linkedContext = linkHeaders[LINK_HEADER_CONTEXT];\n      if(Array.isArray(linkedContext)) {\n        throw new JsonLdError(\n          'URL could not be dereferenced, it has more than one associated ' +\n          'HTTP Link Header.',\n          'jsonld.InvalidUrl',\n          {code: 'multiple context link headers', url});\n      }\n      if(linkedContext) {\n        doc.contextUrl = linkedContext.target;\n      }\n\n      // \"alternate\" link header is a redirect\n      alternate = linkHeaders['alternate'];\n      if(alternate &&\n        alternate.type == 'application/ld+json' &&\n        !(res.headers['content-type'] || '')\n          .match(/^application\\/(\\w*\\+)?json$/)) {\n        res.headers.location = prependBase(url, alternate.target);\n      }\n    }\n\n    // handle redirect\n    if((alternate ||\n      res.statusCode >= 300 && res.statusCode < 400) && res.headers.location) {\n      if(redirects.length === maxRedirects) {\n        throw new JsonLdError(\n          'URL could not be dereferenced; there were too many redirects.',\n          'jsonld.TooManyRedirects', {\n            code: 'loading document failed',\n            url,\n            httpStatusCode: res.statusCode,\n            redirects\n          });\n      }\n      if(redirects.indexOf(url) !== -1) {\n        throw new JsonLdError(\n          'URL could not be dereferenced; infinite redirection was detected.',\n          'jsonld.InfiniteRedirectDetected', {\n            code: 'recursive context inclusion',\n            url,\n            httpStatusCode: res.statusCode,\n            redirects\n          });\n      }\n      redirects.push(url);\n      return loadDocument(res.headers.location, redirects);\n    }\n\n    // cache for each redirected URL\n    redirects.push(url);\n    // TODO: disable cache until HTTP caching implemented\n    /*\n    for(let i = 0; i < redirects.length; ++i) {\n      cache.set(\n        redirects[i],\n        {contextUrl: null, documentUrl: redirects[i], document: body});\n    }\n    */\n\n    return doc;\n  }\n};\n\nfunction _request(request, options) {\n  return new Promise((resolve, reject) => {\n    request(options, (err, res, body) => {\n      if(err) {\n        reject(err);\n      } else {\n        resolve({res, body});\n      }\n    });\n  });\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}