{"ast":null,"code":"/*!\n * Copyright (c) 2020-2021 Digital Bazaar, Inc. All rights reserved.\n */\nimport jsigs from 'jsonld-signatures';\nconst {\n  suites: {\n    LinkedDataSignature\n  }\n} = jsigs;\nconst base58btc = require('base58-universal');\nimport { Ed25519VerificationKey2020 } from '@digitalbazaar/ed25519-verification-key-2020';\nimport suiteContext2020 from 'ed25519-signature-2020-context';\nimport suiteContext2018 from 'ed25519-signature-2018-context';\n\n// 'https://w3id.org/security/suites/ed25519-2020/v1'\nconst SUITE_CONTEXT_URL = suiteContext2020.constants.CONTEXT_URL;\n// 'https://w3id.org/security/suites/ed25519-2018/v1'\nconst SUITE_CONTEXT_URL_2018 = suiteContext2018.constants.CONTEXT_URL;\n// multibase base58-btc header\nconst MULTIBASE_BASE58BTC_HEADER = 'z';\nexport class Ed25519Signature2020 extends LinkedDataSignature {\n  /**\n   * @param {object} options - Options hashmap.\n   *\n   * Either a `key` OR at least one of `signer`/`verifier` is required:\n   *\n   * @param {object} [options.key] - An optional key object (containing an\n   *   `id` property, and either `signer` or `verifier`, depending on the\n   *   intended operation. Useful for when the application is managing keys\n   *   itself (when using a KMS, you never have access to the private key,\n   *   and so should use the `signer` param instead).\n   * @param {Function} [options.signer] - Signer function that returns an\n   *   object with an async sign() method. This is useful when interfacing\n   *   with a KMS (since you don't get access to the private key and its\n   *   `signer()`, the KMS client gives you only the signer function to use).\n   * @param {Function} [options.verifier] - Verifier function that returns\n   *   an object with an async `verify()` method. Useful when working with a\n   *   KMS-provided verifier function.\n   *\n   * Advanced optional parameters and overrides:\n   *\n   * @param {object} [options.proof] - A JSON-LD document with options to use\n   *   for the `proof` node (e.g. any other custom fields can be provided here\n   *   using a context different from security-v2).\n   * @param {string|Date} [options.date] - Signing date to use if not passed.\n   * @param {boolean} [options.useNativeCanonize] - Whether to use a native\n   *   canonize algorithm.\n   */\n  constructor({\n    key,\n    signer,\n    verifier,\n    proof,\n    date,\n    useNativeCanonize\n  } = {}) {\n    super({\n      type: 'Ed25519Signature2020',\n      LDKeyClass: Ed25519VerificationKey2020,\n      contextUrl: SUITE_CONTEXT_URL,\n      key,\n      signer,\n      verifier,\n      proof,\n      date,\n      useNativeCanonize\n    });\n    // Some operations may be performed with Ed25519VerificationKey2018.\n    // So, Ed25519VerificationKey2020 is recommended, but not strictly required.\n    this.requiredKeyType = 'Ed25519VerificationKey2020';\n  }\n\n  /**\n   * Adds a signature (proofValue) field to the proof object. Called by\n   * LinkedDataSignature.createProof().\n   *\n   * @param {object} options - The options to use.\n   * @param {Uint8Array} options.verifyData - Data to be signed (extracted\n   *   from document, according to the suite's spec).\n   * @param {object} options.proof - Proof object (containing the proofPurpose,\n   *   verificationMethod, etc).\n   *\n   * @returns {Promise<object>} Resolves with the proof containing the signature\n   *   value.\n   */\n  async sign({\n    verifyData,\n    proof\n  }) {\n    if (!(this.signer && typeof this.signer.sign === 'function')) {\n      throw new Error('A signer API has not been specified.');\n    }\n    const signatureBytes = await this.signer.sign({\n      data: verifyData\n    });\n    proof.proofValue = MULTIBASE_BASE58BTC_HEADER + base58btc.encode(signatureBytes);\n    return proof;\n  }\n\n  /**\n   * Verifies the proof signature against the given data.\n   *\n   * @param {object} options - The options to use.\n   * @param {Uint8Array} options.verifyData - Canonicalized hashed data.\n   * @param {object} options.verificationMethod - Key object.\n   * @param {object} options.proof - The proof to be verified.\n   *\n   * @returns {Promise<boolean>} Resolves with the verification result.\n   */\n  async verifySignature({\n    verifyData,\n    verificationMethod,\n    proof\n  }) {\n    const {\n      proofValue\n    } = proof;\n    if (!(proofValue && typeof proofValue === 'string')) {\n      throw new TypeError('The proof does not include a valid \"proofValue\" property.');\n    }\n    if (proofValue[0] !== MULTIBASE_BASE58BTC_HEADER) {\n      throw new Error('Only base58btc multibase encoding is supported.');\n    }\n    const signatureBytes = base58btc.decode(proofValue.substr(1));\n    let {\n      verifier\n    } = this;\n    if (!verifier) {\n      const key = await this.LDKeyClass.from(verificationMethod);\n      verifier = key.verifier();\n    }\n    return verifier.verify({\n      data: verifyData,\n      signature: signatureBytes\n    });\n  }\n  async assertVerificationMethod({\n    verificationMethod\n  }) {\n    let contextUrl;\n    if (verificationMethod.type === 'Ed25519VerificationKey2020') {\n      contextUrl = SUITE_CONTEXT_URL;\n    } else if (verificationMethod.type === 'Ed25519VerificationKey2018') {\n      contextUrl = SUITE_CONTEXT_URL_2018;\n    } else {\n      throw new Error(`Unsupported key type \"${verificationMethod.type}\".`);\n    }\n    if (!_includesContext({\n      document: verificationMethod,\n      contextUrl\n    })) {\n      // For DID Documents, since keys do not have their own contexts,\n      // the suite context is usually provided by the documentLoader logic\n      throw new TypeError(`The verification method (key) must contain \"${contextUrl}\" context.`);\n    }\n\n    // ensure verification method has not been revoked\n    if (verificationMethod.revoked !== undefined) {\n      throw new Error('The verification method has been revoked.');\n    }\n  }\n  async getVerificationMethod({\n    proof,\n    documentLoader\n  }) {\n    if (this.key) {\n      // This happens most often during sign() operations. For verify(),\n      // the expectation is that the verification method will be fetched\n      // by the documentLoader (below), not provided as a `key` parameter.\n      return this.key.export({\n        publicKey: true\n      });\n    }\n    let {\n      verificationMethod\n    } = proof;\n    if (typeof verificationMethod === 'object') {\n      verificationMethod = verificationMethod.id;\n    }\n    if (!verificationMethod) {\n      throw new Error('No \"verificationMethod\" found in proof.');\n    }\n    const {\n      document\n    } = await documentLoader(verificationMethod);\n    verificationMethod = typeof document === 'string' ? JSON.parse(document) : document;\n    await this.assertVerificationMethod({\n      verificationMethod\n    });\n    if (verificationMethod.type === 'Ed25519VerificationKey2018') {\n      verificationMethod = (await Ed25519VerificationKey2020.fromEd25519VerificationKey2018({\n        keyPair: verificationMethod\n      })).export({\n        publicKey: true,\n        includeContext: true\n      });\n    }\n    return verificationMethod;\n  }\n  async matchProof({\n    proof,\n    document,\n    purpose,\n    documentLoader,\n    expansionMap\n  }) {\n    if (!_includesContext({\n      document,\n      contextUrl: SUITE_CONTEXT_URL\n    })) {\n      return false;\n    }\n    if (!(await super.matchProof({\n      proof,\n      document,\n      purpose,\n      documentLoader,\n      expansionMap\n    }))) {\n      return false;\n    }\n    if (!this.key) {\n      // no key specified, so assume this suite matches and it can be retrieved\n      return true;\n    }\n    const {\n      verificationMethod\n    } = proof;\n\n    // only match if the key specified matches the one in the proof\n    if (typeof verificationMethod === 'object') {\n      return verificationMethod.id === this.key.id;\n    }\n    return verificationMethod === this.key.id;\n  }\n}\n\n/**\n * Tests whether a provided JSON-LD document includes a context url in its\n * `@context` property.\n *\n * @param {object} options - Options hashmap.\n * @param {object} options.document - A JSON-LD document.\n * @param {string} options.contextUrl - A context url.\n *\n * @returns {boolean} Returns true if document includes context.\n */\nfunction _includesContext({\n  document,\n  contextUrl\n}) {\n  const context = document['@context'];\n  return context === contextUrl || Array.isArray(context) && context.includes(contextUrl);\n}\nEd25519Signature2020.CONTEXT_URL = SUITE_CONTEXT_URL;\nEd25519Signature2020.CONTEXT = suiteContext2020.contexts.get(SUITE_CONTEXT_URL);","map":{"version":3,"names":["jsigs","suites","LinkedDataSignature","base58btc","require","Ed25519VerificationKey2020","suiteContext2020","suiteContext2018","SUITE_CONTEXT_URL","constants","CONTEXT_URL","SUITE_CONTEXT_URL_2018","MULTIBASE_BASE58BTC_HEADER","Ed25519Signature2020","constructor","key","signer","verifier","proof","date","useNativeCanonize","type","LDKeyClass","contextUrl","requiredKeyType","sign","verifyData","Error","signatureBytes","data","proofValue","encode","verifySignature","verificationMethod","TypeError","decode","substr","from","verify","signature","assertVerificationMethod","_includesContext","document","revoked","undefined","getVerificationMethod","documentLoader","export","publicKey","id","JSON","parse","fromEd25519VerificationKey2018","keyPair","includeContext","matchProof","purpose","expansionMap","context","Array","isArray","includes","CONTEXT","contexts","get"],"sources":["/home/pratap/hid-ssi-js-sdk/node_modules/@digitalbazaar/ed25519-signature-2020/lib/Ed25519Signature2020.js"],"sourcesContent":["/*!\n * Copyright (c) 2020-2021 Digital Bazaar, Inc. All rights reserved.\n */\nimport jsigs from 'jsonld-signatures';\nconst {suites: {LinkedDataSignature}} = jsigs;\nconst base58btc = require('base58-universal');\nimport {\n  Ed25519VerificationKey2020\n} from '@digitalbazaar/ed25519-verification-key-2020';\nimport suiteContext2020 from 'ed25519-signature-2020-context';\nimport suiteContext2018 from 'ed25519-signature-2018-context';\n\n// 'https://w3id.org/security/suites/ed25519-2020/v1'\nconst SUITE_CONTEXT_URL = suiteContext2020.constants.CONTEXT_URL;\n// 'https://w3id.org/security/suites/ed25519-2018/v1'\nconst SUITE_CONTEXT_URL_2018 = suiteContext2018.constants.CONTEXT_URL;\n// multibase base58-btc header\nconst MULTIBASE_BASE58BTC_HEADER = 'z';\n\nexport class Ed25519Signature2020 extends LinkedDataSignature {\n  /**\n   * @param {object} options - Options hashmap.\n   *\n   * Either a `key` OR at least one of `signer`/`verifier` is required:\n   *\n   * @param {object} [options.key] - An optional key object (containing an\n   *   `id` property, and either `signer` or `verifier`, depending on the\n   *   intended operation. Useful for when the application is managing keys\n   *   itself (when using a KMS, you never have access to the private key,\n   *   and so should use the `signer` param instead).\n   * @param {Function} [options.signer] - Signer function that returns an\n   *   object with an async sign() method. This is useful when interfacing\n   *   with a KMS (since you don't get access to the private key and its\n   *   `signer()`, the KMS client gives you only the signer function to use).\n   * @param {Function} [options.verifier] - Verifier function that returns\n   *   an object with an async `verify()` method. Useful when working with a\n   *   KMS-provided verifier function.\n   *\n   * Advanced optional parameters and overrides:\n   *\n   * @param {object} [options.proof] - A JSON-LD document with options to use\n   *   for the `proof` node (e.g. any other custom fields can be provided here\n   *   using a context different from security-v2).\n   * @param {string|Date} [options.date] - Signing date to use if not passed.\n   * @param {boolean} [options.useNativeCanonize] - Whether to use a native\n   *   canonize algorithm.\n   */\n  constructor({\n    key, signer, verifier, proof, date, useNativeCanonize\n  } = {}) {\n    super({\n      type: 'Ed25519Signature2020', LDKeyClass: Ed25519VerificationKey2020,\n      contextUrl: SUITE_CONTEXT_URL,\n      key, signer, verifier, proof, date, useNativeCanonize\n    });\n    // Some operations may be performed with Ed25519VerificationKey2018.\n    // So, Ed25519VerificationKey2020 is recommended, but not strictly required.\n    this.requiredKeyType = 'Ed25519VerificationKey2020';\n  }\n\n  /**\n   * Adds a signature (proofValue) field to the proof object. Called by\n   * LinkedDataSignature.createProof().\n   *\n   * @param {object} options - The options to use.\n   * @param {Uint8Array} options.verifyData - Data to be signed (extracted\n   *   from document, according to the suite's spec).\n   * @param {object} options.proof - Proof object (containing the proofPurpose,\n   *   verificationMethod, etc).\n   *\n   * @returns {Promise<object>} Resolves with the proof containing the signature\n   *   value.\n   */\n  async sign({verifyData, proof}) {\n    if(!(this.signer && typeof this.signer.sign === 'function')) {\n      throw new Error('A signer API has not been specified.');\n    }\n\n    const signatureBytes = await this.signer.sign({data: verifyData});\n    proof.proofValue =\n      MULTIBASE_BASE58BTC_HEADER + base58btc.encode(signatureBytes);\n\n    return proof;\n  }\n\n  /**\n   * Verifies the proof signature against the given data.\n   *\n   * @param {object} options - The options to use.\n   * @param {Uint8Array} options.verifyData - Canonicalized hashed data.\n   * @param {object} options.verificationMethod - Key object.\n   * @param {object} options.proof - The proof to be verified.\n   *\n   * @returns {Promise<boolean>} Resolves with the verification result.\n   */\n  async verifySignature({verifyData, verificationMethod, proof}) {\n    const {proofValue} = proof;\n    if(!(proofValue && typeof proofValue === 'string')) {\n      throw new TypeError(\n        'The proof does not include a valid \"proofValue\" property.');\n    }\n    if(proofValue[0] !== MULTIBASE_BASE58BTC_HEADER) {\n      throw new Error('Only base58btc multibase encoding is supported.');\n    }\n    const signatureBytes = base58btc.decode(proofValue.substr(1));\n\n    let {verifier} = this;\n    if(!verifier) {\n      const key = await this.LDKeyClass.from(verificationMethod);\n      verifier = key.verifier();\n    }\n    return verifier.verify({data: verifyData, signature: signatureBytes});\n  }\n\n  async assertVerificationMethod({verificationMethod}) {\n    let contextUrl;\n    if(verificationMethod.type === 'Ed25519VerificationKey2020') {\n      contextUrl = SUITE_CONTEXT_URL;\n    } else if(verificationMethod.type === 'Ed25519VerificationKey2018') {\n      contextUrl = SUITE_CONTEXT_URL_2018;\n    } else {\n      throw new Error(`Unsupported key type \"${verificationMethod.type}\".`);\n    }\n    if(!_includesContext({\n      document: verificationMethod, contextUrl\n    })) {\n      // For DID Documents, since keys do not have their own contexts,\n      // the suite context is usually provided by the documentLoader logic\n      throw new TypeError(\n        `The verification method (key) must contain \"${contextUrl}\" context.`\n      );\n    }\n\n    // ensure verification method has not been revoked\n    if(verificationMethod.revoked !== undefined) {\n      throw new Error('The verification method has been revoked.');\n    }\n  }\n\n  async getVerificationMethod({proof, documentLoader}) {\n    if(this.key) {\n      // This happens most often during sign() operations. For verify(),\n      // the expectation is that the verification method will be fetched\n      // by the documentLoader (below), not provided as a `key` parameter.\n      return this.key.export({publicKey: true});\n    }\n\n    let {verificationMethod} = proof;\n\n    if(typeof verificationMethod === 'object') {\n      verificationMethod = verificationMethod.id;\n    }\n\n    if(!verificationMethod) {\n      throw new Error('No \"verificationMethod\" found in proof.');\n    }\n\n    const {document} = await documentLoader(verificationMethod);\n\n    verificationMethod = typeof document === 'string' ?\n      JSON.parse(document) : document;\n\n    await this.assertVerificationMethod({verificationMethod});\n    if(verificationMethod.type === 'Ed25519VerificationKey2018') {\n      verificationMethod = (await Ed25519VerificationKey2020\n        .fromEd25519VerificationKey2018({keyPair: verificationMethod}))\n        .export({publicKey: true, includeContext: true});\n    }\n    return verificationMethod;\n  }\n\n  async matchProof({proof, document, purpose, documentLoader, expansionMap}) {\n    if(!_includesContext({document, contextUrl: SUITE_CONTEXT_URL})) {\n      return false;\n    }\n\n    if(!await super.matchProof({proof, document, purpose, documentLoader,\n      expansionMap})) {\n      return false;\n    }\n    if(!this.key) {\n      // no key specified, so assume this suite matches and it can be retrieved\n      return true;\n    }\n\n    const {verificationMethod} = proof;\n\n    // only match if the key specified matches the one in the proof\n    if(typeof verificationMethod === 'object') {\n      return verificationMethod.id === this.key.id;\n    }\n    return verificationMethod === this.key.id;\n  }\n}\n\n/**\n * Tests whether a provided JSON-LD document includes a context url in its\n * `@context` property.\n *\n * @param {object} options - Options hashmap.\n * @param {object} options.document - A JSON-LD document.\n * @param {string} options.contextUrl - A context url.\n *\n * @returns {boolean} Returns true if document includes context.\n */\nfunction _includesContext({document, contextUrl}) {\n  const context = document['@context'];\n  return context === contextUrl ||\n    (Array.isArray(context) && context.includes(contextUrl));\n}\n\nEd25519Signature2020.CONTEXT_URL = SUITE_CONTEXT_URL;\nEd25519Signature2020.CONTEXT = suiteContext2020.contexts.get(SUITE_CONTEXT_URL);\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}