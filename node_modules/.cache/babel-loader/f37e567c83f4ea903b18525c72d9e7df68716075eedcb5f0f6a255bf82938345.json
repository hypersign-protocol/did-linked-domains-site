{"ast":null,"code":"/*!\n * Copyright (c) 2010-2023 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n\n/* Core API */\nconst api = {};\nmodule.exports = api;\n\n/* API Constants */\nconst constants = require('./constants');\nObject.assign(api, constants);\n\n// TODO: support `ProofChain`\nconst ProofSet = require('./ProofSet');\nconst VerificationError = require('./VerificationError');\n\n/**\n * Derives a proof from the provided document, resulting in a new document\n * with a new `proof` on it as generated by the given cryptographic suite.\n *\n * @param {object} document - The JSON-LD document from which to derive a\n *   new proof.\n *\n * @param {object} options - Options hashmap.\n * @param {LinkedDataSignature} options.suite - The linked data signature\n *   cryptographic suite, containing private key material, with which to sign\n *   the document.\n *\n * @param {ProofPurpose} purpose - A proof purpose instance that will\n *   match proofs to be verified and ensure they were created according to\n *   the appropriate purpose.\n *\n * @param {function} documentLoader  - A secure document loader (it is\n *   recommended to use one that provides static known documents, instead of\n *   fetching from the web) for returning contexts, controller documents, keys,\n *   and other relevant URLs needed for the proof.\n *\n * Advanced optional parameters and overrides:\n *\n * @param {function} [options.expansionMap] - NOT SUPPORTED; do not use.\n * @param {boolean} [options.addSuiteContext=true] - Toggles the default\n *   behavior of each signature suite enforcing the presence of its own\n *   `@context` (if it is not present, it's added to the context list).\n *\n * @returns {Promise<object>} Resolves with signed document.\n */\napi.derive = async function derive(document, {\n  suite,\n  purpose,\n  documentLoader,\n  addSuiteContext = true\n} = {}) {\n  if (typeof document !== 'object') {\n    throw new TypeError('The \"document\" parameter must be an object.');\n  }\n  // Ensure document contains the signature suite specific context URL\n  // or throw an error (in case an advanced user overrides the\n  // `addSuiteContext` flag to false).\n  suite.ensureSuiteContext({\n    document,\n    addSuiteContext\n  });\n  try {\n    return await new ProofSet().derive(document, {\n      suite,\n      purpose,\n      documentLoader\n    });\n  } catch (e) {\n    if (!documentLoader && e.name === 'jsonld.InvalidUrl') {\n      const {\n        details: {\n          url\n        }\n      } = e;\n      const err = new Error(`A URL \"${url}\" could not be fetched; you need to pass ` + '\"documentLoader\" or resolve the URL before calling \"derive\".');\n      err.cause = e;\n      throw err;\n    }\n    throw e;\n  }\n};\n\n/**\n * Cryptographically signs the provided document by adding a `proof` section,\n * based on the provided suite and proof purpose.\n *\n * @param {object} document - The JSON-LD document to be signed.\n *\n * @param {object} options - Options hashmap.\n * @param {LinkedDataSignature} options.suite - The linked data signature\n *   cryptographic suite with which to sign the document.\n *\n * @param {ProofPurpose} purpose - A proof purpose instance that will\n *   match proofs to be verified and ensure they were created according to\n *   the appropriate purpose.\n *\n * @param {function} documentLoader  - A secure document loader (it is\n *   recommended to use one that provides static known documents, instead of\n *   fetching from the web) for returning contexts, controller documents, keys,\n *   and other relevant URLs needed for the proof.\n *\n * Advanced optional parameters and overrides:\n *\n * @param {function} [options.expansionMap] - NOT SUPPORTED; do not use.\n * @param {boolean} [options.addSuiteContext=true] - Toggles the default\n *   behavior of each signature suite enforcing the presence of its own\n *   `@context` (if it is not present, it's added to the context list).\n *\n * @returns {Promise<object>} Resolves with signed document.\n */\napi.sign = async function sign(document, {\n  suite,\n  purpose,\n  documentLoader,\n  expansionMap,\n  addSuiteContext = true\n} = {}) {\n  if (expansionMap) {\n    throw new Error('\"expansionMap\" not supported.');\n  }\n  if (typeof document !== 'object') {\n    throw new TypeError('The \"document\" parameter must be an object.');\n  }\n  // Ensure document contains the signature suite specific context URL\n  // or throw an error (in case an advanced user overrides the `addSuiteContext`\n  // flag to false).\n  suite.ensureSuiteContext({\n    document,\n    addSuiteContext\n  });\n  try {\n    return await new ProofSet().add(document, {\n      suite,\n      purpose,\n      documentLoader\n    });\n  } catch (e) {\n    if (!documentLoader && e.name === 'jsonld.InvalidUrl') {\n      const {\n        details: {\n          url\n        }\n      } = e;\n      const err = new Error(`A URL \"${url}\" could not be fetched; you need to pass ` + '\"documentLoader\" or resolve the URL before calling \"sign\".');\n      err.cause = e;\n      throw err;\n    }\n    throw e;\n  }\n};\n\n/**\n * Verifies the linked data signature on the provided document.\n *\n * @param {object} document - The JSON-LD document with one or more proofs to be\n *   verified.\n *\n * @param {object} options - The options to use.\n * @param {LinkedDataSignature|LinkedDataSignature[]} options.suite -\n *   Acceptable signature suite instances for verifying the proof(s).\n *\n * @param {ProofPurpose} purpose - A proof purpose instance that will\n *   match proofs to be verified and ensure they were created according to\n *   the appropriate purpose.\n *\n * Advanced optional parameters and overrides:\n *\n * @param {function} [options.documentLoader]  - A custom document loader,\n *   `Promise<RemoteDocument> documentLoader(url)`.\n * @param {function} [options.expansionMap] - NOT SUPPORTED; do not use.\n *\n * @return {Promise<{verified: boolean, results: Array,\n *   error: VerificationError}>}\n *   resolves with an object with a `verified` boolean property that is `true`\n *   if at least one proof matching the given purpose and suite verifies and\n *   `false` otherwise; a `results` property with an array of detailed results;\n *   if `false` an `error` property will be present, with `error.errors`\n *   containing all of the errors that occurred during the verification process.\n */\napi.verify = async function verify(document, {\n  suite,\n  purpose,\n  documentLoader,\n  expansionMap\n} = {}) {\n  if (expansionMap) {\n    throw new Error('\"expansionMap\" not supported.');\n  }\n  if (typeof document !== 'object') {\n    throw new TypeError('The \"document\" parameter must be an object.');\n  }\n  const result = await new ProofSet().verify(document, {\n    suite,\n    purpose,\n    documentLoader\n  });\n  const {\n    error\n  } = result;\n  if (error) {\n    if (!documentLoader && error.name === 'jsonld.InvalidUrl') {\n      const {\n        details: {\n          url\n        }\n      } = error;\n      const urlError = new Error(`A URL \"${url}\" could not be fetched; you need to pass ` + '\"documentLoader\" or resolve the URL before calling \"verify\".');\n      result.error = new VerificationError(urlError);\n    } else {\n      result.error = new VerificationError(error);\n    }\n  }\n  return result;\n};\n\n// expose suite classes\napi.suites = require('./suites').suites;\n\n// expose ProofPurpose classes to enable extensions\napi.purposes = require('./purposes').purposes;\n\n// expose document loader helpers\nObject.assign(api, require('./documentLoader'));","map":{"version":3,"names":["api","module","exports","constants","require","Object","assign","ProofSet","VerificationError","derive","document","suite","purpose","documentLoader","addSuiteContext","TypeError","ensureSuiteContext","e","name","details","url","err","Error","cause","sign","expansionMap","add","verify","result","error","urlError","suites","purposes"],"sources":["/home/pratap/domain-linkege/node_modules/jsonld-signatures/lib/jsonld-signatures.js"],"sourcesContent":["/*!\n * Copyright (c) 2010-2023 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n\n/* Core API */\nconst api = {};\nmodule.exports = api;\n\n/* API Constants */\nconst constants = require('./constants');\nObject.assign(api, constants);\n\n// TODO: support `ProofChain`\nconst ProofSet = require('./ProofSet');\nconst VerificationError = require('./VerificationError');\n\n/**\n * Derives a proof from the provided document, resulting in a new document\n * with a new `proof` on it as generated by the given cryptographic suite.\n *\n * @param {object} document - The JSON-LD document from which to derive a\n *   new proof.\n *\n * @param {object} options - Options hashmap.\n * @param {LinkedDataSignature} options.suite - The linked data signature\n *   cryptographic suite, containing private key material, with which to sign\n *   the document.\n *\n * @param {ProofPurpose} purpose - A proof purpose instance that will\n *   match proofs to be verified and ensure they were created according to\n *   the appropriate purpose.\n *\n * @param {function} documentLoader  - A secure document loader (it is\n *   recommended to use one that provides static known documents, instead of\n *   fetching from the web) for returning contexts, controller documents, keys,\n *   and other relevant URLs needed for the proof.\n *\n * Advanced optional parameters and overrides:\n *\n * @param {function} [options.expansionMap] - NOT SUPPORTED; do not use.\n * @param {boolean} [options.addSuiteContext=true] - Toggles the default\n *   behavior of each signature suite enforcing the presence of its own\n *   `@context` (if it is not present, it's added to the context list).\n *\n * @returns {Promise<object>} Resolves with signed document.\n */\napi.derive = async function derive(document, {\n  suite, purpose, documentLoader, addSuiteContext = true\n} = {}) {\n  if(typeof document !== 'object') {\n    throw new TypeError('The \"document\" parameter must be an object.');\n  }\n  // Ensure document contains the signature suite specific context URL\n  // or throw an error (in case an advanced user overrides the\n  // `addSuiteContext` flag to false).\n  suite.ensureSuiteContext({document, addSuiteContext});\n\n  try {\n    return await new ProofSet().derive(\n      document, {suite, purpose, documentLoader});\n  } catch(e) {\n    if(!documentLoader && e.name === 'jsonld.InvalidUrl') {\n      const {details: {url}} = e;\n      const err = new Error(\n        `A URL \"${url}\" could not be fetched; you need to pass ` +\n        '\"documentLoader\" or resolve the URL before calling \"derive\".');\n      err.cause = e;\n      throw err;\n    }\n    throw e;\n  }\n};\n\n/**\n * Cryptographically signs the provided document by adding a `proof` section,\n * based on the provided suite and proof purpose.\n *\n * @param {object} document - The JSON-LD document to be signed.\n *\n * @param {object} options - Options hashmap.\n * @param {LinkedDataSignature} options.suite - The linked data signature\n *   cryptographic suite with which to sign the document.\n *\n * @param {ProofPurpose} purpose - A proof purpose instance that will\n *   match proofs to be verified and ensure they were created according to\n *   the appropriate purpose.\n *\n * @param {function} documentLoader  - A secure document loader (it is\n *   recommended to use one that provides static known documents, instead of\n *   fetching from the web) for returning contexts, controller documents, keys,\n *   and other relevant URLs needed for the proof.\n *\n * Advanced optional parameters and overrides:\n *\n * @param {function} [options.expansionMap] - NOT SUPPORTED; do not use.\n * @param {boolean} [options.addSuiteContext=true] - Toggles the default\n *   behavior of each signature suite enforcing the presence of its own\n *   `@context` (if it is not present, it's added to the context list).\n *\n * @returns {Promise<object>} Resolves with signed document.\n */\napi.sign = async function sign(document, {\n  suite, purpose, documentLoader, expansionMap, addSuiteContext = true\n} = {}) {\n  if(expansionMap) {\n    throw new Error('\"expansionMap\" not supported.');\n  }\n  if(typeof document !== 'object') {\n    throw new TypeError('The \"document\" parameter must be an object.');\n  }\n  // Ensure document contains the signature suite specific context URL\n  // or throw an error (in case an advanced user overrides the `addSuiteContext`\n  // flag to false).\n  suite.ensureSuiteContext({document, addSuiteContext});\n\n  try {\n    return await new ProofSet().add(document, {suite, purpose, documentLoader});\n  } catch(e) {\n    if(!documentLoader && e.name === 'jsonld.InvalidUrl') {\n      const {details: {url}} = e;\n      const err = new Error(\n        `A URL \"${url}\" could not be fetched; you need to pass ` +\n        '\"documentLoader\" or resolve the URL before calling \"sign\".');\n      err.cause = e;\n      throw err;\n    }\n    throw e;\n  }\n};\n\n/**\n * Verifies the linked data signature on the provided document.\n *\n * @param {object} document - The JSON-LD document with one or more proofs to be\n *   verified.\n *\n * @param {object} options - The options to use.\n * @param {LinkedDataSignature|LinkedDataSignature[]} options.suite -\n *   Acceptable signature suite instances for verifying the proof(s).\n *\n * @param {ProofPurpose} purpose - A proof purpose instance that will\n *   match proofs to be verified and ensure they were created according to\n *   the appropriate purpose.\n *\n * Advanced optional parameters and overrides:\n *\n * @param {function} [options.documentLoader]  - A custom document loader,\n *   `Promise<RemoteDocument> documentLoader(url)`.\n * @param {function} [options.expansionMap] - NOT SUPPORTED; do not use.\n *\n * @return {Promise<{verified: boolean, results: Array,\n *   error: VerificationError}>}\n *   resolves with an object with a `verified` boolean property that is `true`\n *   if at least one proof matching the given purpose and suite verifies and\n *   `false` otherwise; a `results` property with an array of detailed results;\n *   if `false` an `error` property will be present, with `error.errors`\n *   containing all of the errors that occurred during the verification process.\n */\napi.verify = async function verify(document, {\n  suite, purpose, documentLoader, expansionMap\n} = {}) {\n  if(expansionMap) {\n    throw new Error('\"expansionMap\" not supported.');\n  }\n  if(typeof document !== 'object') {\n    throw new TypeError('The \"document\" parameter must be an object.');\n  }\n  const result = await new ProofSet().verify(\n    document, {suite, purpose, documentLoader});\n  const {error} = result;\n  if(error) {\n    if(!documentLoader && error.name === 'jsonld.InvalidUrl') {\n      const {details: {url}} = error;\n      const urlError = new Error(\n        `A URL \"${url}\" could not be fetched; you need to pass ` +\n        '\"documentLoader\" or resolve the URL before calling \"verify\".');\n      result.error = new VerificationError(urlError);\n    } else {\n      result.error = new VerificationError(error);\n    }\n  }\n  return result;\n};\n\n// expose suite classes\napi.suites = require('./suites').suites;\n\n// expose ProofPurpose classes to enable extensions\napi.purposes = require('./purposes').purposes;\n\n// expose document loader helpers\nObject.assign(api, require('./documentLoader'));\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}